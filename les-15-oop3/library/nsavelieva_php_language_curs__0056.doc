{\rtf1\ansi\ansicpg\deff0\deflang1049\deflangfe1049\deftab708{\fonttbl{\f0\fswiss\fprq2\fcharset204{\*\fname Arial CYR;}Arial;}{\f1\froman\fprq2\fcharset204{\*\fname Times New Roman CYR;}Times New Roman;}{\f2\fmodern\fprq1\fcharset204{\*\fname Courier New CYR;}Courier New;}}{\info
{\title Курс "Язык программирования PHP"}
{\author Нина Владимировна Савельева }
}{\fet0 \ftnbj \ftnrstpg \ftnnar}{\stylesheet
{\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Normal;}
{\s1 \qc\snext0\b\f0\fs32\fi0\li0\ri0  heading 1;}
{\s2 \qc\snext0\b\f0\fs28\fi0\li0\ri0  heading 2;}
{\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0  heading 3;}
{\s4 \qc\snext0\lang1049\f1\fs26\b\fi0\li0\ri0  heading 4;}
{\s5 \qc\snext0\i\fs24\f1\b\fi0\li0\ri0  heading 5;}
{\s6 \qc\snext0\s6\f1\b\fs24\fi0  heading 6;}
{\s10 \qj\snext\f1\fs22\b0\i1\li3000\fi400\ri0  Epigraph;}
{\s11 \qj\snext0\f1\fs22\b1\i0\li3000\fi400\ri0  Epigraph Author;}
{\s12 \qj\snext0\f1\fs24\b0\i1\fi567\li0\ri0  Annotation;}
{\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600  Cite;}
{\s14 \qj\snext0\f1\fs22\b1\i1\li1701\ri600  Cite Author;}
{\s15 \ql\snext0\f1\fs24\b1\i0\li2000\ri600\sb12  Poem Title;}
{\s16 \ql\snext0\f1\fs24\b0\i0\li2000\ri600  Stanza;}
{\s17 \qj\snext0\f1\fs20\b0\i0\fi200\li0\ri0  FootNote;}
{\s18 \qj\snext\f1\fs18\b0\i1\li1500\fi400\ri0  FootNote Epigraph;}
{\s18 \qj\snext0\f1\fs18\b1\i0\li1500\fi400\ri0  FootNote Epigraph Author;}
{\s19 \ql\snext0\f1\fs18\b0\i0\li500\ri600  FootNote Stanza;}
{\s20 \qj\snext0\f1\fs18\b0\i0\li300\ri600  FootNote Cite;}
{\s21 \qj\snext0\f1\fs18\b1\i1\li350\ri600  FootNote Cite Author;}
{\s22 \ql\snext0\f1\fs20\b1\i0\li2000\ri600\sb12  FootNote Poem Title;}

}\paperw11906\paperh16838\margl1417\margr850\margt1134\margb1134


\s0 \f0\qc\fi0\li0\ri0 Спасибо, что скачали книгу в 
{\field{\*\fldinst{HYPERLINK "http://royallib.ru" }}{\fldrslt \ul бесплатной электронной библиотеке Royallib.ru}}
\par

\s0 \f0\qc\fi0\li0\ri0 
{\field{\*\fldinst{HYPERLINK "http://royallib.ru/author/saveleva_nina.html" }}{\fldrslt \ul Все книги автора}}
\par

\s0 \f0\qc\fi0\li0\ri0 
{\field{\*\fldinst{HYPERLINK "http://royallib.ru/book/saveleva_nina/kurs_yazik_programmirovaniya_PHP.html" }}{\fldrslt \ul Эта же книга в других форматах}}
\par
\par

\s0 \f0\qc\fi0\li0\ri0 Приятного чтения!\par
\par
\par
\par
\s2 \qc\snext0\b\f0\fs28\fi0\li0\ri0 Язык программирования PHP\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b PHP, в настоящее время, – один из наиболее популярных языков для реализации веб-приложений. Данный курс посвящен изучению его основ. Акцент делается на практическое применение полученных навыков.\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Язык PHP был создан для решения конкретной практической задачи в среде интернет (какой именно можно узнать, прочитав первую лекцию курса). Мы тоже постараемся не отвлекаться слишком сильно на теоретические рассуждения, и будем стремиться к решению какой-нибудь конкретной задачи в каждой из лекций. Большинство примеров взяты из реально существующей системы: виртуального музея истории информатики. Первая часть курса посвящена изучению основ синтаксиса и управляющим конструкциям. После этого рассматривается технология клиент-сервер, как основная сфера приложения языка PHP. Затем переходим к изучению наиболее полезных на наш взгляд встроенных функций и решению с их помощью практических задач. Хотя объектная модель в языке PHP не самая богатая, ее принципиальное наличие позволяет естественным образом описывать объектные модели данных. В качестве базовой модели будет рассмотрена модель документа виртуального музея информатики. После этого будет рассмотрен ряд прикладных аспектов: работа с файловой системой, с БД, строками, сессиями, DOM XML - все это позволит рассмотреть ключевые задачи практического использования языка.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Цель\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Знакомство с языком PHP, развитие навыков проектирования и программирования веб-приложений.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Предварительные знания\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Общие представления о языках программирования и клиент-серверных технологиях, язык HTML.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Предварительные курсы\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Применение каскадных таблиц стилей (CSS)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Введение в HTML\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Дополнительные курсы\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Введение в JavaScript \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Язык программирования Perl \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Язык программирования Python \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Введение в CGI  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Спецификация CSS2  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Спецификация языка HTML  \par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Введение в PHP\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b История PHP\b0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Язык PHP был разработан как инструмент для решения чисто практических задач. Его создатель, Расмус Лердорф, хотел знать, сколько человек читают его online-резюме, и написал для этого простенькую CGI-оболочку на языке Perl, т.е. это был набор Perl-скриптов, предназначенных исключительно для определенной цели – сбора статистики посещений.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Для справки.\b0   CGI (Common Gateway Interface – общий интерфейс шлюзов) является стандартом, который предназначен для создания серверных приложений, работающих по протоколу HTTP. Такие приложения (их называют шлюзами или CGI-программами) запускаются сервером в режиме реального времени. Сервер передает запросы пользователя CGI-программе, которая их обрабатывает и возвращает результат своей работы на экран пользователя. Таким образом, посетитель получает динамическую информацию, которая может изменяться в результате влияния различных факторов. Сам шлюз (скрипт CGI) может быть написан на различных языках программирования – Cи/C++, Fortran, Perl, TCL, UNIX Shell, Visual Basic, Python и др.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Вскоре выяснилось, что оболочка обладает небольшой производительностью, и пришлось переписать ее заново, но уже на языке Си. После этого исходники были выложены на всеобщее обозрение для исправления ошибок и дополнения. Пользователи сервера, где располагался сайт с первой версией PHP, заинтересовались инструментом, появились желающие его использовать. Так что скоро PHP превратился в самостоятельный проект, и в начале 1995 года вышла первая известная версия продукта, называвшаяся Personal Home Page Tools (средства для персональной домашней страницы). Средства эти были более чем скромными: анализатор кода, понимающий всего лишь несколько специальных команд, и набор утилит, полезных для создания гостевой книги, счетчика посещений, чата и т.п.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 К середине 1995 года после основательной переработки появилась вторая версия продукта, названная PHP/FI (Personal Home Page / Forms Interpreter – персональная домашняя страница/ интерпретатор форм). Она включала набор базовых возможностей сегодняшнего PHP, возможность автоматически обрабатывать html-формы и встраиваться в html-коды. Синтаксис PHP/FI сильно напоминал синтаксис Perl, но был более простым.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В 1997 вышла вторая версия Cи-реализации PHP – PHP/FI 2.0. К тому моменту PHP использовали уже несколько тысяч людей по всему миру, примерно с 50 тыс. доменов, что составляло около 1% всего числа доменов Internet. Число разработчиков PHP увеличилось до нескольких человек, но, несмотря на это, PHP/FI 2.0 все еще оставался крупным проектом одного человека. Официально PHP/FI 2.0 вышел только в ноябре 1997 года, просуществовав до этого в основном в бета-версиях. Вскоре после выхода его заменили альфа-версии PHP 3.0.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 PHP 3.0 была первой версией, напоминающей PHP, каким мы знаем его сегодня. Он очень сильно отличался от PHP/FI 2.0 и появился опять же как инструмент для решения конкретной прикладной задачи. Его создатели, Энди Гутманс (Andi Gutmans) и Зив Сураски (Zeev Suraski), в 1997 году переписали заново код PHP/FI, поскольку он показался им непригодным для разработки приложения электронной коммерции, над которым они работали. Для того чтобы получить помощь в реализации проекта от разработчиков PHP/FI, Гутманс и Сураски решили объединиться с ними и объявить PHP3 официальным преемником PHP/FI. После объединения разработка PHP/FI была полностью прекращена.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Одной из сильных сторон PHP 3.0 была возможность расширения ядра. Именно свойство расширяемости PHP 3.0 привлекло внимание множества разработчиков, желающих добавить свой модуль расширения. Кроме того, PHP 3.0 предоставляла широкие возможности для взаимодействия с базами данных, различными протоколами и API. Немаловажным шагом к успеху оказалась разработка нового, намного более мощного и полного синтаксиса с поддержкой ООП. С момента появления PHP 3.0 изменилась не только функциональность и внутреннее устройство языка, но и его название. В аббревиатуре PHP больше не было упоминания о персональном использовании, PHP стало сокращением (рекурсивным акронимом) от PHP: Hypertext Preprocessor, что значит «PHP: препроцессор гипертекста».\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 К концу 1998 года число пользователей PHP возросло до десятков тысяч. Сотни тысяч web-сайтов сообщали о том, что они работают с использованием этого языка. Почти на 10% серверов Internet был установлен PHP 3.0.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Официально PHP 3.0 вышел в июне 1998 года, после 9 месяцев публичного тестирования. А уже к зиме Энди Гутманс и Зив Сураски начали переработку ядра PHP. В их задачи входило увеличение производительности работы сложных приложений и улучшение модульности кода, лежащего в основе PHP.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Новое ядро было названо «Zend Engine» (от имен создателей: Zeev и Andi) и впервые представлено в середине 1999 года. PHP 4.0, основанный на этом ядре и принесший с собой набор дополнительных функций, официально вышел в мае 2000 года, почти через два года после своего предшественника, PHP 3.0. Помимо улучшения производительности, PHP 4.0 имел еще несколько ключевых нововведений, таких как поддержка сессий, буферизация вывода, более безопасные способы обработки вводимой пользователем информации и несколько новых языковых конструкций.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В настоящее время ведутся работы по улучшению Zend Engine и внедрению нововведений в PHP 5.0, первые бета-версии которого уже вышли в свет. Одно из существенных изменений произошло в объектной модели языка, ее основательно подлатали и добавили много новых возможностей.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Сегодня PHP используется сотнями тысяч разработчиков. Несколько миллионов сайтов написаны на PHP, что составляет более 20% доменов Internet.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Возможности PHP\b0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 «PHP может все», – заявляют его создатели. В первую очередь PHP используется для создания скриптов, работающих на стороне сервера, для этого его, собственно, и придумали. PHP способен решать те же задачи, что и любые другие CGI-скрипты, в том числе обрабатывать данные html-форм, динамически генерировать html страницы и т.п. Но есть и другие области, где может использоваться PHP. Всего выделяют три основные области применения PHP.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - Первая область, как уже говорилось, – это создание приложений (скриптов), которые исполняются на стороне сервера. PHP наиболее широко используется именно для создания такого рода скриптов. Для того чтобы работать таким образом, понадобится PHP-парсер (т.е. обработчик php-скриптов) и web-сервер для обработки скрипта, браузер для просмотра результатов работы скрипта, ну, и, конечно, какой-либо текстовый редактор для написания самого php-кода. Парсер PHP распространяется в виде CGI-программы или серверного модуля. Как установить его и web-сервер на свой компьютер, мы рассмотрим немного позднее. В этом курсе мы будем обсуждать, как правило, создание именно серверных приложений, как пример использования языка PHP.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - Вторая область – это создание скриптов, выполняющихся в командной строке. То есть с помощью PHP можно создавать такие скрипты, которые будут исполняться, вне зависимости от web-сервера и браузера, на конкретной машине. Для такой работы потребуется лишь парсер PHP (в этом случае его называют интерпретатором командной строки (cli, command line interpreter)). Этот способ работы подходит, например, для скриптов, которые должны выполняться регулярно с помощью различных планировщиков задач или для решения задач простой обработки текста.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - И последняя область – это создание GUI-приложений (графических интерфейсов), выполняющихся на стороне клиента. В принципе это не самый лучший способ использовать PHP, особенно для начинающих, но если вы уже досконально изучили PHP, то такие возможности языка могут оказаться весьма полезны. Для применения PHP в этой области потребуется специальный инструмент – PHP-GTK, который является расширением PHP.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Итак, область применения PHP достаточно обширна и разнообразна. Тем не менее существует множество других языков программирования, способных решать похожие задачи. Почему стоит изучать PHP? Что это нам дает? Во-первых, PHP очень прост в изучении. Достаточно ознакомиться лишь с основными правилами синтаксиса и принципами его работы, и можно начинать писать собственные программы, причем браться за такие задачи, решение которых на другом языке требовало бы серьезной подготовки.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Во-вторых, PHP поддерживается почти на всех известных платформах, почти во всех операционных системах и на самых разных серверах. Это тоже очень важно. Вряд ли кому-то захочется переходить, например, от работы под Windows к работе под Linux или от сервера IIS к серверу Apache только для того, чтобы изучить еще один язык программирования.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В PHP сочетаются две самые популярные парадигмы программирования – объектная и процедурная. В PHP4 более полно поддерживается процедурное программирование, но есть возможность писать программы и в объектном стиле. Уже в первых пробных версиях PHP5 большинство недочетов в реализации объектно-ориентированной модели языка, существующих в PHP4, устранены. Таким образом, можно выбрать наиболее привычный стиль работы.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если говорить о возможностях сегодняшнего PHP, то они выходят далеко за рамки тех, что были реализованы в его первых версиях. С помощью PHP можно создавать изображения, PDF-файлы, флэш-ролики, в него включена поддержка большого числа современных баз данных, встроены функции для работы с текстовыми данными любых форматов, включая XML, и функции для работы с файловой системой. PHP поддерживает взаимодействие с различными сервисами посредством соответствующих протоколов, таких как протокол управления доступом к директориям LDAP, протокол работы с сетевым оборудованием SNMP, протоколы передачи сообщений IMAP, NNTP и POP3, протокол передачи гипертекста HTTP и т.д.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Обращая внимание на взаимодействие между различными языками, следует упомянуть о поддержке объектов Java и возможности их использования в качестве объектов PHP. Для доступа к удаленным объектам можно использовать расширение CORBA.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для работы с текстовой информацией PHP унаследовал (с небольшими изменениями) механизмы работы с регулярными выражениями из языка Perl и UNIX-систем. Для обработки XML-документов можно использовать как стандарты DOM и SAX, так и API для XSLT-трансформаций.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для создания приложений электронной коммерции существует ряд полезных функций, таких как функции осуществления платежей Cybercash, CyberMUT, VeriSign Payflow Pro и CCVS.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Установка и настройка ПО\b0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Возможности языка мы обсудили, области применения рассмотрели, историю изучили. Теперь можно приступать к установке необходимого инструментария. Поскольку в качестве практической основы курса мы будем рассматривать задачи, решаемые с помощью технологии клиент-сервер, и PHP соответственно будет использоваться для создания скриптов, обрабатываемых сервером, нам нужно установить web-сервер и интерпретатор PHP. В качестве web-сервера выберем, например, Apache, как наиболее популярный среди web-разработчиков. Для просмотра результатов работы программ нам понадобится web-браузер, например Internet Explorer.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Установка Apache 1.3.29 под Windows XP\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Чтобы что-нибудь установить, нужно для начала иметь соответствующее программное обеспечение (ПО). Скачать ПО для установки Apache можно, например, с его официального сайта http://www.apache.org. Мы скачали файл apache_1.3.29-win3x86-no_src.exe. Это автоматический установщик (иначе – wizard) сервера Apache под Windows. Эта программа попытается почти самостоятельно (а точнее, с минимальными усилиями с вашей стороны) установить на компьютер какое-либо программное обеспечение, а в данном случае сервер. После запуска файла установщика появляется следующее окошко (рис. 1.1).\par
\par
\qc\par\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 \b Рис. 1.1.\b0            Автоматическая установка сервера Apache\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Чтобы установить HTTP-сервер Apache версии 1.3.29 на свой компьютер, нужно нажать на кнопку Next. Кстати говоря, эта же программа позволит изменить или удалить уже установленный web-сервер.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 После нажатия кнопки Next программа предложит согласиться с условиями лицензии (рис. 1.2).\par
\par
\qc\par\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 \b Рис. 1.2.\b0            Лицензионное соглашение\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Следующий экран будет содержать информацию о сервере Apache, и в частности о его Windows-реализации (его изображение не приводим).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 На следующем шаге нужно ввести имя сетевого домена, имя сервера и e-mail администратора. Программа попытается автоматически определить ваш домен и хост по настройкам компьютера (рис. 1.3).\par
\par
\qc\par\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 \b Рис. 1.3.\b0            Основная информация о сервере\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 После того как вы ввели данные в вышеприведенную форму, нужно выбрать тип установки: полная (устанавливаются все компоненты сервера) или определяемая пользователем (можно выбрать компоненты для установки) (рис. 1.4.).\par
\par
\qc\par\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 \b Рис. 1.4.\b0            Тип установки\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Выбор компонентов сервера не очень большой – это инструменты, необходимые для работы сервера и документация к нему (рис. 1.5).\par
\par
\qc\par\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 \b Рис. 1.5.\b0            Выбор компонент пользовательской установки\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Мы выберем полную установку. Тогда на следующем шаге программа предложит выбрать папку, в которую будет установлен сервер. По умолчанию сервер устанавливается в папку c:\\Program Files\\Apache Group\\ (рис. 1.6).\par
\par
\qc\par\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 \b Рис. 1.6.\b0            Папка, в которую будет установлен сервер\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 На следующем экране (рис. 1.7) потребуется подтвердить правильность введенных данных и начать установку. Из любого окна установки, включая и это, можно вернуться назад и изменить введенные ранее данные.\par
\par
\qc\par\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 \b Рис. 1.7.\b0            Начало установки\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 После нажатия кнопки Install начнется непосредственная установка сервера. От пользователя никаких дополнительных действий больше не требуется. С одной стороны, это хорошо, но есть у такой автоматизированной установки и некоторые недостатки. Например, домашние директории пользователей оказываются там же, где и файлы настроек сервера (c:\\Program Files\\Apache Group\\Apache\\users\\). Это небезопасно, если на компьютере работает несколько пользователей, не являющихся администраторами сервера. Но для начала можно ничего не менять. Допустим, мы запустили установщик, ввели все необходимые данные, он выполнил все операции успешно и говорит, что сервер установлен. Как проверить, действительно ли сервер установлен? Набираем в окне браузера http://localhost/. Если все установилось правильно, мы получим страничку приветствия сервера Apache (см. рис. 1.8).\par
\par
\qc\par\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 \b Рис. 1.8.\b0            Страница приветствия\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Итак, сервер установлен. Как теперь с ним работать? Откуда можно запускать скрипты и где должны находиться файлы пользователей? Файлы, которые должны быть обработаны сервером, можно сохранять либо в корне сервера (в нашем случае это c:\\Program Files\\Apache Group\\Apache\\htdocs ), либо в директориях пользователей (в нашем случае это c:\\Program Files\\Apache Group\\Apache\\users\\). Местоположение корня сервера и директорий пользователей прописано в настройках сервера, а точнее, в файле конфигурации httpd.conf (найти его можно в c:\\Program Files\\Apache Group\\Apache\\conf ). Для изменения этих путей нужно изменить соответствующие переменные в файле конфигурации сервера. Переменная в файле конфигурации ServerRoot отвечает за корневую директорию сервера, а переменная UserDir – за директорию, где будут располагаться файлы пользователей сервера (для более безопасной работы советуем изменить переменную UserDir на что-нибудь типа c:\\users\\). Чтобы получить доступ к файлу test.html, находящемуся в корне сервера, нужно набрать в браузере http://localhost/test.html (т. е. имя хоста, имя файла). Если же файл test.html находится в директории пользователя user, то для его просмотра нужно набрать в браузере http://localhost/~user/test.html.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Установка PHP 4.3.4 под Windows\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Перейдем к установке PHP. Скачать его дистрибутив можно с официального сайта PHP – http://www.php.net. Для удобства лучше выбрать автоматический инсталлятор, как и в случае с сервером. Самое первое окошко при такой установке PHP содержит приветствие и предупреждение о существовании авторских прав на этот продукт (рис. 1.9).\par
\par
\qc\par\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 \b Рис. 1.9.\b0            Программа автоматической установки PHP\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Далее нужно прочитать и согласиться (или не согласиться) с лицензией (рис. 1.10).\par
\par
\qc\par\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 \b Рис. 1.10.\b0            Лицензионное соглашение\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Затем выбираем тип установки: стандартный или для специалистов. Мы выберем стандартную установку (рис. 1.11).\par
\par
\qc\par\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 \b Рис. 1.11.\b0            Тип установки\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В следующем окне программа предложит выбрать директорию для установки PHP. Туда будут скопированы файлы библиотек, расширений, интерпретатор командной строки, модули и т.п. (рис. 1.12).\par
\par
\qc\par\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 \b Рис. 1.12.\b0            Выбор папки, в которую будет установлен PHP\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В следующем окошке предлагается ввести адрес SMTP-сервера, т.е. сервера отправки почтовых сообщений, и обратный адрес отправителя почты. Это окошко мы приводить не будем.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Далее предлагается выбрать из списка сервер, с которым будет работать PHP. Поскольку мы установили Apache, то выберем из списка именно его (рис. 1.13).\par
\par
\qc\par\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 \b Рис. 1.13.\b0            Выбор сервера, на котором будет работать PHP\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Следующее окошко начинает инсталляцию (рис. 1.14).\par
\par
\qc\par\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 \b Рис. 1.14.\b0            Начало автоматической установки PHP\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 После копирования необходимых файлов мы получили следующее сообщение (см. рис. 1.15):\par
\par
\qc\par\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 \b Рис. 1.15.\b0            Сообщение о невозможности автоматически настроить Apache для работы с PHP\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Это значит, что нужно настраивать сервер Apache для работы с PHP вручную.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Сначала следует выбрать, как мы хотим установить PHP, поскольку он поставляется в двух видах: CGI-скрипт (php.exe) или набор SAPI-модулей (например, php4isapi.dll), используемых сервером. Последний вариант обладает новыми возможностями, однако из-за недостаточной проработанности может функционировать недостаточно надежно, особенно на платформах старше Windows 2000 (может появляться куча ошибок 500, могут возникать сбои в других серверных модулях, таких как ASP). Так что, если нужна абсолютная стабильность – надо выбирать установку PHP в виде CGI выполнимого приложения.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если мы хотим установить PHP как серверный модуль, то в файле конфигурации сервера (httpd.conf) нужно написать:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 LoadModule php4_module \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                  c:/php/sapi/php4apache.dll\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 AddType application/x-httpd-php .php .phtml\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 AddModule mod_php4.c\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если мы устанавливаем PHP как cgi-программу, то в httpd.conf нужно написать:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ScriptAlias /php/ "c:/php/index.html" \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 AddType application/x-httpd-php .php .phtml \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Action application/x-httpd-php "/php/php.exe"\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В этом случае могут возникнуть проблемы с безопасностью. Рекомендуется исправить директорию, где лежит исполняемый файл интерпретатора (c:\\php\\), на что-нибудь менее очевидное (например, на c:\\abc_php\\). Мы советуем устанавливать PHP как серверный модуль.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Еще нужно отредактировать файл php.ini (в папке c:\\Windows), чтобы PHP «знал», где находится корневая директория сервера, где пользовательские директории, а где его собственные библиотеки расширений. За это в файле php.ini отвечают соответственно переменные doc_root, user_dir и extension_dir. Зададим их таким образом:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 doc_root = "c:\\Program Files\\Apache \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                        Group\\Apache\\htdocs"\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 user_dir = "c:\\users"\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 extension_dir = "c:\\php\\extensions"\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Кроме того, можно выбрать расширения, которые будут загружаться при запуске PHP. В реализацию PHP под Windows изначально входит очень мало расширений. Чтобы загрузить расширение, нужно раскомментировать в php.ini соответствующую ему строчку 'extension=php_*.dll'. Например, чтобы загрузить расширение для работы с MSSQL, нужно раскомментировать строку 'extension=php_mssql.dll'. Некоторые расширения требуют дополнительных библиотек. Поэтому рекомендуется скопировать дополнительные библиотеки в системную директорию (из папки c:\\php\\dlls). При первой установке следует настроить и протестировать PHP без расширений.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для того чтобы настройки, выполненные в конфигурационных файлах сервера и PHP вступили в силу, нужно перезапустить сервер.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Проверим, работает ли PHP. Для этого создадим тестовый файл (1.php) в директории пользователя (c:\\users\\nina) со следующим содержанием:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo"<h1>Привет всем!</h1>";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Запустим этот файл через браузер, набрав http://localhost/~nina/1.php. Если что-то не так, то на экран будет выведен текст этого файла. Если все хорошо, то наш скрипт должен обработаться сервером и вывести большими буквами строку «Привет всем!».\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Установка PHP под Linux\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Как и в случае с Windows, для Linux существует два способа установки PHP: используя пакеты и непосредственно компилируя исходный код PHP, который можно скачать с http://www.php.net. Мы остановимся на первом варианте и рассмотрим установку PHP+Apache на примере дистрибутива AltMaster2.2 (http://altlinux.ru).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для того чтобы установить apache, необходимо выбрать одноименный пакет. Это можно сделать, например, с помощью менеджера пакетов Synaptic. Воспользовавшись меню \b «Пакет -> Установить»\b0   (рис. 1.16) нужно выбрать интересующие пакеты. После этого необходимо перейти к установке выбранных пакетов с помощью меню \b «Действия -> Выполнить»\b0  . После установки Apache имеет смысл перезагрузиться или выполнить следующую команду:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 /etc/init.d/httpd start\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 # /etc/init.d/httpd start\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Starting httpd:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     [ OK ]\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Это приведет к запуску сервера и можно будет увидеть по адресу http://localhost почти такую же страницу, как и при установке Apache под Windows. Возможным отличием будет присутствие логотипа AltLinux.\par
\par
\qc\par\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 \b Рис. 1.16.\b0            Выбор пакета для установки Apache под Linux\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 После установки Apache можно приступить к установке непосредственно PHP. Опять же можно использовать PHP с помощью CGI и через модуль Apache. В первом случае достаточно пакета php и необходимых для его установки пакетов. Во втором случае необходимо дополнительно установить пакет mod_php. (рис. 1.17).\par
\par
\qc\par\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 \b Рис. 1.17.\b0            Выбор пакетов для установки PHP под Linux\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Менеджер пакетов Synaptic – это оболочка к программе apt-get, более подробно о ней можно узнать с помощью команды man apt-get. Воспользуемся утилитой apt-get для установки пакета mod_php. Команда apt-get build-dep mod_php установит пакеты, которые нам необходимы для инсталляции mod_php. Команда apt-get install mod_php завершит установку:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Как видно из приведенного листинга, скрипт установки самостоятельно перезагрузил сервер Apache. Также он самостоятельно внес изменения в конфигурационный файл Apache, полный путь до которого: /etc/httpd/conf/httpd.conf\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В httpd.conf добавлена строка:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Include conf/addon-modules/mod_php4.conf\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Содержимое файла mod_php4.conf\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 LoadModule php4_module \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                   usr/lib/apache/libphp4.so\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 AddModule mod_php4.c\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 AddType application/x-httpd-php \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                   .php .php4 .php3 .phtml\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 AddType application/x-httpd-php-source .phps\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 AddHandler application/x-httpd-php \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                   .php .php4 .php3 .phtml\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Как видно, изменения в httpd.conf подобны изменениям, которые мы вносили при установке под Windows.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь можно воспользоваться тестовым файлом для проверки работоспособности PHP+Apache. Создадим test.php со следующим содержанием:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo"<h1>Привет всем!</h1>";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Корень сервера находится /var/www/html/. Можно создать каталог test и разместить там файл test.php. Вызвав этот файл из браузера по его адресу (http://localhost/test/test.php), получим страничку с текстом «Привет всем».\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В заключение отметим, что процесс установки PHP с помощью пакетов в других дистрибутивах Linux принципиально не отличается от рассмотренного нами. Процесс установки из исходного кода в них же подробно описан. Стоит отметить, что «ручная» компоновка позволит настроить PHP под конкретные нужды, также возможен выигрыш в производительности.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Дистрибутив Денвер\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Мы достаточно подробно рассмотрели установку и настройку PHP для платформ Linux и Windows. Для тех, кто не желает вникать в устройство PHP и требуемых для его работы компонентов, существуют готовые дистрибутивы, содержащие все наиболее распространенные расширения PHP. Один из самых известных – дистрибутив Денвер (http://dklab.ru/chicken/web/). Инструкции по его установке можно прочитать на сайте разработчиков. Отметим только, что его установка достаточно проста и не требует особых навыков. Этот дистрибутив можно рекомендовать для начинающих программистов, желающих научиться работать с PHP. Для более серьезных задач лучше все же установить и настроить PHP самостоятельно.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Первая PHP-программа\b0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 По большому счету, первую PHP-программу вы уже создали, когда проверяли, работает ли интерпретатор PHP (в предыдущей главе). Сейчас мы хотим более подробно рассказать о том, что представляет собой PHP-программа и чем она отличается от программ на языках Cи, Perl и JavaScript. Рассмотрим пример.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <html>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   <head>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   <title>Пример</title>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   </head>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   <body>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   <?php \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   echo "<p>Привет, я – скрипт PHP!</p>"; \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   ?>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 </body>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 </html> \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Это простой HTML-файл, в который встроен с помощью специальных тегов код, написанный на языке PHP.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Как мы уже отмечали выше, PHP похож на Cи и Perl. Однако приведенная здесь программа сильно отличается от аналогичных по смыслу программ на языках Cи и Perl. Здесь не нужно писать кучу специальных команд для вывода HTML. Пишется непосредственно HTML-скрипт, в который можно встраивать PHP-код, осуществляющий какие-либо действия (например, выводящий текст на экран, как в нашем примере). Недостатком PHP по сравнению с Cи и Perl, несмотря на все усилия разработчиков, все еще является недостаточная быстрота выполнения сложных скриптов.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 PHP-скрипты – это программы, которые выполняются и обрабатываются сервером. Так что сравнивать его со скриптовыми языками типа JavaScript невозможно, потому что написанные на них скрипты выполняются на машине клиента. В чем отличие скриптов, выполняемых на сервере и на клиенте? Если скрипт обрабатывается сервером, клиенту посылаются только результаты работы скрипта. Например, если на сервере выполнялся скрипт, подобный приведенному выше, клиент получит сгенерированную HTML-страницу вида:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <html>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     <head>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     <title>Пример</title>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     </head>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     <body>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     <p>Привет, я – скрипт PHP!</p> \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     </body>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 </html> \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В этом случае клиент не знает, какой код выполняется. Можно даже сконфигурировать свой сервер таким образом, чтобы HTML-файлы обрабатывались процессором PHP, так что клиенты даже не смогут узнать, получают ли они обычный HTML-файл или результат выполнения скрипта. Если же скрипт обрабатывается клиентом (например, это программа на языке JavaScript), то клиент получает страницу, содержащую код скрипта.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Мы отмечали выше, что PHP-скрипты встраиваются в HTML-код. Возникает вопрос, каким образом? Есть несколько способов. Один из них приведен в самом первом примере – с помощью открывающего тега <?php и закрывающего тега ?>. Такого вида специальные теги позволяют переключаться между режимами HTML и PHP. Этот синтаксис наиболее предпочтителен, поскольку позволяет задействовать PHP в XML-совместимых программах (например, написанных на языке XHTML), но тем не менее можно использовать следующие альтернативные варианты (команда echo "Some text"; выводит на экран текст «Some text».):\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 1.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <? echo "Это простейшая\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0          инструкция для\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0          обработки PHP"; ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 2.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <script language="php"> \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  echo "Некоторые редакторы\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0        (FrontPage) предпочитают\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0        делать так";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 </script>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 3.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <% echo "Можно использовать теги\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0          в стиле ASP "; %>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Первый из этих способов не всегда доступен. Чтобы им пользоваться, нужно включить короткие теги либо с помощью функции short_tags() для PHP 3, либо включив установку short_open_tag в конфигурационном файле PHP, либо скомпилировав PHP с параметром --enable-short-tags. Даже если это включено по умолчанию в php.ini-dist, использование коротких тегов не рекомендуется. Второй способ аналогичен вставке, например, JavaScript-кода и использует для этого соответствующий html тег. Поэтому использовать его можно всегда, но это делается редко из-за его громоздкости. Третий способ можно применить, только если теги в стиле ASP были включены, используя конфигурационную установку asp_tags.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Когда PHP обрабатывает файл, он просто передает его текст, пока не встретит один из перечисленных специальных тегов, который сообщает ему о необходимости начать интерпретацию текста как кода PHP. Затем он выполняет весь найденный код до закрывающего тега, говорящего интерпретатору, что далее снова идет просто текст. Этот механизм позволяет внедрять PHP-код в HTML – все за пределами тегов PHP остается неизменным, тогда как внутри интерпретируется как код. Заметим также, что php-файл не похож на CGI-скрипт. Php файл не должен быть исполнимым или еще каким-либо образом помеченным.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для того чтобы отправить php-файл на обработку серверу, нужно в строке браузера набрать путь к этому файлу на сервере. Скрипты php должны располагаться там, где разрешен доступ через www, например там же, где лежит домашняя страничка. Если php-файл лежит на локальной машине, то его можно обработать с помощью интерпретатора командной строки.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Заключение\b0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Итак, мы получили представление о том, что такое язык PHP, как он появился и развивался, узнали, как и где его можно использовать, установили программное обеспечение и сделали все необходимые настройки для работы с ним, а также выяснили, что представляет собой php-программа. В следующих лекциях мы рассмотрим основы синтаксиса PHP и решим несколько полезных практических задач.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Основы синтаксиса\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Мы приступаем к изучению основных элементов синтаксиса языка PHP. Рассмотрим способы разделения инструкций и создания комментариев, переменные, константы, типы данных и операторы.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В качестве примера решим задачу создания заготовки электронного письма. Ее смысл заключается в следующем.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Допустим, у вас есть какое-то объявление и несколько разных людей, которым нужно это объявление отправить. Для этого вы делаете заготовку с содержанием объявления, внутри которого есть ряд изменяющихся (в зависимости от потенциального получателя) параметров.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Основной синтаксис\b0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Первое, что нужно знать относительно синтаксиса PHP, – это то, как он встраивается в HTML-код, как интерпретатор узнает, что это код на языке PHP. В предыдущей лекции мы уже говорили об этом. Повторяться не будем, отметим только, что в примерах мы чаще всего будем использовать вариант <?php ?>, и иногда сокращенный вариант <? ?>.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Разделение инструкций\b0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Программа на PHP (да и на любом другом языке программирования) – это набор команд (инструкций). Обработчику программы (парсеру) необходимо как-то отличать одну команду от другой. Для этого используются специальные символы – разделители. В PHP инструкции разделяются так же, как и в Cи или Perl, – каждое выражение заканчивается точкой с запятой.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Закрывающий тег «?>» также подразумевает конец инструкции, поэтому перед ним точку с запятой не ставят. Например, два следующих фрагмента кода эквивалентны:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo "Hello, world!"; // точка с запятой\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                       // в конце команды\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                       // обязательна\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo "Hello, world!" ?>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <!-- точка с запятой \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     опускается из-за "?>" -->\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Комментарии\b0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Часто при написании программ возникает необходимость делать какие-либо комментарии к коду, которые никак не влияют на сам код, а только поясняют его. Это важно при создании больших программ и в случае, если несколько человек работают над одной программой. При наличии комментариев в программе в ее коде разобраться гораздо проще. Кроме того, если решать задачу по частям, недоделанные части решения также удобно комментировать, чтобы не забыть о них в дальнейшем. Во всех языках программирования предусмотрена возможность включать комментарии в код программы. PHP поддерживает несколько видов комментариев: в стиле Cи, C++ и оболочки Unix. Символы // и # обозначают начало однострочных комментариев, /* и */ – соответственно начало и конец многострочных комментариев.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo "Меня зовут Вася";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   // Это однострочный комментарий \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   // в стиле С++\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo "Фамилия моя Петров"; \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 /* Это многострочный комментарий.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Здесь можно написать несколько строк. \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 При исполнении программы все, что\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 находится здесь (закомментировано),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 будет игнорировано. */\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo "Я изучаю PHP в INTUIT.ru";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   # Это комментарий в стиле \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   # оболочки Unix\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Переменные, константы и операторы\b0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Важным элементом каждого языка являются переменные, константы и операторы, применяемые к этим переменным и константам. Рассмотрим, как выделяются и обрабатываются эти элементы в PHP.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Переменные\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Переменная в PHP обозначается знаком доллара, за которым следует ее имя. Например:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $my_var\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Имя переменной чувствительно к регистру, т.е. переменные $my_var и $My_var различны.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Имена переменных соответствуют тем же правилам, что и остальные наименования в PHP: правильное имя переменной должно начинаться с буквы или символа подчеркивания с последующими в любом количестве буквами, цифрами или символами подчеркивания.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В PHP 3 переменные всегда присваивались по значению. То есть когда вы присваиваете выражение переменной, все значения оригинального выражения копируются в эту переменную. Это означает, к примеру, что после присвоения одной переменной значения другой изменение одной из них не влияет на значение другой.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $first = ' Text '; // Присваиваем $first\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                    // значение \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                    // ' Text '\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $second = $first; // Присваиваем $second\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                   // значение \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                   // переменной $first\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $first = ' New text '; // Изменяем\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                        // значение\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                        // $first \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                        // на ' New text '\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo "Переменая с именем first " .\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      "равна $first <br>"; \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         // выводим значение $first\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo "Переменая с именем second " .\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      "равна $second"; \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         // выводим значение $second\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Результат работы этого скрипта будет следующим:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Переменная с именем first равна New text \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Переменная с именем second равна Text \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 PHP 4, кроме этого, предлагает еще один способ присвоения значений переменным: присвоение по ссылке. Для того чтобы присвоить значение переменной по ссылке, это значение должно иметь имя, т.е. оно должно быть представлено какой-либо переменной. Чтобы указать, что значение одной переменной присваивается другой переменной по ссылке, нужно перед именем первой переменной поставить знак амперсанд &.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Рассмотрим тот же пример, что и выше, только будем присваивать значение переменной first переменной second по ссылке:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $first = ' Text '; // Присваиваем $first\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                    // значение ' Text '\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $second = &$first;  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 /* Делаем ссылку на $first через $second.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    Теперь значения этих переменных\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    будут всегда совпадать */\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // Изменим значение $first\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // на ' New text '\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $first = ' New text ';\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo "Переменная с именем first " .\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      "равна $first <br>"; \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // выведем значения обеих переменных\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo "Переменная с именем second " .\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      "равна $second";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Этот скрипт выведет следующее:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Переменная с именем first равна New text.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Переменная с именем second равна New text. \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 То есть вместе с переменной $first  изменилась и переменная $second.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Константы\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для хранения постоянных величин, т.е. таких величин, значение которых не меняется в ходе выполнения скрипта, используются константы. Такими величинами могут быть математические константы, пароли, пути к файлам и т.п. Основное отличие константы от переменной состоит в том, что ей нельзя присвоить значение больше одного раза и ее значение нельзя аннулировать после ее объявления. Кроме того, у константы нет приставки в виде знака доллара и ее нельзя определить простым присваиванием значения. Как же тогда можно определить константу? Для этого существует специальная функция define(). Ее синтаксис таков:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 define("Имя_константы", \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0        "Значение_константы", \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0        [Нечувствительность_к_регистру])\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 По умолчанию имена констант чувствительны к регистру. Для каждой константы это можно изменить, указав в качестве значения аргумента Нечувствительность_к_регистру значение True. Существует соглашение, по которому имена констант всегда пишутся в верхнем регистре.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Получить значение константы можно, указав ее имя. В отличие от переменных, не нужно предварять имя константы символом $. Кроме того, для получения значения константы можно использовать функцию constant() с именем константы в качестве параметра.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // определяем константу \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // PASSWORD\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 define("PASSWORD","qwerty"); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // определяем регистронезависимую \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // константу PI со значением 3.14\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 define("PI","3.14", True);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // выведет значение константы PASSWORD, \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // т.е. qwerty  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo (PASSWORD);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // тоже выведет qwerty  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo constant("PASSWORD");\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo (password);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 /* выведет password и предупреждение, \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    поскольку мы ввели регистрозависимую\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    константу PASSWORD */\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo pi;    \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // выведет 3.14, поскольку константа PI \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // регистронезависима по определению\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Кроме переменных, объявляемых пользователем, о которых мы только что рассказали, в PHP существует ряд констант, определяемых самим интерпретатором. Например, константа __FILE__ хранит имя файла программы (и путь к нему), которая выполняется в данный момент, __FUNCTION__ содержит имя функции, __CLASS__ – имя класса, PHP_VERSION – версия интерпретатора PHP. Полный список предопределенных констант можно получить, прочитав руководство по PHP.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Операторы\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Операторы позволяют выполнять различные действия с переменными, константами и выражениями. Мы еще не упоминали о том, что такое выражение. Выражение можно определить как все, что угодно, что имеет значение. Переменные и константы – это основные и наиболее простые формы выражений. Существует множество операций (и соответствующих им операторов), которые можно производить с выражениями. Рассмотрим некоторые из них подробнее.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 +\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Сложение\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $a + $b\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 -\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Вычитание\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $a - $b\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 *\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Умножение\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $a * $b\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 /\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Деление\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $a / $b\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 %\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Остаток от деления\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $a % $b\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 .\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Конкатенация (сложение строк)\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $c = $a . $b\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  (это строка, состоящая из $a и $b)\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 =\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Присваивание\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Переменной слева от оператора  будет присвоено значение,  полученное в результате выполнения каких-либо операций или переменной/константы с правой стороны\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $a = ($b = 4) +5;\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  ($a будет равна 9, $b будет равна 4)\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 +=\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Сокращение. Прибавляет к  переменной число и затем присваивает ей полученное значение\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $a += 5;\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  (эквивалентно $a = $a + 5;)\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 .=\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Сокращенно обозначает комбинацию операций конкатенации  и присваивания (сначала добавляется строка, потом полученная строка записывается в  переменную)\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $b = "Привет ";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $b .= "всем";\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В результате: $b="Привет всем"\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 and\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 И\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $a и $b истинны (True)\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $a and $b\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 &&\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 И\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $a && $b\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 or\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Или\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Хотя бы одна из переменных $a или $b истинна (возможно, что и обе)\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $a or $b\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ||\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Или\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $a || $b\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 xor\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Исключающее или\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Одна из переменных истинна.  Случай, когда они обе истинны, исключается\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $a xor $b\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 !\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Инверсия (NOT)\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если $a=True, то !$a=False и наоборот\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ! $a\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ==\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Равенство\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Значения переменных равны\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $a == $b\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ===\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эквивалентность\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Равны значения и типы переменных\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $a === $b\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 !=\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Неравенство\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Значения переменных не равны\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $a != $b\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Неравенство\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $a <> $b\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 !==\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Неэквивалентность\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Переменные не эквивалентны\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $a !== $b\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Меньше\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $a < $b\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 >\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Больше\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $a > $b\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <=\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Меньше или равно\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $a <= $b\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 >=\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Больше или равно\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $a >= $b\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ++$a\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Пре-инкремент\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Увеличивает $a  на единицу и возвращает $a\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $a=4;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo "Должно быть 4:" .$a++;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo "Должно быть 6:" .++$a;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $a++\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Пост-инкремент\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Возвращает $a, затем увеличивает $a на единицу\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 --$a\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Пре-декремент\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Уменьшает $a на единицу и возвращает $a\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $a--\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Пост-декремент\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Возвращает $a, затем уменьшает $a на единицу\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Типы данных\b0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 PHP поддерживает восемь простых типов данных.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Четыре скалярных типа:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - boolean (логический);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - integer (целый);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - float (с плавающей точкой);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - string (строковый).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Два смешанных типа:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - array (массив);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - object (объект).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 И два специальных типа:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - resource (ресурс);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - NULL.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В PHP не принято явное объявление типов переменных. Предпочтительнее, чтобы это делал сам интерпретатор во время выполнения программы в зависимости от контекста, в котором используется переменная. Рассмотрим по порядку все перечисленные типы данных.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Тип boolean (булев или логический тип)\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Этот простейший тип выражает истинность значения, то есть переменная этого типа может иметь только два значения – истина TRUE или ложь FALSE.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Чтобы определить булев тип, используют ключевое слово TRUE или FALSE. Оба регистронезависимы.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $test = True;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Логические переменные используются в различных управляющих конструкциях (циклах, условиях и т.п., более подробно речь о них пойдет в одной из следующих лекций). Иметь логический тип, т.е. принимать только два значения, истину или ложь, могут также и некоторые операторы (например, оператор  равенства). Они также используются в управляющих конструкциях для проверки каких-либо условий. Например, в условной конструкции проверяется истинность значения оператора или переменной и в зависимости от результата проверки выполняются те или иные действия. Здесь условие может быть истинно или ложно, что как раз и отражает переменная и оператор логического типа.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // Оператор '==' проверяет равенство\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // и возвращает \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // булево значение\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 if ($know == False) \{ // если $know \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                       // имеет значение \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                       // false\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo "Изучай PHP!";  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 if (!$know) \{ // то же самое, что\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0               // и выше, т.е. проверка \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0               // имеет ли $know значение\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0               // false\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo "Изучай PHP!";  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 /* оператор == проверяет, совпадает ли\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    значение переменной $action со строкой\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    "Изучить PHP". Если совпадает, то\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    возвращает true, иначе – false.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    Если возвращено true, то выполняется\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    то, что внутри фигурных скобок */\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 if ($action == "Изучить PHP")\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \{ echo "Начал изучать"; \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Тип integer (целые)\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Этот тип задает число из множества целых чисел Z = \{..., -2, -1, 0, 1, 2, ...\}. Целые могут быть указаны в десятичной, шестнадцатеричной или восьмеричной системе счисления, по желанию с предшествующим знаком «-» или «+».\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если вы используете восьмеричную систему счисления, вы должны предварить число 0 (нулем), для использования шестнадцатеричной системы нужно поставить перед числом 0x.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 # десятичное число\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $a = 1234;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 # отрицательное число  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $a = -123;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 # восьмеричное число (эквивалентно\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 # 83 в десятичной системе) \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $a = 0123;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 # шестнадцатеричное число (эквивалентно\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 # 26 в десятичной системе)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $a = 0x1A;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?> \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Размер целого зависит от платформы, хотя, как правило, максимальное значение около двух миллиардов (это 32-битное знаковое). Беззнаковые целые PHP не поддерживает.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если вы определите число, превышающее пределы целого типа, оно будет интерпретировано как число с плавающей точкой. Также если вы используете оператор, результатом работы которого будет число, превышающее пределы целого, вместо него будет возвращено число с плавающей точкой.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В PHP не существует оператора деления целых. Результатом 1/2 будет число с плавающей точкой 0.5. Вы можете привести значение к целому, что всегда округляет его в меньшую сторону, либо использовать функцию round(), округляющую значение по стандартным правилам. Для преобразования переменной к конкретному типу нужно перед переменной указать в скобках нужный тип. Например, для преобразования переменной $a=0.5 к целому типу необходимо написать (integer)(0.5) или (integer) $a или использовать сокращенную запись (int)(0.5). Возможность явного приведения типов по такому принципу существует для всех типов данных (конечно, не всегда значение одного типа можно перевести в другой тип). Мы не будем углубляться во все тонкости приведения типов, поскольку PHP делает это автоматически в зависимости от контекста.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Тип float (числа с плавающей точкой)\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Числа с плавающей точкой (они же числа двойной точности или действительные числа) могут быть определены при помощи любого из следующих синтаксисов:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $a = 1.234;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $b = 1.2e3;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $c = 7E-10;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?> \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Размер числа с плавающей точкой зависит от платформы, хотя максимум, как правило, ~1.8e308 с точностью около 14 десятичных цифр.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Тип string (строки)\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Строка – это набор символов. В PHP символ – это то же самое, что байт, это значит, что существует ровно 256 различных символов. Это также означает, что PHP не имеет встроенной поддержки Unicode. В PHP практически не существует ограничений на размер строк, поэтому нет абсолютно никаких причин беспокоиться об их длине.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Строка в PHP может быть определена тремя различными способами:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - с помощью одинарных кавычек;\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - с помощью двойных кавычек;\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - heredoc-синтаксисом.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Одинарные кавычки\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Простейший способ определить строку – это заключить ее в одинарные кавычки «'». Чтобы использовать одинарную кавычку внутри строки, как и во многих других языках, перед ней необходимо поставить символ обратной косой черты «\\», т. е. экранировать ее. Если обратная косая черта должна идти перед одинарной кавычкой либо быть в конце строки, необходимо продублировать ее «\\\\'».\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если внутри строки, заключенной в одинарные кавычки, обратный слэш «\\» встречается перед любым другим символом (отличным от «\\» и «'» ), то он рассматривается как обычный символ и выводится, как и все остальные. Поэтому обратную косую черту необходимо экранировать, только если она находится в конце строки, перед закрывающей кавычкой.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В PHP существует ряд комбинаций символов, начинающихся с символа обратной косой черты. Их называют управляющими последовательностями, и они имеют специальные значения, о которых мы расскажем немного позднее. Так вот, в отличие от двух других синтаксисов, переменные и управляющие последовательности для специальных символов, встречающиеся в строках, заключенных в одинарные кавычки, не обрабатываются.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo 'Также вы можете вставлять в строки\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     символ новой строки таким образом,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     поскольку это нормально';\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // Выведет: Чтобы вывести ' надо\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // перед ней поставить \\\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo 'Чтобы вывести \\' надо перед ' \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      'ней поставить \\\\';\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // Выведет: Вы хотите удалить C:\\*.*?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo 'Вы хотите удалить C:\\\\*.*?';\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // Выведет: Это не вставит: \\n\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // новую строку\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo 'Это не вставит: \\n новую строку';\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // Выведет: Переменные $expand также\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // $either не подставляются\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo 'Переменные $expand также $either' .\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      'не подставляются';\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?> \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Двойные кавычки\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если строка заключена в двойные кавычки «"», PHP распознает большее количество управляющих последовательностей для специальных символов. Некоторые из них приведены в таблице 2.7.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \\n\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Новая строка (LF или 0x0A (10) в ASCII)\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \\r\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Возврат каретки (CR или 0x0D (13) в ASCII)\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \\t\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Горизонтальная табуляция (HT или 0x09 (9) в ASCII)\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \\\\\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Обратная косая черта\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \\$\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Знак доллара\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \\"\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Двойная кавычка\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Повторяем, если вы захотите экранировать любой другой символ, обратная косая черта также будет напечатана!\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Самым важным свойством строк в двойных кавычках является обработка переменных.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Heredoc\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Другой способ определения строк – это использование heredoc-синтаксиса. В этом случае строка должна начинаться с символа <<<, после которого идет идентификатор. Заканчивается строка этим же идентификатором. Закрывающий идентификатор должен начинаться в первом столбце строки. Кроме того, идентификатор должен соответствовать тем же правилам именования, что и все остальные метки в PHP: содержать только буквенно-цифровые символы и знак подчеркивания и начинаться не с цифры или знака подчеркивания.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Heredoc-текст ведет себя так же, как и строка в двойных кавычках, при этом их не имея. Это означает, что вам нет необходимости экранировать кавычки в heredoc, но вы по-прежнему можете использовать перечисленные выше управляющие последовательности. Переменные внутри heredoc тоже обрабатываются.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $str = <<<EOD\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Пример строки,охватывающей несколько\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 строчек, с использованием\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 heredoc-синтаксиса\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 EOD;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // Здесь идентификатор – EOD. Ниже\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // идентификатор EOT\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $name = 'Вася';\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo <<<EOT\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Меня зовут "$name". \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 EOT;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // это выведет "Меня зовут "Вася"."\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?> \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Замечание: Поддержка heredoc была добавлена в PHP 4.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Тип array (массив)\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Массив в PHP представляет собой упорядоченную карту – тип, который преобразует значения в ключи. Этот тип оптимизирован в нескольких направлениях, поэтому вы можете использовать его как собственно массив, список (вектор), хеш-таблицу (являющуюся реализацией карты), стэк, очередь и т.д. Поскольку вы можете иметь в качестве значения другой массив PHP, можно также легко эмулировать деревья.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Определить массив можно с помощью конструкции array() или непосредственно задавая значения его элементам.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Определение при помощи array()\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 array ([key] => value,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0        [key1] => value1, ... )\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Языковая конструкция array() принимает в качестве параметров пары ключ => значение, разделенные запятыми. Символ => устанавливает соответствие между значением и его ключом. Ключ может быть как целым числом, так и строкой, а значение может быть любого имеющегося в PHP типа. Числовой ключ массива часто называют индексом. Индексирование массива в PHP начинается с нуля. Значение элемента массива можно получить, указав после имени массива в квадратных скобках ключ искомого элемента. Если ключ массива представляет собой стандартную запись целого числа, то он рассматривается как число, в противном случае – как строка. Поэтому запись $a["1"] равносильна записи $a[1], так же как и $a["-1"] равносильно $a[-1].\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $books = array ("php" =>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                 "PHP users guide",\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                 12 => true);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo $books["php"];\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 //выведет "PHP users guide"\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo $books[12];     //выведет 1\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?> \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если для элемента ключ не задан, то в качестве ключа берется максимальный числовой ключ, увеличенный на единицу. Если указать ключ, которому уже было присвоено какое-то значение, то оно будет перезаписано. Начиная с PHP 4.3.0, если максимальный ключ – отрицательное число, то следующим ключом массива будет ноль (0).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // массивы $arr и $arr1 эквиваленты\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $arr = array(5 => 43, 32, 56, "b" => 12);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $arr1 = array(5 => 43, 6 => 32,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0               7 => 56, "b" => 12);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?> \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если использовать в качестве ключа TRUE или FALSE, то его значение переводится соответственно в единицу и ноль типа integer. Если использовать NULL, то вместо ключа получим пустую строку. Можно использовать и саму пустую строку в качестве ключа, при этом ее надо брать в кавычки. Так что это не то же самое, что использование пустых квадратных скобок. Нельзя использовать в качестве ключа массивы и объекты.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Определение с помощью синтаксиса квадратных скобок\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Создать массив можно, просто записывая в него значения. Как мы уже говорили, значение элемента массива можно получить с помощью квадратных скобок, внутри которых нужно указать его ключ например, $book["php"]. Если указать новый ключ и новое значение например, $book["new_key"]="new_value", то в массив добавится новый элемент. Если мы не укажем ключ, а только присвоим значение $book[]="new_value", то новый элемент массива будет иметь числовой ключ, на единицу больший максимального существующего. Если массив, в который мы добавляем значения, еще не существует, то он будет создан.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $books["key"]= value; // добавили в массив\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                     // $books значение \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                     // value с ключом key\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $books[] = value1; /* добавили в массив\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                       значение value1 с\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                       ключом 13, поскольку\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                       максимальный ключ у\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                       нас был 12 */\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для того чтобы изменить конкретный элемент массива, нужно просто присвоить ему с его ключом новое значение. Изменить ключ элемента нельзя, можно только удалить элемент (пару ключ/значение) и добавить новую. Чтобы удалить элемент массива, нужно использовать функцию unset().\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $books = array ("php" =>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                 "PHP users guide",\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                 12 => true);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $books[] =\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  "Book about Perl"; // добавили элемент\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                     // с ключом (индексом)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                     // 13 это эквивалентно \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                     // $books[13] =\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                     // "Book about Perl";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $books["lisp"] =\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  123456; /* Это добавляет к массиву новый\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0             элемент с ключом "lisp" и\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0             значением 123456 */\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 unset($books[12]); // Это удаляет элемент\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                    // c ключом 12 из массива \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 unset ($books); // удаляет массив полностью\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?> \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Заметим, что, когда используются пустые квадратные скобки, максимальный числовой ключ ищется среди ключей, существующих в массиве с момента последнего переиндексирования. Переиндексировать массив можно с помощью функции array_values().\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $arr =\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  array ("a","b","c"); /* Создаем массив\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                          со значениями\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                          "a", "b" и "c".\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                          Поскольку ключи\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                          не указаны, они\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                          будут 0,1,2\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                          соответственно */\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 print_r($arr); // выводим массив (и ключи,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                // и значения)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 unset($arr[0]);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 unset($arr[1]);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 unset($arr[2]); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0          // удаляем из него все значения \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 print_r($arr);  // выводим массив (и ключи,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                 // и значения)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $arr[] = "aa";  // добавляем новый элемент\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                 // в массив. \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                 // Его индексом (ключом)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                 // будет 3, а не 0\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 print_r($arr);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $arr =\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  array_values($arr); // переиндексируем\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                      // массив \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $arr[] = "bb"; // ключом этого элемента\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                // будет 1\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 print_r($arr);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Результатом работы этого скрипта будет:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Array ( [0] => a [1] => b [2] => c ) \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Array ( ) \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Array ( [3] => aa ) \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Array ( [0] => aa [1] => bb ) \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Тип object (объекты)\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Объекты – тип данных, пришедший из объектно-ориентированного программирования (ООП). Согласно принципам ООП, класс – это набор объектов, обладающих определенными свойствами и методами работы с ним, а объект соответственно – экземпляр класса. Например, программисты – это класс людей, которые пишут программы, изучают компьютерную литературу и, кроме того, как все люди, имеют имя и фамилию. Теперь, если взять одного конкретного программиста, Васю Иванова, то можно сказать, что он является объектом класса программистов, обладает теми же свойствами, что и другие программисты, тоже имеет имя, пишет программы и т.п.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В PHP для доступа к методам объекта используется оператор ->. Для инициализации объекта используется выражение new, создающее в переменной экземпляр объекта.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 //создаем класс людей\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 class Person\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \{\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // метод, который обучает человека PHP\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     function know_php()\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         \{\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0             echo "Теперь я знаю PHP";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         \}    \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $bob = new Person; // создаем объект\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                    // класса человек\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $bob -> know_php(); // обучаем его PHP\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Более подробно реализацию принципов ООП в языке PHP мы рассмотрим в одной из следующих лекций.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Тип resource (ресурсы)\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Ресурс – это специальная переменная, содержащая ссылку на внешний ресурс (например, соединение с базой данных). Ресурсы создаются и используются специальными функциями (например, mysql_connect(), pdf_new() и т.п.).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Тип Null\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Специальное значение NULL говорит о том, что переменная не имеет значения.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Переменная считается NULL, если:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - ей была присвоена константа NULL ($var = NULL);\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - ей еще не было присвоено какое-либо значение;\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - она была удалена с помощью unset().\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Существует только одно значение типа NULL – регистронезависимое ключевое слово NULL.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Решение задачи\b0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь вернемся к задаче, которую мы поставили в самом начале лекции. Напомним, что она состояла в составлении письма разным людям по поводу разных событий. Попытаемся использовать для решения этой задачи изученные средства – переменные, операторы, константы, строки и массивы. В зависимости от получателя изменяется событие и обращение, указанные в письме, поэтому естественно вынести эти величины в переменные. Более того, поскольку событий и людей много, удобно использовать переменные типа массив. Подпись в письме остается постоянной всегда, поэтому логично задать ее как константу. Чтобы не писать слишком длинные и громоздкие строки, используем оператор конкатенации. Итак, вот что получилось:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // пусть наша подпись \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // будет константой\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 define("SIGN","С уважением, Вася"); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // зададим массивы людей и событий\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $names = array("Иван Иванович",\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                "Петр Петрович",\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                "Семен Семенович");\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $events = array(\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     "f" => "день открытых дверей",\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     "o" => "открытие выставки",\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     "p" => "бал выпускников");\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // составим текст приглашения\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $str = "Уважаемый (ая), $names[0]";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $str .= "<br>Приглашаем Вас на ".\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         $events["f"];\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $str .= "<br>" . SIGN;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo $str; // выведем текст на экран\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Заключение\b0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Итак, в этой лекции мы познакомились с основами синтаксиса языка PHP, научились работать с переменными различных типов, константами, операторами, познакомились со всеми существующими в PHP типами данных. Говоря о таких типах данных, как строки и массивы, мы разобрали только самые основы. Эти конструкции настолько удобны и просты в использовании, что заслуживают отдельного разговора. Подробности будут изложены в последующих лекциях. Решая задачу, мы старались использовать только имеющиеся знания и не забегать вперед, поэтому решение не слишком подходит для практического применения. В следующей лекции мы исправим этот недостаток и создадим более универсальный шаблон электронного письма.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Управляющие конструкции\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Условные операторы\b0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Оператор if\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Это один из самых важных операторов многих языков, включая PHP. Он позволяет выполнять фрагменты кода в зависимости от условия. Структуру оператора if можно представить следующим образом:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 if (выражение) блок_выполнения\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Здесь выражение есть любое правильное PHP-выражение (т.е. все, что имеет значение). В процессе обработки скрипта выражение преобразуется к логическому типу. Если в результате преобразования значение выражения истинно (True), то выполняется блок_выполнения. В противном случае блок_выполнения игнорируется. Если блок_выполнения содержит несколько команд, то он должен быть заключен в фигурные скобки \{ \}.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Правила преобразования выражения к логическому типу:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - логическое False\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - целый ноль (0)\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - действительный ноль (0.0)\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - пустая строка и строка "0"\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - массив без элементов\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - объект без переменных (подробно об объектах будет  рассказано в одной из следующих лекций)\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - специальный тип NULL\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - Все остальные значения преобразуются в TRUE.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $names = array("Иван","Петр","Семен"); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 if ($names[0]=="Иван") \{ \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     echo "Привет, Ваня!";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     $num = 1;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     $account = 2000;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 if ($num) echo "Иван первый в списке!";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $bax = 30;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 if ($account > 100*$bax+3) \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     echo "Эта строчка не появится \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     на экране, так как условие не выполнено";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Оператор else\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Мы рассмотрели только одну, основную часть оператора if. Существует несколько расширений этого оператора. Оператор else расширяет if на случай, если проверяемое в if выражение является неверным, и позволяет выполнить какие-либо действия при таких условиях.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Структуру оператора if, расширенного с помощью оператора else, можно представить следующим образом:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 if (выражение) блок_выполнения\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 else блок_выполнения1\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эту конструкцию if...else можно интерпретировать примерно так: если выполнено условие (т.е. выражение=true), то выполняем действия из блока_выполнения, иначе – действия из блока_выполнения1. Использовать оператор else не обязательно.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Посмотрим, как можно изменить предыдущий пример, учитывая необходимость совершения действий и в случае невыполнения условия.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $names = array("Иван","Петр","Семен"); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 if ($names[0]=="Иван") \{ \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     echo "Привет, Ваня!";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     $num = 1;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     $account = 2000;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \} else \{\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     echo "Привет, $names[0]. \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    А мы ждали Ваню :(";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 if ($num) echo "Иван первый в списке!";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 else echo "Иван НЕ первый в списке?!";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $bax = 30;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 if ($account > 100*$bax+3) \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     echo "Эта строка не появится на экране,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     так как условие не выполнено"; \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     else echo "Зато появится эта строка!";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Оператор elseif\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Еще один способ расширения условного оператора if – использование оператора elseif. elseif – это комбинация else и if. Как и else, он расширяет if для выполнения различных действий в том случае, если условие, проверяемое в if, неверно. Но в отличие от else, альтернативные действия будут выполнены, только если elseif-условие является верным. Структуру оператора if, расширенного с помощью операторов else и elseif, можно представить следующим образом:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 if (выражение) блок_выполнения\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 elseif(выражение1) блок_выполнения1\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ...\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 else блок_выполненияN\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Операторов elseif может быть сразу несколько в одном if-блоке. Elseif-утверждение будет выполнено, только если предшествующее if-условие является False, все предшествующие elseif-условия являются False, а данное elseif-условие – True.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $names = array("Иван","Петр","Семен"); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 if ($names[0]=="Иван") \{    \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // если первое имя в массиве Иван\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     echo "Привет, Ваня!";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \}elseif ($names[0] == "Петр")\{  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // если первое имя \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // не Иван, а Петр\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     echo "Привет, Петя!";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \}elseif ($names[0] == "Семен")\{     \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // если первое имя не \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // Иван, не Петр, а Семен\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     echo "Привет, Сеня!";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \}else \{ \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // если первое имя не Иван, \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // не Петр и не Семен\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     echo "Привет, $names[0]. А ты кто такой?";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Альтернативный синтаксис\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 PHP предлагает альтернативный синтаксис для некоторых своих управляющих структур, а именно для if, while, for, foreach и switch. В каждом случае открывающую скобку нужно заменить на двоеточие (:), а закрывающую – на endif;, endwhile; и т.д. соответственно.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Например, синтаксис оператора if можно записать таким образом:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 if(выражение): блок_выполнения endif;\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Смысл остается тем же: если условие, записанное в круглых скобках оператора if, оказалось истиной, будет выполняться весь код, от двоеточия «:» до команды endif;. Использование такого синтаксиса полезно при встраивании php в html-код.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $names = array("Иван","Петр","Семен"); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 if ($names[0]=="Иван"): \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Привет, Ваня!\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php endif ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если используются конструкции else и elseif, то также можно задействовать альтернативный синтаксис:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 if ($a == 5):\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     print "a равно 5";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     print "...";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 elseif ($a == 6):\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     print "a равно 6";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     print "!!!";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 else:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     print "a не равно ни 5, ни 6";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 endif;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Оператор switch\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Еще одна конструкция, позволяющая проверять условие и выполнять в зависимости от этого различные действия, – это switch. На русский язык название данного оператора можно перевести как «переключатель». И смысл у него именно такой. В зависимости от того, какое значение имеет переменная, он переключается между различными блоками действия. switch очень похож на оператор if...elseif...else или набор операторов if. Структуру switch можно записать следующим образом:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 switch (выражение или переменная)\{\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 case значение1:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     блок_действий1\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 break;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 case значение2:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     блок_действий2\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 break;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ...\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 default:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     блок_действий_по_умолчанию\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \}\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В отличие от if, здесь значение выражения не приводится к логическому типу, а просто сравнивается со значениями, перечисленными после ключевых слов case (значение1, значение 2 и т.д.). Если значение выражения совпало с каким-то вариантом, то выполняется соответствующий блок_действий – от двоеточия после совпавшего значения до конца switch или до первого оператора break, если таковой найдется. Если значение выражения не совпало ни с одним из вариантов, то выполняются действия по умолчанию (блок_действий_по_умолчанию), находящиеся после ключевого слова default. Выражение в switch вычисляется только один раз, а в операторе elseif – каждый раз, поэтому, если выражение достаточно сложное, то switch работает быстрее.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Пример 3.3 можно переписать с использованием switch следующим образом:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $names = array("Иван","Петр","Семен"); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 switch ($names[0])\{\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 case "Иван": \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     echo "Привет, Ваня!";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 break;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 case "Петр":\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     echo "Привет, Петя!";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 break;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 case "Семен":\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     echo "Привет, Сеня!";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 break;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 default:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     echo "Привет, $names[0]. \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    А как Вас зовут?";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если в этом примере опустить оператор break, например, в case "Петр":, то, если переменная окажется равной строке "Петр", после вывода на экран сообщения "Привет, Петя!" программа пойдет дальше и выведет также сообщение "Привет, Сеня!" и только потом, встретив break, продолжит свое выполнение за пределами switch.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для конструкции switch, как и для if, возможен альтернативный синтаксис, где открывающая switch фигурная скобка заменяется двоеточием, а закрывающая – endswitch; соответственно.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Циклы\b0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В PHP существует несколько конструкций, позволяющих выполнять повторяющиеся действия в зависимости от условия. Это циклы while, do..while, foreach и for. Рассмотрим их более подробно.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i while\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Структура:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 while (выражение) \{ блок_выполнения \}\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 либо\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 while (выражение): блок_выполнения endwhile; \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 while – простой цикл. Он предписывает PHP выполнять команды блока_выполнения до тех пор, пока выражение вычисляется как True (здесь, как и в if, происходит приведение выражения к логическому типу). Значение выражения проверяется каждый раз в начале цикла, так что, даже если его значение изменилось в процессе выполнения блока_выполнения, цикл не будет остановлен до конца итерации (т.е. пока все команды блока_выполнения не будут исполнены).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 //эта программа напечатает все четные цифры\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     $i = 1;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     while ($i < 10) \{\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         if ($i % 2 == 0) print $i;  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // печатаем цифру, если она четная \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         $i++;   \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // и увеличиваем $i на единицу\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i do... while\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Циклы do..while очень похожи на циклы while, с той лишь разницей, что истинность выражения проверяется в конце цикла, а не в начале. Благодаря этому блок_выполнения цикл do...while гарантированно выполняется хотя бы один раз.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Структура:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 do \{блок_выполнения\} while (выражение);\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // эта программа напечатает число 12, несмотря на то \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // что условие цикла не выполнено\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $i = 12;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     do\{\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         if ($i % 2 == 0) print $i;  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // если число четное, то печатаем его\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         $i++;   \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // увеличиваем число на единицу\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     \}while ($i<10)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i for\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Это самые сложные циклы в PHP. Они напоминают соответствующие циклы C.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Структура:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 for (выражение1; выражение2; выражение3) \{блок_выполнения\}\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 либо\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 for (выражение1; выражение2; выражение3): блок_выполнения endfor;\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Здесь, как мы видим, условие состоит сразу из трех выражений. Первое выражение выражение1 вычисляется безусловно один раз в начале цикла. В начале каждой итерации вычисляется выражение2. Если оно является True, то цикл продолжается и выполняются все команды блока_выполнения. Если выражение2 вычисляется как False, то исполнение цикла останавливается. В конце каждой итерации (т.е. после выполнения всех команд блока_выполнения) вычисляется выражение3.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Каждое из выражений 1, 2, 3 может быть пустым. Если выражение2 является пустым, то это значит, что цикл должен выполняться неопределенное время (в этом случае PHP считает это выражение всегда истинным). Это не так бесполезно, как кажется, ведь цикл можно останавливать, используя оператор break.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Например, все четные цифры можно вывести с использованием цикла for таким образом:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 for ($i=0; $i<10; $i++)\{\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     if ($i % 2 == 0) print $i;  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // печатаем четные числа\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если опустить второе выражение (условие $i<10), то такую же задачу можно решить, останавливая цикл оператором break.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 for ($i=0; ; $i++)\{\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     if ($i>=10) break;  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0       // если $i больше или равно 10,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0       // то прекращаем работу цикла\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     if ($i % 2 == 0) print $i;  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      // если число четное, \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0       // то печатаем его\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Можно опустить все три выражения. В этом случае просто не будет задано начальное значение счетчика $i и оно не будет изменяться каждый раз в конце цикла. Все эти действия можно записать в виде отдельных команд либо в блоке_выполнения, либо перед циклом:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $i=0; // задаем начальное значение счетчика\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 for ( ; ; )\{\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     if ($i>=10) break;  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      // если $i больше или равно 10, \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0       // то прекращаем работу цикла\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     if ($i % 2 == 0) print $i;  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      // если число четное, \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0       // то печатаем его\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $i++; // увеличиваем счетчик на единицу\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В третье выражение конструкции for можно записывать через запятую сразу несколько простейших команд. Например, если мы хотим просто вывести все цифры, то программу можно записать совсем просто:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 for ($i=0; $i<10; print $i, $i++) \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 /* Если блок_выполнения не содержит команд \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 или содержит только одну команду, \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 фигурные скобки, в которые он заключен, \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 можно опускать*/\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i foreach\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Еще одна полезная конструкция. Она появилась только в PHP4 и предназначена исключительно для работы с массивами.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Синтаксис:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 foreach ($array as $value) \{блок_выполнения\}\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 либо\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 foreach ($array as $key => $value)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    \{блок_выполнения\} \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В первом случае формируется цикл по всем элементам массива, заданного переменной $array. На каждом шаге цикла значение текущего элемента массива записывается в переменную $value, и внутренний счетчик массива передвигается на единицу (так что на следующем шаге будет виден следующий элемент массива). Внутри блока_выполнения значение текущего элемента массива может быть получено с помощью переменной $value. Выполнение блока_выполнения происходит столько раз, сколько элементов в массиве $array.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Вторая форма записи в дополнение к перечисленному выше на каждом шаге цикла записывает ключ текущего элемента массива в переменную $key, которую тоже можно использовать в блоке_выполнения.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Когда foreach начинает исполнение, внутренний указатель массива автоматически устанавливается на первый элемент.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $names = array("Иван","Петр","Семен"); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 foreach ($names as $val) \{\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     echo "Привет, $val <br>";   \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // выведет всем приветствие \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 foreach ($names as $k => $val) \{ \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // кроме приветствия, \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // выведем номера в списке, т.е. ключи\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     echo "Привет, $val ! \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      Ты в списке под номером $k <br>"; \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Операторы передачи управления\b0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Иногда в случае особых обстоятельств требуется немедленно завершить работу цикла и передать управление первой инструкции программы, расположенной за последней инструкцией цикла. Для этого используют операторы break и continue.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Break\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Оператор break заканчивает выполнение текущего цикла, будь то for, foreach, while, do..while или switch. break может использоваться с числовым аргументом, который говорит, работу скольких управляющих структур, содержащих его, нужно завершить.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $i=1;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 while ($i) \{\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     $n = rand(1,10);    \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // генерируем произвольное число \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // от 1 до 10\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     echo "$i:$n ";      \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // выводим номер итерации и \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // сгенерированное число\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     if ($n==5) break; \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 /* Если было сгенерировано число 5, \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 то прекращаем работу цикла. В этом случае \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 все, что находится после этой строчки \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 внутри цикла, не будет выполнено */\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     echo "Цикл работает <br>";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     $i++;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo "<br>Число итераций цикла $i ";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Результатом работы этого скрипта будет примерно следующее:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 1:7 Цикл работает \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 2:2 Цикл работает \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 3:5 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Число итераций цикла 3 \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если после оператора break указать число, то прервется именно такое количество содержащих этот оператор циклов. В приведенном выше примере это неактуально, поскольку вложенных циклов нет. Немного изменим наш скрипт:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $i=1;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 while ($i) \{\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   $n = rand(1,10);    \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   // генерируем произвольное число \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   // от 1 до 10\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   switch ($n)\{\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     case 5:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0       echo "<font color=blue>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         Выход из switch (n=$n)</font>";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     break 1;    \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    // прекращаем работу switch \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // (первого содержащего break цикла)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     case 10:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0       echo "<font color=red>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0        Выход из switch и \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0       while (n=$n)</font>";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     break 2;    \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    // прекращаем работу switch и while \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // (двух содержащих break циклов)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     default:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0       echo "switch работает (n=$n), ";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo " while работает – шаг $i <br>";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $i++;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo "<br>Число итераций цикла $i ";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i continue\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Иногда нужно не полностью прекратить работу цикла, а только начать его новую итерацию. Оператор continue позволяет пропустить дальнейшие инструкции из блока_выполнения любого цикла и продолжить выполнение с нового круга. continue можно использовать с числовым аргументом, который указывает, сколько содержащих его управляющих конструкций должны завершить работу.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Заменим в примере предыдущего параграфа оператор break на continue. Кроме того, ограничим число шагов цикла четырьмя.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $i=1;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 while ($i<4) \{\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     $n = rand(1,10); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    // генерируем произвольное число \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    // от 1 до 10\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     echo "$i:$n ";  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    // выводим номер итерации и \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // сгенерированное число\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     if ($n==5) \{\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         echo "Новая итерация ";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         continue; \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 /* Если было сгенерировано число 5, \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 то начинаем новую итерацию цикла, \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $i не увеличивается */\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     echo "Цикл работает <br>";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     $i++;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo "<br>Число итераций цикла $i ";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Результатом работы этого скрипта будет\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 1:10 Цикл работает \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 2:5 Новая итерация 2:1 Цикл работает \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 3:1 Цикл работает \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Число итераций цикла 4 \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Заметим, что после выполнения оператора continue работа цикла не заканчивается. В примере счетчик цикла не меняется в случае получения числа 5, поскольку он находится после оператора continue. Фактически с помощью continue мы пытаемся избежать ситуации, когда будет сгенерировано число 5. Поэтому можно было просто написать, заменив оператор continue на проверку истинности выражения:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $i=1;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 while ($i<4) \{\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     $n = rand(1,10);    \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    // генерируем произвольное число \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // от 1 до 10\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     if ($n!==5) \{\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         echo "$i:$n <br>";  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    // выводим номер итерации \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // и сгенерированное число\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     $i++;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В PHP существует одна особенность использования оператора continue – в конструкциях switch он работает так же, как и break. Если switch находится внутри цикла и нужно начать новую итерацию цикла, следует использовать continue 2.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Операторы включения\b0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i include\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Оператор include позволяет включать код, содержащийся в указанном файле, и выполнять его столько раз, сколько программа встречает этот оператор. Включение может производиться любым из перечисленных способов:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 include 'имя_файла';\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 include $file_name;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 include ("имя_файла");\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Пример 3.9.\b0   Пусть в файле params.inc у нас хранится набор каких-то параметров и функций. Каждый раз, когда нам нужно будет использовать эти параметры (функции), мы будем вставлять в текст нашей основной программы команду include 'params.inc'.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 params.inc\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $user = "Вася";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $today = date("d.m.y"); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 /* функция date() возвращает дату \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 и время (здесь – дату в формате \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 день.месяц.год) */\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 include.php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 include ("params.inc"); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 /* переменные $user и $today заданы в файле\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 params.inc. Здесь мы тоже можем ими \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 пользоваться благодаря команде \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 include("params.inc") */\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo "Привет, $user!<br>";  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // выведет "Привет, Вася!"\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo "Сегодня $today";      \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // выведет, например, "Сегодня 7.07.05"\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Заметим, что использование оператора include эквивалентно простой вставке содержательной части файла params.inc в код программы include.php. Может быть, тогда можно было в params.inc записать простой текст без всяких тегов, указывающих на то, что это php-код? Нельзя! Дело в том, что в момент вставки файла происходит переключение из режима обработки PHP в режим HTML. Поэтому код внутри включаемого файла, который нужно обработать как PHP-скрипт, должен быть заключен в соответствующие теги.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Поиск файла для вставки происходит по следующим правилам.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - Сначала ведется поиск файла в include_path относительно текущей рабочей директории.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - Если файл не найден, то поиск производится в include_path относительно директории текущего скрипта.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - Параметр include_path, определяемый в файле настроек PHP, задает имена директорий, в которых нужно искать включаемые файлы.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Например, ваш include_path это . (то есть текущая директория), текущая рабочая директория это /www/. В основной файл include.php вы включаете файл my_dir/a.php, который в свою очередь включает b.php. Тогда парсер первым делом ищет файл b.php в директории /www/, и если такового нет, то в директории /www/my_dir/.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если файл включен с помощью include, то содержащийся в нем код наследует область видимости переменных строки, где появился include. Любые переменные вызванного файла будут доступны в вызывающем файле с этой строки и далее. Соответственно, если include появляется внутри функции вызывающего файла, то код, содержащийся в вызываемом файле, будет вести себя так, как будто он был определен внутри функции. Таким образом, он унаследует область видимости этой функции. Хотя мы и не знакомились еще с понятием функции, все же приводим здесь эти сведения в расчете на интуитивное его понимание.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Пример 3.10\b0  . Пусть файл для вставки params.inc останется таким же, а include.php будет следующим:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 function Footer()\{ \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // объявляем функцию с именем Footer\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     include ("params.inc"); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 /* включаем файл params.inc. \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    Теперь его переменными можно пользоваться,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    но только внутри функции */\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     $str = "Сегодня: $today <br>";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     $str .= "<a \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      href='mailto:help@intuit.ru'>Страницу\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0       создал $user</a>";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     echo "$str";    \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Footer();   \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // вызываем функцию Footer(). Получим:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 //Сегодня: 08.07.05 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 //Страницу создал Вася\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo "$user, $today";   \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // выведет запятую, так как \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // эти переменные видны только \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    // внутри функции\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Кроме локальных файлов, с помощью include можно включать и внешние файлы, указывая их url-адреса. Данная возможность контролируется директивой url_fopen_wrappers в файле настроек PHP и по умолчанию, как правило, включена. Но в версиях PHP для Windows до PHP 4.3.0 эта возможность не поддерживается совсем, вне зависимости от url_fopen_wrappers.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 include() – это специальная языковая конструкция, поэтому при использовании внутри условных блоков ее нужно заключать в фигурные скобки.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 /*  Это неверная запись. Получим ошибку.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     Мы же вставляем не одну команду, \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    а несколько, они только записаны \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    в другом файле */\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 if ($condition) include("first.php");\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 else include("second.php");\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // А вот так правильно. \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 if ($condition)\{ include("first.php"); \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 else \{ include("second.php"); \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 При использовании include возможны два вида ошибок – ошибка вставки (например, нельзя найти указанный файл, неверно написана сама команда вставки и т.п.) или ошибка исполнения (если ошибка содержится во вставляемом файле). В любом случае при ошибке в команде include исполнение скрипта не завершается.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i require\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Этот оператор действует примерно так же, как и #include в C++. Все, что мы говорили о include, лишь за некоторыми исключениями, справедливо и для require. Require также позволяет включать в программу и исполнять какой-либо файл. Основное отличие require и include заключается в том, как они реагируют на возникновение ошибки. Как уже говорилось, include выдает предупреждение, и работа скрипта продолжается. Ошибка в require вызывает фатальную ошибку работы скрипта и прекращает его выполнение.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Условные операторы на require() не влияют. Хотя, если строка, в которой появляется этот оператор, не исполняется, то ни одна строка кода из вставляемого файла тоже не исполняется. Циклы также не влияют на require(). Хотя код, содержащийся во вставляемом файле, является объектом цикла, но вставка сама по себе происходит только однажды.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В реализациях PHP до версии 4.0.2 использование require() означало, что интерпретатор обязательно попытается прочесть вставляемый файл.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 require, как и include, при использовании внутри условных блоков нужно заключать в фигурные скобки.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Решение задачи\b0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 И наконец, вернемся к задаче, сформулированной в начале лекции. Мы хотим создать программу, которую можно было бы использовать для отправки писем (или просто для их генерации) с приглашениями на различные мероприятия множеству пользователей. В предыдущей лекции уже рассматривался подобный случай. Сейчас мы вынесем всю информацию о людях и событиях в отдельный файл data.php и напишем программу, не зависящую (ну, может, совсем чуть-чуть зависящую) от этой информации и ее структуры. В этом случае для того, чтобы, например, расширить список адресатов, не нужно будет изменять скрипт, генерирующий приглашения. Кроме того, можно будет использовать информацию о людях и событиях в других скриптах. В самом скрипте, генерирующем приглашения letters.php, мы использовали условные операторы, циклы, require и другие изученные ранее конструкции.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 define("SIGN","С уважением, Вася"); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // пусть наша подпись \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // будет константой\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // информация о событиях\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $events = array(\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     "f" => "день открытых дверей",\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     "o" => "открытие выставки", \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     "p" => "бал выпускников");\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // имеющаяся информация о людях \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // (имя и электронный адрес)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $people = array(\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     "ivan" => array(\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0        "name" => "Иван Иванович",\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         "email"=>"user_ivan@intuit.ru"),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     "pit" => array(\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0        "name" => "Петр Петрович",\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         "email" => "user_petr@intuit.ru"),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     "semen" => array(\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0        "name" => "Семен Семенович"));\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // кто куда приглашается\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $who_where["ivan"] = "o" ;  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // Иван – на выставку\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $who_where["pit"] = "p";        \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // Петр – на бал\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 require("data.php");    \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // включаем файл с данными о событиях\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 foreach($people as $key => $man_info)\{ \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // для каждого человека делаем следующее:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $event_key = $who_where[$key]; \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // получаем событие, \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    // на которое он приглашается\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 if ($event_key<>"")\{\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     foreach($man_info as $key1 => $info)\{\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // получаем имя и email \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    // конкретного человека\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     if ($key1=="name") \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0       $str = "Уважаемый (ая), $info";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     if ($key1=="email") $email = $info;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // составляем приглашение\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     $str .= "<br>Приглашаем Вас на ". \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0        $events[$event_key];\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     switch ($event_key)\{ \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    // в зависимости от события \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // добавляем какую-нибудь строчку\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         case "f":\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         $str .= "<br>Подтвердите Ваше \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0           участие по телефону!";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         break;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         case "o":\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         $str .= "<br>Приходите за 15 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0           минут до открытия!";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         break;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         case "p":\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         $str .= "<br>Не забудьте подарок :-)";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         break;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     $str .= "<br>" . SIGN . "<hr>"; \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    // добавляем подпись\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    echo $str; // вводим приглашение на экран \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 /* если у вас настроена отправка почты с \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 помощью PHP, то письмо можно отправить \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 командой mail($email,"Letter",$str); */\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Заключение\b0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Итак, мы завершили изучение управляющих конструкций языка PHP. Мы старались привести самое основное и не углубляться в различные нюансы тех или иных конструкций. Подробную информацию можно найти в руководстве по PHP.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Обработка запросов с помощью PHP\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Основы клиент-серверных технологий\b0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В самом начале курса мы уже говорили о том, что PHP – это скриптовый язык, обрабатываемый сервером. Сейчас мы хотим уточнить, что же такое сервер, какие функции он выполняет и какие вообще бывают серверы. Если речь идет о сервере, невольно всплывает в памяти понятие клиента. Все потому, что эти два понятия неразрывно связаны. Объединяет их компьютерная архитектура клиент-сервер. Обычно, когда говорят «сервер», имеют в виду сервер в архитектуре клиент-сервер, а когда говорят «клиент» – имеют в виду клиент в этой же архитектуре. Так что же это за архитектура? Суть ее в том, чтобы разделить функции между двумя подсистемами: клиентом, который отправляет запрос на выполнение каких-либо действий, и сервером, который выполняет этот запрос. Взаимодействие между клиентом и сервером происходит посредством стандартных специальных протоколов, таких как TCP/IP и z39.50. На самом деле протоколов очень много, они различаются по уровням. Мы рассмотрим только протокол прикладного уровня HTTP (чуть позднее), поскольку для решения наших программистских задач нужен только он. А пока вернемся к клиент-серверной архитектуре и разберемся, что же такое клиент и что такое сервер.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Сервер представляет собой набор программ, которые контролируют выполнение различных процессов. Соответственно, этот набор программ установлен на каком-то компьютере. Часто компьютер, на котором установлен сервер, и называют сервером. Основная функция компьютера-сервера – по запросу клиента запустить какой-либо определенный процесс и отправить клиенту результаты его работы.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Клиентом называют любой процесс, который пользуется услугами сервера. Клиентом может быть как пользователь, так и программа. Основная задача клиента – выполнение приложения и осуществление связи с сервером, когда этого требует приложение. То есть клиент должен предоставлять пользователю интерфейс для работы с приложением, реализовывать логику его работы и при необходимости отправлять задания серверу.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Взаимодействие между клиентом и сервером начинается по инициативе клиента. Клиент запрашивает вид обслуживания, устанавливает сеанс, получает нужные ему результаты и сообщает об окончании работы.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Услугами одного сервера чаще всего пользуется несколько клиентов одновременно. Поэтому каждый сервер должен иметь достаточно большую производительность и обеспечивать безопасность данных.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Логичнее всего устанавливать сервер на компьютере, входящем в какую-либо сеть, локальную или глобальную. Однако можно устанавливать сервер и на отдельно стоящий компьютер (тогда он будет являться одновременно и клиентом и сервером).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Существует множество типов серверов. Вот лишь некоторые из них.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Такой сервер специально приспособлен к обработке изображений, хранению видеоматериалов, видеоигр и т.п. В связи с этим компьютер, на котором установлен видеосервер, должен иметь высокую производительность и большую память.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - \b Поисковый\b0   сервер предназначен для поиска информации в Internet.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - \b Почтовый\b0   сервер предоставляет услуги в ответ на запросы, присланные по электронной почте.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - \b Сервер WWW\b0   предназначен для работы в Internet.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - \b Сервер баз данных\b0   выполняет обработку запросов к базам данных.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - Сервер защиты данных предназначен для обеспечения безопасности данных (содержит, например, средства для идентификации паролей).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - \b Сервер приложений\b0   предназначен для выполнения прикладных процессов. С одной стороны взаимодействует с клиентами, получая задания, а с другой – работает с базами данных, подбирая необходимые для обработки данные.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - \b Сервер удаленного доступа\b0   обеспечивает коллективный удаленный доступ к данным.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - \b Файловый сервер\b0   обеспечивает функционирование распределенных ресурсов, предоставляет услуги поиска, хранения, архивирования данных и возможность одновременного доступа к ним нескольких пользователей.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Обычно на компьютере-сервере работает сразу несколько программ-серверов. Одна занимается электронной почтой, другая распределением файлов, третья предоставляет web-страницы.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Из всех типов серверов нас в основном интересует сервер WWW. Часто его называют web-сервером, http-сервером или даже просто сервером. Что представляет собой web-сервер? Во-первых, это хранилище информационных ресурсов. Во-вторых, эти ресурсы хранятся и предоставляются пользователям в соответствии со стандартами Internet (такими, как протокол передачи данных HTTP). Как предоставляются данные в соответствии с этим протоколом, мы рассмотрим чуть позже. Работа с документами web-сервера осуществляется при помощи браузера (например, IE, Opera или Mozilla), который отсылает серверу запросы, созданные в соответствии с протоколом HTTP. В процессе выполнения задания сервер может связываться с другими серверами.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Далее в ходе лекции, говоря «сервер», мы будем подразумевать web-сервер.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В качестве примеров web-серверов можно привести сервер Apache группы Apache, Internet Information Server (IIS) компании Microsoft, SunOne фирмы Sun Microsystems,WebLogic фирмы BEA Systems, IAS (Inprise Application Server) фирмы Borland, WebSphere фирмы IBM, OAS (Oracle Application Server).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 На рис. 4.1 и в таблице 4.1 приведена статистика использования различных серверов среди всех доменов Internet от NetCraft http://news.netcraft.com/.\par
\par
\qc\par\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 \b Рис. 4.1.\b0            Статистика использования ведущих web-серверов\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Apache\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 31703884\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  67.21\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  32280582\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  67.20\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  -0.01\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Microsoft\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 9849971\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  20.88\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  10099760\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 21.02\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  0.14\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 SunONE\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 1657295\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  3.51\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  1651575\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  3.44\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  -0.07\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Zeus\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 755227\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  1.60\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  762716\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  1.59\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  -0.01\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Как видно из приведенной таблицы, сервер Apache занимает лидирующие позиции. Все, что мы когда-либо будем говорить о web-серверах, ориентировано на Apache, если не указано иное. О том, как установить его на свой компьютер, мы уже рассказывали в самой первой лекции. А теперь, как было обещано, обратимся к протоколу HTTP.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Протокол HTTP и способы передачи данных на сервер\b0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Internet построен по многоуровневому принципу, от физического уровня, связанного с физическими аспектами передачи двоичной информации, и до прикладного уровня, обеспечивающего интерфейс между пользователем и сетью.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 HTTP (HyperText Transfer Protocol, протокол передачи гипертекста) – это протокол прикладного уровня, разработанный для обмена гипертекстовой информацией в Internet.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 HTTP предоставляет набор методов для указания целей запроса, отправляемого серверу. Эти методы основаны на дисциплине ссылок, где для указания ресурса, к которому должен быть применен данный метод, используется универсальный идентификатор ресурсов (Universal Resource Identifier) в виде местонахождения ресурса (Universal Resource Locator, URL) или в виде его универсального имени (Universal Resource Name, URN).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Сообщения по сети при использовании протокола HTTP передаются в формате, схожем с форматом почтового сообщения Internet (RFC-822) или с форматом сообщений MIME (Multipurpose Internet Mail Exchange).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 HTTP используется для коммуникаций между различными пользовательскими программами и программами-шлюзами, предоставляющими доступ к существующим Internet-протоколам, таким как SMTP (протокол электронной почты), NNTP (протокол передачи новостей), FTP (протокол передачи файлов), Gopher и WAIS. HTTP разработан для того, чтобы позволять таким шлюзам через промежуточные программы-серверы (proxy) передавать данные без потерь.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Протокол реализует принцип запрос/ответ. Запрашивающая программа – клиент инициирует взаимодействие с отвечающей программой – сервером и посылает запрос, содержащий:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - метод доступа;\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - адрес URI;\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - версию протокола;\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - сообщение (похожее по форме на MIME) с информацией о типе передаваемых данных, информацией о клиенте, пославшем запрос, и, возможно, с содержательной частью (телом) сообщения.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Ответ сервера содержит:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - строку состояния, в которую входит версия протокола и код возврата (успех или ошибка);\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - сообщение (в форме, похожей на MIME), в которое входит информация сервера, метаинформация (т.е. информация о содержании сообщения) и тело сообщения.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В протоколе не указывается, кто должен открывать и закрывать соединение между клиентом и сервером. На практике соединение, как правило, открывает клиент, а сервер после отправки ответа инициирует его разрыв.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Давайте рассмотрим более подробно, в какой форме отправляются запросы на сервер.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Форма запроса клиента\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Клиент отсылает серверу запрос в одной из двух форм: в полной или сокращенной. Запрос в первой форме называется соответственно полным запросом, а во второй форме – простым запросом.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Простой запрос содержит метод доступа и адрес ресурса. Формально это можно записать так:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <Простой-Запрос> := <Метод> <символ пробел>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     <Запрашиваемый-URI> <символ новой строки>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В качестве метода могут быть указаны GET, POST, HEAD, PUT, DELETE и другие. О наиболее распространенных из них мы поговорим немного позже. В качестве запрашиваемого URI чаще всего используется URL-адрес ресурса.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Пример простого запроса:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 GET http://phpbook.info/\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Здесь GET – это метод доступа, т.е. метод, который должен быть применен к запрашиваемому ресурсу, а http://phpbook.info/ – это URL-адрес запрашиваемого ресурса.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Полный запрос содержит строку состояния, несколько заголовков (заголовок запроса, общий заголовок или заголовок содержания) и, возможно, тело запроса. Формально общий вид полного запроса можно записать так:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <Полный запрос> := <Строка Состояния> \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     (<Общий заголовок>|<Заголовок запроса>|\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     <Заголовок содержания>)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     <символ новой строки>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     [<содержание запроса>]\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Квадратные скобки здесь обозначают необязательные элементы заголовка, через вертикальную черту перечислены альтернативные варианты. Элемент <Строка состояния> содержит метод запроса и URI ресурса (как и простой запрос) и, кроме того, используемую версию протокола HTTP. Например, для вызова внешней программы можно задействовать следующую строку состояния:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 POST http://phpbook.info/cgi-bin/test HTTP/1.0\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В данном случае используется метод POST и протокол HTTP версии 1.0.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В обеих формах запроса важное место занимает URI запрашиваемого ресурса. Чаще всего URI используется в виде URL-адреса ресурса. При обращении к серверу можно применять как полную форму URL, так и упрощенную.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Полная форма содержит тип протокола доступа, адрес сервера ресурса и адрес ресурса на сервере (рисунок 4.2).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В сокращенной форме опускают протокол и адрес сервера, указывая только местоположение ресурса от корня сервера. Полную форму используют, если возможна пересылка запроса другому серверу. Если же работа происходит только с одним сервером, то чаще применяют сокращенную форму.\par
\par
\qc\par\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 \b Рис. 4.2.\b0            Полная форма URL\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Далее мы рассмотрим наиболее распространенные методы отправки запросов.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Методы\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Как уже говорилось, любой запрос клиента к серверу должен начинаться с указания метода. Метод сообщает о цели запроса клиента. Протокол HTTP поддерживает достаточно много методов, но реально используются только три: POST, GET и HEAD. Метод GET позволяет получить любые данные, идентифицированные с помощью URI в запросе ресурса. Если URI указывает на программу, то возвращается результат работы программы, а не ее текст (если, конечно, текст не есть результат ее работы). Дополнительная информация, необходимая для обработки запроса, встраивается в сам запрос (в строку статуса). При использовании метода GET в поле тела ресурса возвращается собственно затребованная информация (текст HTML-документа, например).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Существует разновидность метода GET – условный GET. Этот метод сообщает серверу о том, что на запрос нужно ответить, только если выполнено условие, содержащееся в поле if-Modified-Since заголовка запроса. Если говорить более точно, то тело ресурса передается в ответ на запрос, если этот ресурс изменялся после даты, указанной в if-Modified-Since.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Метод HEAD аналогичен методу GET, только не возвращает тело ресурса и не имеет условного аналога. Метод HEAD используют для получения информации о ресурсе. Это может пригодиться, например, при решении задачи тестирования гипертекстовых ссылок.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Метод POST разработан для передачи на сервер такой информации, как аннотации ресурсов, новостные и почтовые сообщения, данные для добавления в базу данных, т.е. для передачи информации большого объема и достаточно важной. В отличие от методов GET и HEAD, в POST передается тело ресурса, которое и является информацией, получаемой из полей форм или других источников ввода.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 До сих пор мы только теоретизировали, знакомились с основными понятиями. Теперь пора научиться использовать все это на практике. Далее в лекции мы рассмотрим, как посылать запросы серверу и как обрабатывать его ответы.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Использование HTML-форм для передачи данных на сервер\b0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Как передавать данные серверу? Для этого в языке HTML есть специальная конструкция – формы. Формы предназначены для того чтобы получать от пользователя информацию. Например, вам нужно знать логин и пароль пользователя для того, чтобы определить, на какие страницы сайта его можно допускать. Или вам необходимы личные данные пользователя, чтобы была возможность с ним связаться. Формы как раз и применяются для ввода такой информации. В них можно вводить текст или выбирать подходящие варианты из списка. Данные, записанные в форму, отправляются для обработки специальной программе (например, скрипту на PHP) на сервере. В зависимости от введенных пользователем данных эта программа может формировать различные web-страницы, отправлять запросы к базе данных, запускать различные приложения и т.п.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Разберемся с синтаксисом HTML-форм. Возможно, многие с ним знакомы, но мы все же повторим основные моменты, поскольку это важно.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Итак, для создания формы в языке HTML используется тег FORM. Внутри него находится одна или несколько команд INPUT. С помощью атрибутов action и method тега FORM задаются имя программы, которая будет обрабатывать данные формы, и метод запроса, соответственно. Команда INPUT определяет тип и различные характеристики запрашиваемой информации. Отправка данных формы происходит после нажатия кнопки input типа submit. Создадим форму для регистрации участников заочной школы программирования.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 После обработки браузером этот файл будет выглядеть примерно так:\par
\par
\qc\par\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 \b Рис. 4.3.\b0            Пример html-формы\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Вот так создаются и выглядят HTML-формы. Будем считать, что мы научились или вспомнили, как их создавать. Как мы видим, в форме можно указывать метод передачи данных. Посмотрим, что будет происходить, если указать метод GET или POST, и в чем будет разница.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Для метода GET\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 При отправке данных формы с помощью метода GET содержимое формы добавляется к URL после знака вопроса в виде пар имя=значения, объединенных с помощью амперсанта &:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 action?name1=value1&name2=value2&name3=value3\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Здесь action – это URL-адрес программы, которая должна обрабатывать форму (это либо программа, заданная в атрибуте action тега form, либо сама текущая программа, если этот атрибут опущен). Имена name1, name2, name3 соответствуют именам элементов формы, а value1, value2, value3 – значениям этих элементов. Все специальные символы, включая = и &, в именах или значениях этих параметров будут опущены. Поэтому не стоит использовать в названиях или значениях элементов формы эти символы и символы кириллицы в идентификаторах.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если в поле для ввода ввести какой-нибудь служебный символ, то он будет передан в его шестнадцатеричном коде, например, символ $ заменится на %24. Так же передаются и русские буквы.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для полей ввода текста и пароля (это элементы input с атрибутом type=text и type=password), значением будет то, что введет пользователь. Если пользователь ничего не вводит в такое поле, то в строке запроса будет присутствовать элемент name=, где name соответствует имени этого элемента формы.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для кнопок типа checkbox и radio button значение value определяется атрибутом VALUE в том случае, когда кнопка отмечена. Не отмеченные кнопки при составлении строки запроса игнорируются целиком. Несколько кнопок типа checkbox могут иметь один атрибут NAME (и различные VALUE), если это необходимо. Кнопки типа radio button предназначены для одного из всех предложенных вариантов и поэтому должны иметь одинаковый атрибут NAME и различные атрибуты VALUE.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В принципе создавать HTML-форму для передачи данных методом GET не обязательно. Можно просто добавить в строку URL нужные переменные и их значения.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 http://phpbook.info/test.php?id=10&user=pit\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В связи с этим у передачи данных методом GET есть один существенный недостаток – любой может подделать значения параметров. Поэтому не советуем использовать этот метод для доступа к защищенным паролем страницам, для передачи информации, влияющей на безопасность работы программы или сервера. Кроме того, не стоит применять метод GET для передачи информации, которую не разрешено изменять пользователю.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Несмотря на все эти недостатки, использовать метод GET достаточно удобно при отладке скриптов (тогда можно видеть значения и имена передаваемых переменных) и для передачи параметров, не влияющих на безопасность.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Для метода POST\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Содержимое формы кодируется точно так же, как для метода GET (см. выше), но вместо добавления строки к URL содержимое запроса посылается блоком данных как часть операции POST. Если присутствует атрибут ACTION, то значение URL, которое там находится, определяет, куда посылать этот блок данных. Этот метод, как уже отмечалось, рекомендуется для передачи больших по объему блоков данных.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Информация, введенная пользователем и отправленная серверу с помощью метода POST, подается на стандартный ввод программе, указанной в атрибуте action, или текущему скрипту, если этот атрибут опущен. Длина посылаемого файла передается в переменной окружения CONTENT_LENGTH, а тип данных – в переменной CONTENT_TYPE.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Передать данные методом POST можно только с помощью HTML-формы, поскольку данные передаются в теле запроса, а не в заголовке, как в GET. Соответственно и изменить значение параметров можно, только изменив значение, введенное в форму. При использовании POST пользователь не видит передаваемые серверу данные.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Основное преимущество POST запросов – это их большая безопасность и функциональность по сравнению с GET-запросами. Поэтому метод POST чаще используют для передачи важной информации, а также информации большого объема. Тем не менее не стоит целиком полагаться на безопасность этого механизма, поскольку данные POST запроса также можно подделать, например создав html-файл на своей машине и заполнив его нужными данными. Кроме того, не все клиенты могут применять метод POST, что ограничивает варианты его использования.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 При отправке данных на сервер любым методом передаются не только сами данные, введенные пользователем, но и ряд переменных, называемых переменными окружения, характеризующих клиента, историю его работы, пути к файлам и т.п. Вот некоторые из переменных окружения:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - REMOTE_ADDR – IP-адрес хоста (компьютера), отправляющего запрос;\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - REMOTE_HOST – имя хоста, с которого отправлен запрос;\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - HTTP_REFERER – адрес страницы, ссылающейся на текущий скрипт;\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - REQUEST_METHOD – метод, который был использован при отправке запроса;\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - QUERY_STRING – информация, находящаяся в URL после знака вопроса;\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - SCRIPT_NAME – виртуальный путь к программе, которая должна выполняться;\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - HTTP_USER_AGENT – информация о браузере, который использует клиент\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Обработка запросов с помощью PHP\b0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 До сих пор мы упоминали только, что запросы клиента обрабатываются на сервере с помощью специальной программы. На самом деле эту программу мы можем написать сами, в том числе и на языке PHP, и она будет делать с полученными данными все, что мы захотим. Для того чтобы написать эту программу, необходимо познакомиться с некоторыми правилами и инструментами, предлагаемыми для этих целей PHP.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Внутри PHP-скрипта имеется несколько способов получения доступа к данным, переданным клиентом по протоколу HTTP. До версии PHP 4.1.0 доступ к таким данным осуществлялся по именам переданных переменных (напомним, что данные передаются в виде пар «имя переменной, символ «=», значение переменной»). Таким образом, если, например, было передано first_name=Nina, то внутри скрипта появлялась переменная $first_name со значением Nina. Если требовалось различать, каким методом были переданы данные, то использовались ассоциативные массивы $HTTP_POST_VARS и $HTTP_GET_VARS, ключами которых являлись имена переданных переменных, а значениями – соответственно значения этих переменных. Таким образом, если пара first_name=Nina передана методом GET, то $HTTP_GET_VARS["first_name"]="Nina".\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Использовать в программе имена переданных переменных напрямую небезопасно. Поэтому было решено начиная с PHP 4.1.0 задействовать для обращения к переменным, переданным с помощью HTTP-запросов, специальный массив – $_REQUEST. Этот массив содержит данные, переданные методами POST и GET, а также с помощью HTTP cookies. Это суперглобальный ассоциативный массив, т.е. его значения можно получить в любом месте программы, используя в качестве ключа имя соответствующей переменной (элемента формы).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Пример 4.2.\b0   Допустим, мы создали форму для регистрации участников заочной школы программирования, как в приведенном выше примере. Тогда в файле 1.php, обрабатывающем эту форму, можно написать следующее:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $str = "Здравствуйте, \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     ".$_REQUEST["first_name"]. " \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     ".$_REQUEST["last_name"]."! <br>";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $str .="Вы выбрали для изучения курс по \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     ".$_REQUEST["kurs"];\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo $str;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Тогда, если в форму мы ввели имя «Вася», фамилию «Петров» и выбрали среди всех курсов курс по PHP, на экране браузера получим такое сообщение:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Здравствуйте, Вася Петров! \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Вы выбрали для изучения курс по PHP \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 После введения массива $_REQUEST массивы $HTTP_POST_VARS и $HTTP_GET_VARS для однородности были переименованы в $_POST и $_GET соответственно, но сами они из обихода не исчезли из соображений совместимости с предыдущими версиями PHP. В отличие от своих предшественников, массивы $_POST и $_GET стали суперглобальными, т.е. доступными напрямую и внутри функций и методов.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Приведем пример использования этих массивов. Допустим, нам нужно обработать форму, содержащую элементы ввода с именами first_name, last_name, kurs (например, форму form.html, приведенную выше). Данные были переданы методом POST, и данные, переданные другими методами, мы обрабатывать не хотим. Это можно сделать следующим образом:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $str = "Здравствуйте, \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     ".$_POST ["first_name"]."\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     ".$_POST ["last_name"] ."! <br>";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $str .= "Вы выбрали для изучения курс по ".\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         $_POST["kurs"];\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo $str;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Тогда на экране браузера, если мы ввели имя «Вася», фамилию «Петров» и выбрали среди всех курсов курс по PHP, увидим сообщение, как в предыдущем примере:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Здравствуйте, Вася Петров! \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Вы выбрали для изучения курс по PHP \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для того чтобы сохранить возможность обработки скриптов более ранних версий, чем PHP 4.1.0, была введена директива register_globals, разрешающая или запрещающая доступ к переменным непосредственно по их именам. Если в файле настроек PHP параметр register_globals=On, то к переменным, переданным серверу методами GET и POST, можно обращаться просто по их именам (т.е. можно писать $first_name). Если же register_globals=Off, то нужно писать $_REQUEST["first_name"] или $_POST["first_name"], $_GET["first_name"], $HTTP_POST_VARS["first_name"], $HTTP_GET_VARS["first_name"]. С точки зрения безопасности эту директиву лучше отключать (т.е. register_globals=Off). При включенной директиве register_globals перечисленные выше массивы также будут содержать данные, переданные клиентом.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Иногда возникает необходимость узнать значение какой-либо переменной окружения, например метод, использовавшийся при передаче запроса или IP-адрес компьютера, отправившего запрос. Получить такую информацию можно с помощью функции getenv(). Она возвращает значение переменной окружения, имя которой передано ей в качестве параметра.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 getenv("REQUEST_METHOD"); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // возвратит использованный метод\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo getenv ("REMOTE_ADDR");    \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // выведет IP-адрес пользователя, \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // пославшего запрос\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Как мы уже говорили, если используется метод GET, то данные передаются добавлением строки запроса в виде пар «имя_переменной=значение к URL-адресу ресурса». Все, что записано в URL после знака вопроса, можно получить с помощью команды\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 getenv("QUERY_STRING");\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Благодаря этому можно по методу GET передавать данные в каком-нибудь другом виде. Например, указывать только значения нескольких параметров через знак плюс, а в скрипте разбирать строку запроса на части или можно передавать значение всего одного параметра. В этом случае в массиве $_GET появится пустой элемент с ключом, равным этому значению (всей строке запроса), причем символ «+», встретившийся в строке запроса, будет заменен на подчеркивание «_».\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Методом POST данные передаются только с помощью форм, и пользователь (клиент) не видит, какие именно данные отправляются серверу. Чтобы их увидеть, хакер должен подменить нашу форму своей. Тогда сервер отправит результаты обработки неправильной формы не туда, куда нужно. Чтобы этого избежать, можно проверять адрес страницы, с которой были посланы данные. Это можно сделать опять же с помощью функции getenv():\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 getenv("HTTP_REFERER");\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь самое время решить задачу, сформулированную в начале лекции.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Пример обработки запроса с помощью PHP\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Напомним, в чем состояла задача, и уточним ее формулировку. Нужно написать форму для регистрации участников заочной школы программирования и после регистрации отправить участнику сообщение. Мы назвали это сообщение универсальным письмом, но оно будет немного отличаться от того письма, которое мы составили на предыдущей лекции. Здесь мы также не будем отправлять что-либо по электронной почте, дабы не уподобляться спамерам, а просто сгенерируем это сообщение и выведем его на экран браузера. Начальный вариант формы регистрации мы уже приводили выше. Изменим его таким образом, чтобы каждый регистрирующийся мог выбрать сколько угодно курсов для посещения, и не будем подтверждать получение регистрационной формы.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Здесь все достаточно просто и понятно. Единственное, что можно отметить, – это способ передачи значений элемента checkbox. Когда мы пишем в имени элемента kurs[], это значит, что первый отмеченный элемент checkbox будет записан в первый элемент массива kurs, второй отмеченный checkbox – во второй элемент массива и т.д. Можно, конечно, просто дать разные имена элементам checkbox, но это усложнит обработку данных, если курсов будет много.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Скрипт, который все это будет разбирать и обрабатывать, называется 1.php (форма ссылается именно на этот файл, что записано в ее атрибуте action). По умолчанию используется для передачи метод GET, но мы указали POST. По полученным сведениям от зарегистрировавшегося человека, скрипт генерирует соответствующее сообщение. Если человек выбрал какие-то курсы, то ему выводится сообщение о времени их проведения и о лекторах, которые их читают. Если человек ничего не выбрал, то выводится сообщение о следующем собрании заочной школы программистов (ЗШП).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Заключение\b0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Подведем итоги. Мы научились отличать клиента от сервера и компьютер-сервер от программы-сервера, познакомились с основными методами, используемыми для передачи данных на сервер, изучили средства, предлагаемые языком PHP для обработки клиентских запросов, и испробовали их на практике. В принципе этого достаточно для того, чтобы создавать клиент-серверные приложения.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Функции в PHP\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В этой лекции будут рассматриваться вопросы создания и использования функций в PHP. Говоря «функции», мы не имеем в виду все существующие в PHP функции, а лишь функции, определяемые пользователем. Мы рассмотрим способы задания таких функций, методы передачи аргументов, использование аргументов со значением по умолчанию и значения, возвращаемые функцией.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В качестве примера создадим web-интерфейс для генерации html-формы. То есть пользователь выбирает, не прибегая к программированию, какие элементы формы нужно создать, и характеристики этих элементов, а наша программа генерирует нужную форму.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Функции, определяемые пользователем\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для чего нужны функции? Чтобы ответить на этот вопрос, нужно понять, что вообще представляют собой функции. В программировании, как и в математике, функция есть отображение множества ее аргументов на множество ее значений. То есть функция для каждого набора значений аргумента возвращает какие-то значения, являющиеся результатом ее работы. Зачем нужны функции, попытаемся объяснить на примере. Классический пример функции в программировании – это функция, вычисляющая значение факториала числа. То есть мы задаем ей число, а она возвращает нам его факториал. При этом не нужно для каждого числа, факториал которого мы хотим получить, повторять один и тот же код – достаточно просто вызвать функцию с аргументом, равным этому числу.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Функция вычисления факториала натурального числа\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 function fact($n)\{\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   if ($n==0) return 1;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   else return $fact = $n * fact($n-1);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo fact(3);  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    // можно было бы написать echo (3*2);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    // но если число большое,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo fact(50); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    // то удобнее пользоваться функцией,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    // чем писать echo (50*49*48*...*3*2);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Таким образом, когда мы осуществляем действия, в которых прослеживается зависимость от каких-то данных, и при этом, возможно, нам понадобится выполнять такие же действия, но с другими исходными данными, удобно использовать механизм функций – оформить блок действий в виде тела функции, а меняющиеся данные – в качестве ее параметров.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Посмотрим, как в общем виде выглядит задание (объявление) функции. Функция может быть определена с помощью следующего синтаксиса:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 function Имя_функции (параметр1, параметр2,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    ... параметрN)\{\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    Блок_действий\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    return "значение возвращаемое функцией";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \}\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если прямо так написать в php-программе, то работать ничего не будет. Во-первых, Имя_функции и имена параметров функции (параметр1, параметр2 и т.д.) должны соответствовать правилам наименования в PHP (и русских символов в них лучше не использовать). Имена функций нечувствительны к регистру. Во-вторых, параметры функции – это переменные языка, поэтому перед названием каждого из них должен стоять знак $. Никаких троеточий ставить в списке параметров нельзя. В-третьих, вместо слов блок_действий в теле функции должен находиться любой правильный PHP-код (не обязательно зависящий от параметров). И наконец, после ключевого слова return должно идти корректное php-выражение (что-либо, что имеет значение). Кроме того, у функции может и не быть параметров, как и возвращаемого значения. Пример правильного объявления функции – функция вычисления факториала, приведенная выше.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Как происходит вызов функции? Указывается имя функции и в круглых скобках список значений ее параметров, если таковые имеются:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Имя_функции ("значение_для_параметра1",\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   "значение_для_параметра2",...);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // пример вызова функции – вызов функции \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // вычисления факториала приведен выше, \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // там для вычисления факториала числа 3 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // мы писали: fact(3); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // где fact – имя вызываемой функции, \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // а 3 – значение ее параметра с именем $n\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Когда можно вызывать функцию? Казалось бы, странный вопрос. Функцию можно вызвать после ее определения, т.е. в любой строке программы ниже блока function f_name()\{...\}. В PHP3 это было действительно так. Но уже в PHP4 такого требования нет. Все дело в том, как интерпретатор обрабатывает получаемый код. Единственное исключение составляют функции, определяемые условно (внутри условных операторов или других функций). Когда функция определяется таким образом, ее определение должно предшествовать ее вызову.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $make = true;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 /* здесь нельзя вызвать Make_event(); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 потому что она еще не существует, но можно\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 вызвать Save_info() */\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Save_info("Вася","Иванов", \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    "Я выбрал курс по PHP");\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 if ($make)\{\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // определение функции Make_event()\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   function Make_event()\{\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     echo "<p>Хочу изучать Python<br>";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // теперь можно вызывать Make_event()\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Make_event();\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // определение функции Save_info\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 function Save_info($first, $last, $message)\{\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   echo "<br>$message<br>";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   echo "Имя: ". $first . " ". $last . "<br>";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Save_info("Федя","Федоров",\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0           "А я выбрал Lisp");\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // Save_info можно вызывать и здесь\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если функция однажды определена в программе, то переопределить или удалить ее позже нельзя. Несмотря на то, что имена функций нечувствительны к регистру, лучше вызывать функцию по тому же имени, каким она была задана в определении.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 /* нельзя сохранить данные, т.е. вызвать\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 функцию DataSave() до того, как выполнена\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 проверка их правильности, т.е. вызвана \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 функция DataCheck() */\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 DataCheck();\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 DataSave();\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 function DataCheck()\{\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // проверка правильности данных\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   function DataSave()\{\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   // сохраняем данные\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Рассмотрим подробнее аргументы функций, их назначение и использование.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Аргументы функций\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 У каждой функции может быть, как мы уже говорили, список аргументов. С помощью этих аргументов в функцию передается различная информация (например, значение числа, факториал которого надо подсчитать). Каждый аргумент представляет собой переменную или константу.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 С помощью аргументов данные в функцию можно передавать тремя различными способами. Это передача аргументов по значению (используется по умолчанию), по ссылке и задание значения аргументов по умолчанию. Рассмотрим эти способы подробнее.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Когда аргумент передается в функцию по значению, изменение значения аргумента внутри функции не влияет на его значение вне функции. Чтобы позволить функции изменять ее аргументы, их нужно передавать по ссылке. Для этого в определении функции перед именем аргумента следует написать знак амперсанд «&».\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // напишем функцию, которая бы добавляла\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // к строке слово checked\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 function add_label(&$data_str)\{\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   $data_str .= "checked";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $str = "<input type=radio name=article ";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   // пусть имеется такая строка\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo $str ."><br>"; \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // выведет элемент формы –\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // не отмеченную радио кнопку\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 add_label($str);             \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // вызовем функцию\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo $str ."><br>"; \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // это выведет уже отмеченную\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // радио кнопку\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В функции можно определять значения аргументов, используемые по умолчанию. Само значение по умолчанию должно быть константным выражением, а не переменной и не представителем класса или вызовом другой функции.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 У нас есть функция, создающая информационное сообщение, подпись к которому меняется в зависимости от значения переданного ей параметра. Если значение параметра не задано, то используется подпись "Оргкомитет".\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 function Message($sign="Оргкомитет.")\{\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // здесь параметр sign имеет по умолчанию значение "Оргкомитет"\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   echo "Следующее собрание состоится завтра.<br>";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   echo "$sign<br>";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Message(); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // вызываем функцию без параметра.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // В этом случае подпись – это Оргкомитет\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Message("С уважением, Вася"); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // В этом случае подпись\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // будет "С уважением, Вася."\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Результатом работы этого скрипта будет:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Следующее собрание состоится завтра. \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Оргкомитет.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Следующее собрание состоится завтра. \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 С уважением, Вася.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если у функции несколько параметров, то те аргументы, для которых задаются значения по умолчанию, должны быть записаны после всех остальных аргументов в определении функции. В противном случае появится ошибка, если эти аргументы будут опущены при вызове функции.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Например, мы хотим внести описание статьи в каталог. Пользователь должен ввести такие характеристики статьи, как ее название, автор и краткое описание. Если пользователь не вводит имя автора статьи, считаем, что это Иванов Иван.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 function Add_article($title, $description,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     $author="Иванов Иван")\{\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   echo "Заносим в каталог статью: $title,";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   echo "автор $author";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   echo "<br>Краткое описание: ";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   echo "$description <hr>";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Add_article("Информатика и мы",\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     "Это статья про информатику ...",\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    "Петров Петр");\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Add_article("Кто такие хакеры", \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     "Это статья про хакеров ...");\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В результате работы скрипта получим следующее\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Заносим в каталог статью: Информатика и мы,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    автор Петров Петр.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Краткое описание: \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    Это статья про информатику...\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Заносим в каталог статью: Кто такие хакеры,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    автор Иванов Иван.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Краткое описание: \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    Это статья про хакеров...\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если же мы напишем вот так:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 function Add_article($author="Иванов Иван",\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     $title, $description)\{\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // ...действия как в предыдущем примере\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Add_article("Кто такие хакеры", \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     "Это статья про хакеров...");\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 То в результате получим:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Warning: Missing argument 3 for \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     add_article() in\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 c:\\users\\nina\\tasks\\func\\def_bad.php \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     on line 2\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Списки аргументов переменной длины\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В PHP4 можно создавать функции с переменным числом аргументов. То есть мы создаем функцию, не зная заранее, со сколькими аргументами ее вызовут. Для написания такой функции никакого специального синтаксиса не требуется. Все делается с помощью встроенных функций func_num_args(), func_get_arg(), func_get_args().\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Функция func_num_args() возвращает число аргументов, переданных в текущую функцию. Эта функция может использоваться только внутри определения пользовательской функции. Если она появится вне функции, то интерпретатор выдаст предупреждение.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 function DataCheck()\{\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   $n = func_num_args();\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   echo "Число аргументов функции $n";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 DataCheck(); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    // выведет строку \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    // "Число аргументов функции 0"\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 DataCheck(1,2,3); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    // выведет строку\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    // "Число аргументов функции 3"\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Функция func_get_arg (целое номер_аргумента ) возвращает аргумент из списка переданных в функцию аргументов, порядковый номер которого задан параметром номер_аргумента. Аргументы функции считаются начиная с нуля. Как и func_num_args(), эта функция может использоваться только внутри определения какой-либо функции.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Номер_аргумента не может превышать число аргументов, переданных в функцию. Иначе будет сгенерировано предупреждение, и функция func_get_arg() возвратит False.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Создадим функцию для проверки типа данных, ее аргументов. Считаем, что проверка прошла успешно, если первый аргумент функции – целое число, второй – строка.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 function DataCheck()\{\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   $check =true;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   $n = func_num_args(); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      // число аргументов,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      // переданных в функцию\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   /* проверяем, является ли первый \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   переданный аргумент целым числом */\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   if ($n>=1) if (!is_int(func_get_arg(0)))\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0       $check = false;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   /* проверяем, является ли второй \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   переданный аргумент строкой */\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   if ($n>=2) \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      if (!is_string(func_get_arg(1)))\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         $check = false;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 return $check;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 if (DataCheck(a123,"text")) \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    echo "Проверка прошла успешно<br>";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 else echo "Данные не удовлетворяют \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    условиям<br>";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 if (DataCheck(324)) \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    echo "Проверка прошла успешно<br>";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 else echo "Данные не удовлетворяют условиям<br>";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Результатом работы будет следующее.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Данные не удовлетворяют условиям\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Проверка прошла успешно\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Функция func_get_args() возвращает массив, состоящий из списка аргументов, переданных функции. Каждый элемент массива соответствует аргументу, переданному функции. Если функция используется вне определения пользовательской функции, то генерируется предупреждение.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Перепишем предыдущий пример, используя эту функцию. Будем проверять, является ли целым числом каждый четный аргумент, передаваемый функции:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 function DataCheck()\{\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   $check =true;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   $n = func_num_args(); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   // число аргументов,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   // переданных в функцию\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   $args = func_get_args(); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   // массив аргументов функции\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   for ($i=0;$i<$n;$i++)\{\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     $v = $args[$i];\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     if ($i % 2 == 0)\{\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0       if (!is_int($v)) $check = false; \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      // проверяем,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0       // является ли четный аргумент целым\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 return $check;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 if (DataCheck("text", 324)) \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    echo "Проверка прошла успешно<br>";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 else echo "Данные не удовлетворяют \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    условиям<br>";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Как видим, комбинации функций func_num_args(), func_get_arg() и func_get_args() используется для того, чтобы функции могли иметь переменный список аргументов. Эти функции были добавлены только в PHP 4. В PHP3 для того, чтобы добиться подобного эффекта, можно использовать в качестве аргумента функции массив. Например, вот так можно написать скрипт, проверяющий, является ли каждый нечетный параметр функции целым числом:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 function DataCheck($params)\{\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   $check =true;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   $n = count($params); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   // число аргументов,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   // переданных в функцию\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   for ($i=0;$i<$n;$i++)\{\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     $v = $params[$i];\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     if ($i % 2 !== 0)\{\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0       // проверяем, является ли нечетный\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0       // аргумент целым\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 if (!is_int($v)) $check = false;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 return $check;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 if (DataCheck("text", 324))\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     echo "Проверка прошла успешно<br>";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 else echo "Данные не удовлетворяют условиям<br>";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Использование переменных внутри функции\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Глобальные переменные\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Чтобы использовать внутри функции переменные, заданные вне нее, эти переменные нужно объявить как глобальные. Для этого в теле функции следует перечислить их имена после ключевого слова global:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 global $var1, $var2;\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $a=1;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 function Test_g()\{\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 global $a;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   $a = $a*2;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   echo 'в результате работы функции $a=',$a;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo 'вне функции $a=',$a,', ';\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Test_g();\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo "<br>";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo 'вне функции $a=',$a,', ';\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Test_g();\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В результате работы этого скрипта получим:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 вне функции $a=1, в результате работы \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    функции $a=2\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 вне функции $a=2, в результате работы \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    функции $a=4\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Когда переменная объявляется как глобальная, фактически создается ссылка на глобальную переменную. Поэтому такая запись эквивалентна следующей (массив GLOBALS содержит все переменные, глобальные относительно текущей области видимости):\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $var1 = & $GLOBALS["var1"];\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $var2 = & $GLOBALS["var2"];\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Это значит, например, что удаление переменной $var1 не удаляет глобальной переменной $_GLOBALS["var1"].\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Статические переменные\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Чтобы использовать переменные только внутри функции, при этом сохраняя их значения и после выхода из функции, нужно объявить эти переменные как статические. Статические переменные видны только внутри функции и не теряют своего значения, если выполнение программы выходит за пределы функции. Объявление таких переменных производится с помощью ключевого слова static:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 static $var1, $var2;\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Статической переменной может быть присвоено любое значение, но не ссылка.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 function Test_s()\{\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 static $a = 1; \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // нельзя присваивать выражение или ссылку\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   $a = $a*2;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   echo $a;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Test_s(); // выведет 2\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo $a;  // ничего не выведет, так как \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0           // $a доступна только \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         // внутри функции\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Test_s(); // внутри функции $a=2, поэтому \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0           // результатом работы функции \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         // будет число 4\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Возвращаемые значения\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Все функции, приведенные выше в качестве примеров, выполняли какие-либо действия. Кроме подобных действий, любая функция может возвращать как результат своей работы какое-нибудь значение. Это делается с помощью утверждения return. Возвращаемое значение может быть любого типа, включая списки и объекты. Когда интерпретатор встречает команду return в теле функции, он немедленно прекращает ее исполнение и переходит на ту строку, из которой была вызвана функция.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Например, составим функцию, которая возвращает возраст человека. Если человек не умер, то возраст считается относительно текущего года.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 /* если второй параметр вычисляется \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 как true, то он рассматривается как \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 дата смерти, */\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 function Age($birth, $is_dead)\{\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   if ($is_dead) return $is_dead-$birth;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   else return date("Y")-$birth;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo Age(1971, false); // выведет 33\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo Age(1971, 2001); // выведет 30\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В этом примере можно было и не использовать функцию return, а просто заменить ее функцией вывода echo. Однако если мы все же делаем так, что функция возвращает какое-то значение (в данном случае возраст человека), то в программе мы можем присвоить любой переменной значение этой функции:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $my_age = Age(1981, 2004);\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В результате работы функции может быть возвращено только одно значение. Несколько значений можно получить, если возвращать список значений (одномерный массив). Допустим, мы хотим получить полный возраст человека с точностью до дня.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 function Full_age($b_day, $b_month, $b_year)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \{\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         $y = date("y");\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         $m = intval(date("m"));\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         $d = intval(date("d"));\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         $b_month = intval($b_month);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         $b_day = intval($b_day);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         $b_year = intval($b_year);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         $day = ($b_day > $d ?  $d : $d - $b_day);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         $tmpMonth = ($b_day > $d ?  -1 : 0);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         $month = ($b_month > $m + $tmpMonth ?  $m  : $m + $tmpMonth - $b_month);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         $tmpYear  = ($b_month >  $m + $tmpMonth ?  -1 : 0);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         if ($b_year > $y + $tmpYear)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         \{\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                 $year = 0; $month = 0; $day = 0;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         else\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         \{\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                 $year = $y + $tmpYear - $b_year;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         return array ($day,$month,$year);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $age = Full_age("29","06","1986");\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo "Вам $age[2] лет, $age[1] месяцев и $age[0] дней";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Когда функция возвращает несколько значений для их обработки в программе, удобно использовать языковую конструкцию list(), которая позволяет одним действием присвоить значения сразу нескольким переменным. Например, в предыдущем примере, оставив без изменения функцию, обработать возвращаемые ей значения можно было так:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // задание функции Full_age()\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 list($day,$month,$year) = Full_age("07",\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     "08","1974");\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo "Вам $year лет, $month месяцев и \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     $day дней";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Вообще конструкцию list() можно использовать для присвоения переменным значений элементов любого массива.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $arr = array("first","second");\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 list($a,$b) = $arr; \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    // переменной $a присваивается первое\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    // значение массива, $b – второе\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo $a," ",$b;     \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    // выведет строку «first second»\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Возвращение ссылки\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В результате своей работы функция также может возвращать ссылку на какую-либо переменную. Это может пригодиться, если требуется использовать функцию для того, чтобы определить, какой переменной должна быть присвоена ссылка. Чтобы получить из функции ссылку, нужно при объявлении перед ее именем написать знак амперсанд (&) и каждый раз при вызове функции перед ее именем тоже писать амперсанд (&). Обычно функция возвращает ссылку на какую-либо глобальную переменную (или ее часть – ссылку на элемент глобального массива), ссылку на статическую переменную (или ее часть) или ссылку на один из аргументов, если он был также передан по ссылке.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $a = 3; $b = 2;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 function & ref($par)\{\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 global $a, $b;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   if ($par % 2 == 0) return $b;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   else return $a;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $var =& ref(4);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo $var, " и ", $b, "<br>"; \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    //выведет 2 и 2\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $b = 10;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo $var, " и ", $b, "<br>"; \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    // выведет 10 и 10\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 При использовании синтаксиса ссылок в переменную $var нашего примера не копируется значение переменной $b возвращенной функцией $ref, а создается ссылка на эту переменную. То есть теперь переменные $var и $b идентичны и будут изменяться одновременно.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Переменные функции\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 PHP поддерживает концепцию переменных функций. Это значит, что если имя переменной заканчивается круглыми скобками, то PHP ищет функцию с таким же именем и пытается ее выполнить.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 /* создадим две простые функции: \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Add_sign – добавляет подпись к строке и\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Show_text – выводит строку текста */\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 function Add_sign($string, \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    $sign="С уважением, Петр")\{\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    echo $string ." ".$sign;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 function Show_text()\{\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   echo "Отправить сообщение по почте<br>";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $func = "Show_text"; \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    // создаем переменную со значением,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    // равным имени функции Show_text\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $func(); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    // это вызовет функцию Show_text\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $func = "Add_sign";  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    // создаем переменную со значением,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    // равным имени функции Add_sign\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $func("Привет всем <br>"); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    // это вызовет функцию\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    // Add_sign с параметром "Привет всем"\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В этом примере функция Show_text просто выводит строку текста. Казалось бы, зачем для этого создавать отдельную функцию, если существует специальная функция echo(). Дело в том, что такие функции, как echo(), print(), unset(), include() и т.п. нельзя использовать в качестве переменных функций. То есть если мы напишем:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $func = "echo ";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $func("TEXT");\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 то интерпретатор выведет ошибку:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Fatal error: Call to undefined function: \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     echo() in\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 c:\\users\\nina\\tasks\\func\\var_f.php on line 2\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Поэтому для того, чтобы использовать любую из перечисленных выше функций как переменную функцию, нужно создать собственную функцию, что мы и сделали в предыдущем примере.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Внутренние (встроенные) функции\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Говоря о функциях, определяемых пользователем, все же нельзя не сказать пару слов о встроенных функциях. С некоторыми из встроенных функций, такими как echo(), print(), date(), include(), мы уже познакомились. На самом деле все перечисленные функции, кроме date(), являются языковыми конструкциями. Они входят в ядро PHP и не требуют никаких дополнительных настроек и модулей. Функция date() тоже входит в состав ядра PHP и не требует настроек. Но есть и функции, для работы с которыми нужно установить различные библиотеки и подключить соответствующий модуль. Например, для использования функций работы с базой данных MySql следует скомпилировать PHP с поддержкой этого расширения. В последнее время наиболее распространенные расширения и соответственно их функции изначально включают в состав PHP так, чтобы с ними можно работать без каких бы то ни было дополнительных настроек интерпретатора.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Решение задачи\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Напомним, в чем состоит задача. Мы хотим написать интерфейс, который позволял бы создавать html-формы. Пользователь выбирает, какие элементы и в каком количестве нужно создать, придумывает им названия, а наша программа сама генерирует требуемую форму.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Разобьем задачу на несколько подзадач: выбор типов элементов ввода и их количества, создание названий элементов ввода и обработка полученных данных, т.е. непосредственно генерация формы. Первая задача достаточно проста: нужно написать соответствующую форму, например подобную приведенной ниже (task_form.html):\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <form action="ask_names.php">\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Создать элемент "строка ввода текста": <input\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   type=checkbox name=types[] \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   value=string><br>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Количество элементов: <input type=text \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   name=numbers[string]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   size=3><br>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <br>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Создать элемент "текстовая область": <input\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   type=checkbox\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   name=types[] value=text><br>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Количество элементов: <input type=text \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   name=numbers[text]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   size=3><br>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <input type=submit value="Создать">\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 </form>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Когда мы пишем в имени элемента формы, например types[], это значит, что его имя – следующий элемент массива types. То есть у нас первый элемент формы ("строка ввода текста") будет иметь имя types[0], а второй (текстовая область) – types[1]. В браузере task_form.html будет выглядеть примерно так:\par
\par
\qc\par\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 \b Рис. 5.1.\b0            Форма для выбора создаваемых элементов и их количества\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 После отправки данных этой формы мы получим информацию о том, какие элементы и сколько элементов каждого типа нужно создать. Следующий скрипт запрашивает названия для этих элементов:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Допустим, нужно создать два элемента типа «текстовая строка» и один элемент типа «текстовая область», как и отмечено в форме выше. Тогда скрипт ask_names.php обработает ее таким образом, что мы получим такую форму:\par
\par
\qc\par\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 \b Рис. 5.2.\b0            Форма для ввода названий создаваемых элементов\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Введем в эту форму, например, строки «Название», «Автор» и «Краткое содержание». Эти данные будет обрабатывать скрипт task.php.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Результатом работы этого скрипта с входными данными, приведенными выше, будет следующая форма:\par
\par
\qc\par\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 \b Рис. 5.3.\b0            Пример формы, сгенерированной нашей программой\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Заключение\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Подведем итоги. В этой лекции мы изучили функции, определяемые пользователем, их синтаксис и семантику, способы передачи их аргументов и возвращаемых значений. Кроме того, обсуждались способы задания и работы с функциями, имеющими переменное число аргументов и альтернативный способ вызова функции (с помощью переменной, значение которой есть имя функции). В следующей лекции будет рассмотрена объектная модель языка PHP.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Объекты и классы в PHP\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В этой лекции мы рассмотрим объектную модель, предлагаемую языком PHP. Будут представлены понятия класса и объекта, способы их задания и использования, способы расширения классов, конструкторы классов, механизмы наследования и т.п. Кроме того, мы затронем некоторые нововведения, касающиеся объектной модели, появившиеся в PHP5.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В качестве примера решим задачу автоматической генерации по желанию пользователя представителей классов статей или личностей, а также их отображения на странице браузера.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Классы и объекты\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Начнем с основных понятий объектно-ориентированного программирования – класса и объекта. Существует множество определений этих понятий. Мы дадим следующее: объект – это структурированная переменная, содержащая всю информацию о некотором физическом предмете или реализуемом в программе понятии, класс – это описание таких объектов и действий, которые можно с ними выполнять.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В PHP класс определяется с помощью следующего синтаксиса:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 class Имя_класса\{\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   var $имя_свойства;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     /*список свойств*/\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   function имя_метода( )\{\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    /* определение метода */\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   /*список методов*/\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \}\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Имена свойств объектов класса объявляются с помощью ключевого слова var, методы, применимые к объектам данного класса, описываются функциями. Внутри определения класса можно использовать ключевое слово this для обращения к текущему представителю класса.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Например, нам нужно создать класс, описывающий категорию статей. У каждой статьи имеются такие свойства, как название, автор и краткое содержание. Какие действия мы хотим совершать со статьями? Возможно, нам понадобится задавать значения перечисленным свойствами статьи, отображать статью в браузере. Тогда определение этого класса может выглядеть следующим образом:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 class Articles \{ // Создаем класс Статей\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   var $title;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   var $author;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   var $description;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // метод, который присваивает значения\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // атрибутам класса\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   function make_article($t, $a, $d)\{\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     $this->title = $t;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     $this->author = $a;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     $this->description = $d;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 //метод для отображения экземпляров класса\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   function show_article()\{\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     $art = $this->title . "<br>" .\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0            $this->description .\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0       "<br>Автор: " . $this->author;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     echo $art;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Итак, для описания физических объектов типа «статья» мы создали класс с именем Articles, состоящий из трех переменных, содержащих характеристики статьи, и двух функций для создания конкретной статьи и для ее отображения.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Как известно, работая с PHP, можно периодически переключаться в режим HTML. В этом случае программа состоит из нескольких кусков (блоков) кода. Определение класса нельзя разносить по разным блокам php-кода и тем более по разным файлам. То есть если написать:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 class Articles \{ // Начало описания класса\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   var $title;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // продолжение описания класса\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    function show_article()\{\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    // содержание метода\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \} // конец описания класса\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 то программа не будет работать корректно.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Несколько замечаний по поводу имен классов. Имя класса должно удовлетворять правилам именования объектов в языке PHP, но есть ряд имен, которые зарезервированы разработчиками для своих целей. В первую очередь это имена, начинающиеся с символа подчеркивания «_». Для создания классов и функций нельзя использовать такие имена. Кроме того, зарезервировано имя stdClass, поскольку оно используется внутри движка PHP.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Инициализация переменных\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Часто некоторым атрибутам класса бывает необходимо присваивать значения сразу после создания представителя класса. Когда мы создавали класс статей, для присваивания значений атрибутам (свойствам) класса мы использовали специальную функцию make_article(). Вообще говоря, мы поступили не совсем верно, потому что занялись изобретением велосипеда. Специально для задания начальных значений атрибутам класса существует два стандартных метода. В PHP4 можно инициализировать значения с помощью оператора var или с помощью функции конструктора. С помощью var можно инициализировать только константные значения. Для задания не константных значений используют функцию конструктор, которая вызывается автоматически, когда объект конструируется из класса. Функция-конструктор должна иметь имя, совпадающее с именем всего класса, в котором она определена.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Приведем пример. Допустим, при создании объекта «статья» мы хотим установить его свойства следующим образом: автора – равным строке «Иванов», название и краткое содержание – соответствующим элементам глобального массива $_POST, а дату публикации статьи – текущей дате. Тогда следующее описание класса не является корректным в PHP4:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 class Articles \{ // Создаем класс Статей\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   var $title= $_POST["title"];\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   var $author = "Иванов";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   var $description = $_POST["description"];\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   var $published = date("Y-m-d");\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // метод, который присваивает значения\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // атрибутам класса\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 А вот такое описание класса в PHP4 будет работать так, как нужно:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 class Articles \{ // Создаем класс Статей\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   var $title;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   var $author = "Иванов";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   var $description;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   var $published;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // метод, который присваивает значения\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // атрибутам класса\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  function Articles()\{\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   $this->title = $_POST["title"];\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   $this->description = $_POST["description"];\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   $this ->published = date("Y-m-d");\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Отметим, что в PHP3 и PHP4 конструкторы работают по-разному. В PHP3 функция становилась конструктором, если она имела то же имя, что и класс, а в PHP4 – если она имеет то же имя, что и класс, в котором она определена. Разница в подходах видна, когда один класс расширяет другой и происходит наследование свойств и методов базового класса. Но об этом мы поговорим чуть позже. В PHP5 конструктор класса именуется _construct. Кроме того, в PHP5 появились и деструкторы – функции, которые вызываются автоматически перед уничтожением объекта. В PHP5 функция-деструктор должна быть названа _destruct.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Объекты\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В одной из первых лекций мы упоминали о существовании в PHP такого типа данных, как объект. Класс – это описание данных одного типа, данных типа объект. Классы являются как бы шаблонами для реальных переменных. Переменная нужного типа создается из класса с помощью оператора new. Создав объект, мы можем применять к нему все методы и получать все свойства, определенные в описании класса. Для этого используют такой синтаксис: $имя_объекта->название_свойства или $имя_объекта->название_метода(список аргументов). Заметим, что перед названием свойства или метода знака $ не ставят.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $art = new Articles; \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // создаем объект $art\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo ($art ->title); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // выводим название объекта $art\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $another_art = new Articles; \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // создаем объект $another_art\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $another_art->show_article(); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // вызываем метод для\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // отображения объекта в браузер\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Каждый из объектов класса имеет одни и те же свойства и методы. Так, у объекта $art и у объекта $another_art есть свойства title, description, author и методы Articles(), show_article(). Но это два разных объекта. Представим себе объект как директорию в файловой системе, а его характеристики – как файлы в этой директории. Очевидно, что в каждой директории могут лежать одинаковые файлы, но тем не менее они считаются различными, поскольку хранятся в разных директориях. Точно так же свойства и методы считаются различными, если они применяются к разным объектам. Чтобы получить нужный файл из директории верхнего уровня, мы пишем полный путь к этому файлу. При работе с классами нужно указывать полное имя функции, которую мы хотим вызвать. Директорией верхнего уровня в PHP будет пространство глобальных переменных, а путь указывается с помощью разделителя ->. Таким образом, имена $art->title и $another_art->title обозначают две разные переменные. Переменная в PHP имеет только один знак доллара перед именем, поэтому нельзя писать $art->$title. Эта конструкция будет рассмотрена не как обращение к свойству title объекта $art, а как обращение к свойству, имя которого задано переменной $title (например, $art->"").\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $art->title = "Введение в Internet"; \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // так можно установить\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // значение свойства объекта\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $art->$title = "Введение в Internet"; \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // так нельзя установить\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // значение свойства объекта\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $property = "title";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $art->$property = "Введение в Internet"; \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // так можно установить значение \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // свойства объекта\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Создавая класс, мы не можем знать, какое имя будет иметь объект этого класса, тем более что объектов может быть много и все могут иметь разные имена. Соответственно мы не знаем, как обращаться к объекту внутри определения класса. Для того чтобы иметь доступ к функциям и переменным внутри определения класса, нужно использовать псевдопеременную $this. Например, $this->title возвращает значение свойства title у текущего объекта данного класса. Иногда эту переменную предлагают читать как «мое собственное» (к примеру, по отношению к свойству).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Наследование\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i extends\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Механизм наследования – очень важная часть всего объектно-ориентированного подхода. Попытаемся объяснить его суть на примере. Допустим, мы создаем описание человека. Очевидно, что сделать это мы можем по-разному, в зависимости от того, для чего нужно это описание. Можно описать человека как программиста: он знает такие-то языки программирования, операционные системы, участвовал в стольких-то проектах. Однако если человек программист, то он не перестает быть человеком вообще, т.е. он имеет имя, фамилию, место жительства и т.п. Если перевести наши рассуждения в термины объектно-ориентированного программирования, то можно сказать, что мы описали два класса – класс людей и класс программистов, каждый со своими свойствами и методами. Причем класс программистов, очевидно, обладает всеми свойствами класса людей и при этом имеет свои специфические характеристики, т.е. класс программистов является подклассом класса людей. Так, если у человека вообще есть имя, то у программиста оно тоже должно быть, но не наоборот. Кроме программистов можно выделить еще множество классов по профессиональной принадлежности людей. И все они будут подклассами класса людей. Часто на практике удобно определять общий класс, который может использоваться сразу в нескольких проектах (например, класс людей или личностей), и адаптировать его для специфических нужд каждого проекта (например, как класс программистов). Как это можно реализовать? С помощью механизма расширений. Любой класс может быть расширением другого класса. Расширяющий (или производный) класс, кроме тех свойств и методов, которые описаны в его определении, имеет все функции и свойства основного (базового класса). В нашем примере класс программистов – расширяющий, а класс всех людей – базовый. Из класса нельзя удалить никакие существующие свойства и функции, класс можно только расширить. Расширяющий класс в PHP4 всегда зависит только от одного базового класса, поскольку множественное наследование в PHP не поддерживается. Расширяются классы в PHP с помощью ключевого слова extends.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 class Person \{ // определяем класс Личности\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   var $first_name; // имя личности\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   var $last_name; // фамилия личности\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   function make_person($t,$a)\{ \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   // метод устанавливает\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   // значения имени и фамилии объекта\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     $this->first_name = $t;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     $this->last_name = $a;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   function show_person()\{ \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   // метод отображает информацию о личности\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     echo ("<h2>" . $this->first_name . " " .\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0       $this->last_name . "</h2>");\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 class Programmer extends Person\{ \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // определяем класс\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // Programmer, расширяющий Person\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   var $langs = array ("Lisp"); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // константным массивом\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // задать переменную в var можно\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     function set_lang($new_lang)\{ \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // метод добавляет еще\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // один язык к списку известных\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     $this->langs[] = $new_lang;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Класс Programmer имеет те же переменные и функции, что и класс Person, плюс переменную $langs, в которой содержится список изученных программистом языков, и функцию set_lang для добавления еще одного языка к списку изученных. Создать представителя класса программистов можно обычным способом с помощью конструкции new. После этого можно устанавливать и получать список языков, которые знает программист, и в то же время можно использовать функции, заданные для класса Person, т.е. устанавливать и получать имя и фамилию программиста и отображать сведения о нем в браузере:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $progr = new Programmer;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $progr -> set_lang("PHP"); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // методы, определенные для\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // класса Programmer\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 print_r ($progr->langs);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // методы, определенные для класса Person\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $progr->make_person("Bill","Gates");\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $progr->show_person();\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Отношения, в которых состоят созданные нами классы Person и Programmer, называют также отношениями родитель–потомок. Класс Person – родитель, а его потомки, такие как класс Programmer, создаются, основываясь на нем, с помощью расширений. Любой класс может стать родительским и соответственно породить потомков.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Порядок определения классов имеет значение. Нельзя сначала определить класс Programmer, расширяющий класс Person, а уже потом сам класс Person. Класс должен быть определен перед тем, как он будет использоваться (расширяться).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Конструкторы\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь, после знакомства с механизмом наследования в PHP, мы можем прокомментировать различие между конструкторами PHP4 и PHP3 и более подробно рассказать о конструкторах вообще. Напомним, что в PHP3 конструктор – это функция, имя которой совпадает с именем класса. А в PHP4 – функция, имя которой совпадает с именем класса, в котором она определена.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 class Programmer extends Person\{ \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // определяем класс\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // Programmer, расширяющий Person\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   var $langs = array ("Lisp");\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   function Programmer()\{ \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // этот конструктор будет\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // работать и в PHP3, и в PHP4\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     $this->make_person("Иван","Петров");\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Здесь функция Programmer() является конструктором, т.е. выполняется сразу после создания любого представителя класса Programmer, задавая ему имя «Иван» и фамилию «Петров». Конструкторы, как и любые другие функции, могут иметь аргументы. В этом случае, создавая представителя класса, нужно указать значения этих параметров. Аргументы конструктора могут иметь и значения по умолчанию. Если все аргументы имеют значения по умолчанию, тогда можно создавать экземпляр класса без параметров.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 class Programmer extends Person\{ \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // определяем класс\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // Programmer, расширяющий Person\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   var $langs = array ("Lisp");\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   function Programmer($n = "Иван", \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                       $f = "Петров")\{\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // это конструктор\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     $this->make_person($n,$f);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $default_progr = new Programmer(); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // создаст программиста Ивана Петрова\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $new_progr = new Programmer("Вася",\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                             "Сидоров");\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // создаст программиста Васю Сидорова\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 print_r($new_progr); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 /* выведет информацию о переменной \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $new_progr, т.е. свойства объекта \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 и их значения */\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Приведенные примеры будут работать и в PHP3, и в PHP4, конечно если дописать в них определение базового класса Person. Допустим, ситуация немного другая: конструктор имеется только у базового класса Person:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 class Person \{ // определяем класс Личности\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   var $first_name;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   var $last_name;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   function Person($t,$a)\{ // конструктор\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     $this->first_name = $t;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     $this->last_name = $a;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         /* ...        */\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 class Programmer extends Person\{ \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // определяем класс\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // Programmer, расширяющий Person\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   var $langs = array ("Lisp");\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   function set_lang($new_lang)\{\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     $this->langs[] = $new_lang;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $new_progr = new Programmer("Вася",\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                             "Сидоров");\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Что произойдет в этом случае при создании объекта класса Programmer, будет ли автоматически вызвана какая-либо функция? В PHP3 ничего не произойдет, поскольку в этом классе нет функции с именем Programmer() (здесь конструктор – это функция, имя которой совпадает с именем класса). В PHP4 будет вызван конструктор базового класса, если он существует, т.е. вызовется функция Person() из класса Person (здесь конструктор – функция, имя которой совпадает с именем класса, в котором она определена).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Еще одна ситуация – в базовом классе есть функция, имя которой совпадает с именем расширяющего класса, а в расширяющем классе нет конструктора.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 class Person \{ // определяем класс Личности\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   var $first_name;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   var $last_name;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   function Person($t,$a)\{ // конструктор\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     $this->first_name = $t;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     $this->last_name = $a;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   function Programmer($new_lang)\{\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     echo "Я – программист";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 class Programmer extends Person\{ \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // определяем класс\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // Programmer, расширяющий Person\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   var $langs = array ("Lisp");\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   function set_lang($new_lang)\{\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     $this->langs[] = $new_lang;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $new_progr = new Programmer("Вася",\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                             "Сидоров");\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В этом случае PHP3 вызовет в качестве конструктора функцию Programmer() из описания класса Person. Поскольку конструктор – это функция, у которой то же имя, что и у класса. И неважно, определена ли эта функция в самом классе или она наследуется из базового класса. В PHP4 класс Programmer не будет иметь своего конструктора, поэтому вызовется конструктор базового класса.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Ни в PHP 3, ни в PHP 4 конструктор базового класса не вызывается автоматически из конструктора порожденного класса.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Оператор ::\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Иногда внутри описания класса возникает необходимость сослаться на функции или переменные из базового класса. Бывает, что нужно ссылаться на функции в классе, ни один представитель которого еще не создан. Как быть в таком случае? В PHP4 для этого существует специальный оператор «::»\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Например, вот так можно вызвать в описании класса Programmer функцию show_name() из базового класса Person и функцию say_hello(), заданную в описании класса Programmer, когда ни один объект этого класса еще не был создан:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 class Person \{ // определяем класс Личности\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   var $first_name;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   var $last_name;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   function Person($t,$a)\{ // конструктор\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     $this->first_name = $t;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     $this->last_name = $a;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 function show_name()\{ \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   // метод отображает информацию о личности\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     echo ("Меня зовут, " . \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0           $this->first_name . " " .\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0           $this->last_name . "!<br>");\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 class Programmer extends Person\{ \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // определяем класс\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // Programmer, расширяющий Person\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   function set_lang($new_lang)\{ \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // метод добавляет еще\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // один язык к списку известных\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     $this->langs[] = $new_lang;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     Person::show_name(); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // вызываем функцию из базового класса\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     echo "И я знаю теперь еще и " . \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0           $new_lang;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   function show_name()\{\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   echo ("Я программист, " . \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         $this->first_name . " " .\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         $this->last_name . "!<br>");\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   function say_hello()\{\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     echo "Привет!<br>";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Programmer::say_hello(); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // вызываем функцию, когда ни\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // один объект ее класса еще не создан\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $new_progr = new Programmer("Вася","Сидоров");\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $new_progr->set_lang("PHP");\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В результате работы этой программы получим следующее:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Привет!\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Меня зовут Вася Сидоров!\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 И я знаю теперь еще и PHP\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 С помощью команды Programmer::say_hello(); мы вызываем функцию say_hello класса Programmer как таковую, а не как метод, применяемый к объекту данного класса. В этот момент переменных класса нет. Поэтому функции, вызываемые до создания объекта, не могут пользоваться переменными класса и конструкцией this, но могут пользоваться локальными и глобальными переменными.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В определении класса Programmer мы переопределили функцию show_name(), поэтому вызвать функцию show_name() из базового класса Person можно только с помощью оператора «::» Вообще говоря, внутри определения класса мы можем вызывать любые методы и свойства, заданные в его базовом классе с помощью обычного $this, если только порожденный класс не переопределяет эти свойства и методы, как в нашем примере.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Оператор parent\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В приведенном выше примере, обращаясь в базовому классу, мы использовали его имя (мы писали Person::show_name()). Это не совсем удобно, потому что имя класса или иерархия классов может измениться, и тогда придется переписывать код описаний всех классов с тем, чтобы привести используемые в них имена в соответствие с новой иерархией. Чтобы избежать подобной ситуации, вместо имени базового класса нужно использовать ключевое слово parent (например, parent::show_name()). Parent ссылается на класс, прописанный после extends в объявлении вашего класса. Поэтому если вдруг иерархия классов изменится, то достаточно будет внести изменения в имена, указанные после extends в описаниях классов.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Объектная модель PHP5\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Кроме нового названия для конструкторов и появления деструкторов в PHP5 произошло еще достаточно много изменений. Мы не будем обсуждать их подробно, только опишем в общих чертах. Основное изменение – это передача значений параметров класса по ссылке и присвоение объектов по ссылке, а не по значению, как это было в PHP4. В PHP5 если создаются две равные переменные типа объект, то они указывают на одно значение и изменяются одновременно (мы приводили похожий пример с переменными строкового типа). В связи с этим появился новый механизм для создания копий объектов – так называемое клонирование. В PHP4 все методы и переменные класса доступны извне, т.е. они всегда являются открытыми. В PHP5 переменные и методы можно делать открытыми (доступными отовсюду), закрытыми (доступными только внутри класса) и защищенными (доступными внутри класса и в его производных классах). Кроме того, появилась возможность создавать интерфейсы и абстрактные классы и многое другое. В целом объектная модель в PHP5 значительно усовершенствована для более точного соответствия объектно-ориентированной парадигме программирования.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Решение задачи\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Итак, мы хотели по выбору пользователя генерировать форму для ввода описания статьи или человека и отображать данные, введенные в эту форму. Попробуем решить эту задачу, используя объектно-ориентированный подход. Для начала создадим форму, где пользователь выбирает, что он хочет создать, – описание статьи или человека (точнее, это будут две формы):\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <form action="task1.php">\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Создать описание статьи: <input type=submit\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     name=art_create\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     value="Create Article">\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 </form>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <form action="task1.php">\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Создать описание личности: <input \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    type=submit name=pers_create \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    value="Create Person">\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 </form>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь напишем файл для обработки этих форм. В нем создадим два класса – статьи и личности. У каждого класса имеется метод для инициализации его переменных и метод для отображения объектов данного класса. При решении задачи будут использованы две функции, встроенные в PHP для работы с классами и объектами. Это функция get_class(объект), возвращающая имя класса, экземпляром которого является объект, переданный ей в качестве параметра. И функция get_class_vars(имя класса), которая возвращает массив всех свойств класса и их значений по умолчанию. Аналогично можно получить массив имен всех методов класса: get_class_methods (имя класса)\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Заключение\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Итак, мы изучили основные понятия объектной модели, используемой в языке PHP. Были описаны правила создания классов и их представителей-объектов, способы задания начальных значений переменным класса, способы получения значений свойств и вызов методов классов.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Работа с массивами данных\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Язык PHP предоставляет множество функций для работы с массивами данных. Как правило, эти функции решают наиболее часто встречающиеся задачи, связанные с обработкой массивов. В этой лекции мы рассмотрим некоторые из таких функций и с их помощью решим несколько прикладных задач. В частности, будут рассмотрены функции для поиска элементов в массиве, для сортировки элементов массива, применение созданных пользователем функций ко всем элементам массива и разбивка массива на подмассивы.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Массивы\b0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В одной из первых лекций мы рассказывали о том, как можно создать массив данных. Напомним, что массив можно создать двумя способами:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 С помощью конструкции array\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $array_name = array("key1"=>"value1",\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                     "key2"=>"value2");\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  -    \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Непосредственно задавая значения элементам массива\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $array_name["key1"] = value1;\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  -    \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Например, нам нужно хранить список документов, которые будут удалены из базы данных. Естественно хранить его в виде массива, ключом в котором будет идентификатор документа (его уникальный номер), а значением – название документа. Этот массив можно создать таким образом:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $del_items = array("10"=>"Наука и жизнь",\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    "12"=>"Информатика");\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $del_items["13"] = "Программирование на Php"; \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // добавляем элемент в массив\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Операции с массивами\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Массив – это тип данных, с данными этого типа должны быть определены операции. Какие же операции можно производить с массивами? Массивы можно складывать и сравнивать.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Складывают массивы с помощью стандартного оператора «+». Вообще говоря, эту операцию по отношению к массивам точнее назвать объединением. Если у нас есть два массива, $a и $b, то результатом их сложения (объединения) будет массив  $c, состоящий из элементов $a, к которым справа дописаны элементы массива  $b. Причем, если встречаются совпадающие ключи, то в результирующий массив включается элемент из первого массива, т.е. из $a. Таким образом, если складываются массивы в языке PHP, от перемены мест слагаемых  сумма меняется.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $a = array("и"=>"Информатика", \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0            "м"=>"Математика");\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $b = array("и"=>"История","м"=>"Биология",\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0            "ф"=>"Физика");\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $c = $a + $b;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $d = $b +$a;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 print_r($c); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 /* получим: Array([и]=>Информатика\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    [м]=>Математика [ф]=>Физика) */\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 print_r($d); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 /* получим: Array([и]=>История\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    [м]=>Биология [ф]=>Физика) */\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Сравнивать массивы можно, проверяя их равенство или неравенство либо эквивалентность или неэквивалентность. Равенство массивов – это когда совпадают все пары ключ/значение элементов массивов. Эквивалентность – когда кроме равенства значений и ключей элементов требуется еще, чтобы элементы в обоих массивах были записаны в одном и том же порядке. Равенство значений в PHP обозначается символом «==», а эквивалентность – символом «===».\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $a = array("и"=>"Информатика", \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0            "м"=>"Математика");\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $b = array("м"=>"Математика", \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0            "и"=>"Информатика");\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 if ($a == $b) echo "Массивы равны и";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   else echo "Массивы НЕ равны и ";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 if ($a === $b) echo " эквивалентны";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   else echo " НЕ эквивалентны";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // получим echo "Массивы равны и \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                      НЕ эквивалентны"\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Далее рассмотрим еще одну важную операцию с массивом – подсчет количества его элементов. Для ее реализации в PHP есть специальная функция.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Функция count\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Не раз уже мы использовали функцию count(), чтобы вычислить количество элементов массива. На самом деле эта функция вычисляет число элементов в переменной вообще. Если применить ее к любой другой переменной, она возвратит 1. Исключение составляет переменная типа NULL – count(NULL) есть 0. Кроме того, применяя эту функцию к многомерному массиву, чтобы получить число его элементов, нужно использовать дополнительный параметр COUNT_RECURSIVE.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $del_items = array("langs" => array(\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     "10"=>"Python", "12"=>"Lisp"), \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     "other"=>"Информатика");\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo count($del_items) . "<br>"; \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // выведет 2\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo count($del_items,COUNT_RECURSIVE); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // выведет 4\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0          \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Мы не будем повторять все, что было сказано о массивах в предыдущих лекциях. В этой лекции мы рассмотрим некоторые встроенные функции для работы с массивами. И начнем мы с функций для поиска значений в массиве.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Функция in_array\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 in_array("искомое значение","массив", \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         ["ограничение на тип"]);\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 позволяет установить, содержится ли в заданном массиве искомое значение. Если третий аргумент задан как true, то в массиве нужно найти элемент, совпадающий с искомым не только по значению, но и по типу. Если искомое значение – строка, то сравнение чувствительно к регистру.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Например, имеется массив не изученных нами языков программирования. Мы хотим узнать, содержится ли в этом массиве язык PHP. Напишем следующую программу:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $langs = array("Lisp","Python","Java",\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                "PHP","Perl");\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 if (in_array("PHP",$langs)) \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     echo "Надо бы изучить PHP<br>";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // выведет сообщение "Надо бы изучить PHP"\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 if (in_array("php",$langs)) \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     echo "Надо бы изучить php<br>";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // ничего не выведет, поскольку в массиве\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // есть строка "PHP", а не "php"\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0          \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В качестве искомого значения этой функции может выступать и массив. Правда, это свойство было добавлено только начиная с PHP 4.2.0.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Например:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $langs = array("Lisp","Python",array("PHP","Java"),"Perl");\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 if (in_array(array("PHP","Java"),$langs))\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   echo "Надо бы изучить PHP и Java<br>";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0          \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Функция array_search\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Это еще одна функция для поиска значения в массиве. В отличие от in_array в результате работы array_search возвращает значение  ключа, если элемент найден, и ложь – в противном случае. А вот синтаксис у этих функций одинаковый:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 array_search("искомое значение","массив", \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0             ["ограничение на тип"]);\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Сравнение строк чувствительно к регистру, а если указан опциональный аргумент, то сравниваются еще и типы значений. До PHP 4.2.0, если искомое значение не было найдено, эта функция возвращала ошибку или пустое значение  NULL.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Пример 7.4. \b0  Теперь, наоборот, пусть у нас есть массив языков программирования, которые мы знаем. Причем ключом каждого элемента является номер, указывающий, каким по счету был изучен этот язык.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $langs = array("Lisp","Python","Java",\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                "PHP","Perl");\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 if (!array_search("PHP",$langs)) \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     echo "Надо бы изучить PHP<br>";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 else \{\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   $k = array_search("PHP",$langs);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   echo "PHP я изучила $k – м";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0          \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В результате мы получим строчку:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 PHP я изучила 3 – м\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Очевидно, что эта функция более функциональна, чем in_array, поскольку мы не только получаем информацию о том, что искомый элемент в массиве есть, но и узнаем, где именно в массиве он находится. А что будет, если искомых элементов в массиве несколько? В таком случае функция array_search() вернет ключ первого из найденных элементов. Чтобы получить ключи всех элементов, нужно воспользоваться функцией array_keys().\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Функция array_keys\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Функция array_keys() выбирает все ключи  массива. Но у нее имеется дополнительный аргумент, с помощью которого можно получить список ключей элементов с конкретным значением. Синтаксис этой функции таков:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 array_keys ("массив" \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     [,"значение для поиска"])\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Функция array_keys() возвращает как строковые, так и числовые ключи  массива, организуя все значения в виде нового массива с числовыми индексами.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Пример 7.5. \b0  Мы записали массив языков, которые изучили. Список был длинным, и некоторые языки были записаны несколько раз. У нас возникло подозрение, что один из таких языков – Lisp. Давайте это проверим:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $langs =\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 array("Lisp","Python","Java","PHP",\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0       "Perl","Lisp");\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $lisp_keys = array_keys($langs,"Lisp");\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo "Lisp входит в массив ". \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0           count($lisp_keys) ." раза:<br>";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 foreach ($lisp_keys as $val)\{\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     echo "под номером $val <br>";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0          \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В результате получим:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Lisp входит в массив 2 раза:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 под номером 0\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 под номером 5\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0          \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Функция array_keys(), как и две предыдущие, зависит от регистра, т.е. элементов LISP в массиве она не обнаружит. array_keys() появилась только в PHP4. В PHP3 для реализации ее функциональности нужно придумывать свою функцию.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если есть функция для получения всех ключей  массива, то можно предположить, что существует и функция для получения всех значений  массива. Действительно, она существует. Это функция array_values(массив). Все значения переданного ей массива записываются в новый массив, проиндексированный целыми числами, т.е. все ключи  массива теряются, остаются только значения. Но вернемся к нашему примеру.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Итак, мы выяснили, что язык Lisp случайно упомянут в нашем массиве дважды. Поскольку изучить один язык дважды нельзя («учил, но забыл» не считается), то нужно как-то избавиться от повторяющихся языков. Сделать это довольно просто с помощью функции array_unique().\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Функция array_unique\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Функция array_unique(массив) удаляет повторяющиеся значения из массива и возвращает новый массив. Таким образом, вместо нескольких одинаковых значений и их ключей мы имеем одно значение. Какой у него будет ключ? Как из нескольких ключей одинаковых элементов выбирается тот, который будет сохранен в новом массиве? Происходит следующее. Все элементы массива преобразуются в строки и сортируются. Затем обработчик запоминает первый ключ для каждого значения, а остальные ключи игнорирует.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Попробуем избавиться от повторяющихся языков в списке изученных.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $langs =\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 array("Lisp","Java","Python","Java",\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0       "PHP","Perl","Lisp");\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 print_r(array_unique($langs));\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0          \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Получим следующее:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Array ( [0] => Lisp [1] => Java [2] \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     => Python [4] => PHP [5] => Perl )\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0          \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Далее рассмотрим задачу сортировки массива.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Сортировка массивов\b0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Необходимость сортировки данных, в том числе и данных, хранящихся в виде массивов, очень часто возникает при решении самых разнообразных задач. Если в языке Си для того, чтобы решить эту задачу, нужно написать десятки строк кода, то в PHP это делается одной простой командой.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Функция sort\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Функция sort имеет следующий синтаксис\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 sort (массив [, флаги])\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 и сортирует массив, т.е. упорядочивает его значения по возрастанию. Эта функция удаляет все существовавшие в массиве  ключи, заменяя их числовыми индексами, соответствующими новому порядку элементов. В случае успешного завершения работы она возвращает true, иначе – false.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Пример 7.6. \b0  Пусть у нас есть два массива: цены товаров – их названия и, наоборот, названия товаров – их цены. Упорядочим эти массивы по возрастанию:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $items = array(10 => "хлеб", 20 => "молоко",\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   30 => "бутерброд");\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 sort($items); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // строки сортируются в алфавитном \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // порядке, ключи теряются\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 print_r($items);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $rev_items = array("хлеб" => 10, \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     "бутерброд" => 30, "молоко" => 20);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 sort($rev_items); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // числа сортируются по возрастанию,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // ключи теряются\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 print_r($rev_items);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0          \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Получим:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Array ( [0] => бутерброд [1] => \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     молоко [2] => хлеб )\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Array ( [0] => 10 [1] => 20 [2] => 30 )\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0          \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В качестве дополнительного аргумента флаги может использоваться одна из следующих констант:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - SORT_REGULAR – сравнивать элементы массива обычным образом;\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - SORT_NUMERIC – сравнивать элементы массива как числа;\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - SORT_STRING – сравнивать элементы массива как строки.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Функции asort, rsort, arsort\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если требуется сохранять индексы элементов массива после сортировки, то нужно использовать функцию asort (массив [, флаги]). Если необходимо отсортировать массив в обратном порядке, т.е. от наибольшего значения к наименьшему, то можно задействовать функцию rsort (массив [, флаги]). А если при этом нужно еще и сохранить значения  ключей, то следует использовать функцию arsort(массив [, флаги]). Как вы, наверное, заметили синтаксис у этих функций абсолютно такой же, как у функции sort. Соответственно и значения флагов могут быть такими же, как у sort: SORT_REGULAR, SORT_NUMERIC, SORT_STRING. Кстати говоря, флаг SORT_NUMERIC появился только в PHP4.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $books = array("Пушкин"=>"Руслан и Людмила",\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     "Толстой"=>"Война и мир",\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     "Лермонтов"=>"Герой нашего времени");\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 asort($books); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // сортируем массив, \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // сохраняя значения ключей\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 print_r($books);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo "<br>";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 rsort($books); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // сортируем массив в обратном порядке,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // ключи будут заменены\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 print_r($books);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0          \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В результате работы этого скрипта получим:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Array ( [Толстой] => Война и мир\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         [Лермонтов] => Герой нашего времени\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         [Пушкин] => Руслан и Людмила )\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Array ( [0] => Руслан и Людмила\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         [1] => Герой нашего времени \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         [2] => Война и мир )\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0          \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Пример 7.8.\b0   Допустим, мы создаем каталог описаний документов. У каждого документа есть автор, название, дата публикации и краткое содержание. Мы уже не раз отображали описания, составленные из этих характеристик. Каждый раз порядок отображения этих элементов зависел от созданной нами программы. Теперь же мы хотим иметь возможность изменять порядок отображения элементов по желанию пользователя. Составим для этого следующую форму:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <form action=task.php>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <table border=1>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <tr><td>Название </td><td><input type=text\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     name=title size=5> </td></tr>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <tr><td>Краткое содержание </td><td><input\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     type=text name=description size=5> \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    </td></tr>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <tr><td>Автор </td><td><input type=text\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     name=author size=5> </td></tr>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <tr><td>Дата публикации </td><td><input\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     type=text name=published size=5></td></tr>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 </table>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <input type=submit value="Отправить">\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 </form>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0          \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Будем упорядочивать данные, переданные этой формой, по убыванию их значений, сохраняя при этом значения  ключей. Для этого удобно воспользоваться функцией arsort(). Поскольку нам важен только новый порядок элементов, сохраним в новом массиве  ключи исходного массива в нужном порядке. Мы сохраняем ключи исходного массива, поскольку они являются именами элементов, из которых конструируется описание документа, а помнить их важно. Итак, получаем такой скрипт:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 print_r($_GET); echo "<br>";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 arsort ($_GET); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // сортируем массив в обратном порядке,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // сохраняя ключи\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 print_r($_GET); echo "<br>";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $ordered_names = array_keys($_GET); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // составляем новый массив\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 foreach($ordered_names as $key => $val)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo "$key :$val <br>"; \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // выводим элементы нового массива\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0          \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Сортировка массива по ключам\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Очевидно, что может возникнуть необходимость в сортировке массива по значениям ключей. Например, если у нас есть массив данных о книгах, как в приведенном выше примере, то вполне вероятно, что мы захотим отсортировать книги по именам авторов. Для этого в PHP также не нужно писать много строк кода – можно просто воспользоваться функцией ksort() для сортировки по возрастанию (прямой порядок сортировки) или krsort() – для сортировки по убыванию (обратный порядок сортировки). Синтаксис этих функций опять же аналогичен синтаксису функции sort().\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $books = array("Пушкин"=>"Руслан и Людмила",\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      "Толстой"=>"Война и мир",\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      "Лермонтов"=>"Герой нашего времени");\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ksort($books); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // сортируем массив, \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // сохраняя значения ключей\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 print_r($books);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Получим:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Array ( [Лермонтов] => Герой нашего времени\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         [Пушкин] => Руслан и Людмила \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         [Толстой] => Война и мир )\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Сортировка с помощью функции, заданной пользователем\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Кроме двух простых способов сортировки значений массива (по убыванию или по возрастанию) PHP предлагает пользователю возможность самому задавать критерии для сортировки данных. Критерий задается с помощью функции, имя которой указывается в качестве аргумента для специальных функций сортировки  usort() или uksort(). По названиям этих функций можно догадаться, что usort()  сортирует  значения элементов массива, а uksort() – значения  ключей  массива с помощью  определенной пользователем функции. Обе функции возвращают true, если сортировка прошла успешно, и false – в противном случае. Их синтаксис выглядит следующим образом:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 usort (массив , сортирующая функция)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 uksort (массив , сортирующая функция)\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Конечно же, нельзя сортировать массив с помощью любой пользовательской функции. Эта функция должна удовлетворять определенным критериям, позволяющим сравнивать элементы массива. Как должна быть устроена сортирующая функция? Во-первых, она должна иметь два аргумента. В них интерпретатор будет передавать пары значений элементов для функции usort() или ключей  массива для функции uksort(). Во-вторых, сортирующая функция должна возвращать:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - целое число, меньшее нуля, если первый аргумент меньше второго;\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - число, равное нулю, если два аргумента равны;\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - число большее нуля, если первый аргумент больше второго.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Как и для других функций сортировки, для функции usort() существует аналог, не изменяющий значения  ключей, – функция uasort().\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Пример 7.10.\b0   Допустим, у нас есть массив, содержащий такие сведения о литературных произведениях, как название, автор и год создания. Мы хотим упорядочить книги по дате создания.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // массив выглядит таким образом:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $books = array("Герой нашего времени" => \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0              array ("Лермонтов", 1840),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   "Руслан и Людмила" => array("Пушкин",1820),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   "Война и мир" => array ("Толстой",1863),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   "Идиот" => array("Достоевский",1868));\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 /* можно, конечно переписать этот массив \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 по-другому, сделав год издания, например, \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 индексом, но гораздо удобнее написать свою \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 функцию для сортировки */\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 uasort($books,"cmp"); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // сортируем массив с помощью функции cmp\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 foreach ($books as $key => $book) \{\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    echo "$book[0]: \\"$key\\"<br>";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 function cmp($a,$b)\{ \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // функция, определяющая способ сортировки\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    if ($a[1] < $b[1]) return -1;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    elseif ($a[1]==$b[1]) return 0;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    else return 1;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В результате получим:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Пушкин: "Руслан и Людмила"\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Лермонтов: "Герой нашего времени"\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Толстой: "Война и мир"\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Достоевский: "Идиот"\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Мы применили нашу собственную функцию сортировки ко всем элементам массива. Далее рассмотрим, как применить к элементам массива любую другую пользовательскую функцию.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Применение функции ко всем элементам массива\b0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Функция array_walk(массив, функция [, данные]) применяет созданную пользователем функцию функция ко всем элементам массива массив и возвращает true в случае успешного выполнения операции и false – в противном случае.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Пользовательская функция, как правило, имеет два аргумента, в которые поочередно передаются значение и ключ каждого элемента массива. Но если при вызове функции array_walk() указан третий аргумент, то он будет рассмотрен как значение третьего аргумента пользовательской функции, смысл которого определяет сам пользователь. Если функция пользователя требует больше аргументов, чем в нее передано, то при каждом вызове array_walk() будет выдаваться предупреждение.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если необходимо работать с реальными значениями  массива, а не с их копиями, следует передавать аргумент в функцию по ссылке. Однако нужно иметь в виду, что нельзя добавлять или удалять элементы массива и производить действия, изменяющие сам массив, поскольку в этом случае результат работы array_walk() считается неопределенным.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $books1 = array(\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   "А.С. Пушкин"=>"Руслан и Людмила",\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   "Л.Н. Толстой"=>"Война и мир",\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   "М.Ю. Лермонтов"=>"Герой нашего времени");\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // создаем функцию, которую хотим \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // применить к элементам массива\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 function try_walk($val,$key,$data)\{\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    echo "$data \\"$val\\" написал $key<br>";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // применяем ко всем элементам массива \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // $book1 функцию try_walk\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 array_walk($books1,"try_walk","Роман");\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В результате работы скрипта получим:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Роман "Руслан и Людмила" написал А.С. Пушкин\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Роман "Война и мир" написал Л.Н. Толстой\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Роман "Герой нашего времени" \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0       написал М.Ю. Лермонтов\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Заметим, что мы не изменили значений у элементов массива. Чтобы их изменить, надо было передавать значения в переменную $val функции try_walk по ссылке.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $books1 = array(\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   "А.С. Пушкин"=>"Руслан и Людмила",\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   "Л.Н. Толстой"=>"Война и мир",\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   "М.Ю. Лермонтов"=>"Герой нашего времени");\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // создаем функцию, которую хотим \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // применить к элементам массива\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 function try_walk(&$val,$key)\{\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    $key = "<p>Автор: " .$key ."<br>";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    $val = "Название: \\"" . $val ."\\"</p>";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    echo $key.$val;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // применяем ко всем элементам массива \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // $book1 функцию try_walk\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 array_walk($books1,"try_walk");\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 print_r($books1);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В результате работы скрипта получим:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Автор: А.С. Пушкин\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Название: "Руслан и Людмила"\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Автор: Л.Н. Толстой\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Название: "Война и мир"\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Автор: М.Ю. Лермонтов\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Название: "Герой нашего времени"\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Array ( [А.С. Пушкин] => \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0             Название: "Руслан и Людмила"\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         [Л.Н. Толстой] => \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0             Название: "Война и мир"\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         [М.Ю. Лермонтов] => \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0             Название: "Герой нашего времени")\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Выделение подмассива\b0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Функция array_slice\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Поскольку массив – это набор элементов, вполне вероятно, потребуется выделить из него какой-нибудь поднабор. В PHP для этих целей есть функция array_slice. Ее синтаксис таков:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 array_slice (массив, \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0              номер_элемента [, длина])\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эта функция выделяет подмассив длины длина в массиве  массив, начиная с элемента, номер которого задан параметром номер_элемента. Положительный номер_элемента указывает на порядковый номер элемента относительно начала массива, отрицательный – на номер элемента с конца массива.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $arr = array(1,2,3,4,5);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $sub_arr = array_slice($arr,2);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 print_r($sub_arr); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 /* \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 выведет Array ( [0] => 3 [1] =>4 [2] => 5 ),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 т.е. подмассив, состоящий из элементов \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 3, 4, 5 */\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $sub_arr = array_slice($arr,-2);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 print_r($sub_arr); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    // выведет Array ( [0] => 4 [1] => 5 ),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    // т.е. подмассив, из элементов 4, 5\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если задать параметр длина при использовании array_slice, то будет выделен подмассив, имеющий ровно столько элементов, сколько задано этим параметром. Длину можно указывать и отрицательную. В этом случае интерпретатор удалит с конца массива число элементов, равное модулю параметра длина.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $arr = array(1,2,3,4,5);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $sub_arr = array_slice($arr, 2, 2); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // содержит массив из элементов 3, 4\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $sub = array_slice($arr,-3, 2);     \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // тоже содержит массив из элементов 3, 4\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $sub1 = array_slice($arr,0, -1);    \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // содержит массив из \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // элементов 1, 2, 3, 4\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $sub2 = array_slice($arr,-4, -2);   \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // содержит массив из элементов 2, 3\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Функция array_chunk\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Есть еще одна функция, похожая на array_slice() – это array_chunk(). Она разбивает массив на несколько подмассивов заданной длины. Синтаксис ее такой:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 array_chunk ( массив, размер \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     [, сохранять_ключи])\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В результате работы array_chunk() возвращает многомерный массив, элементы которого представляют собой полученные подмассивы. Если задать параметр сохранять ключи как true, то при разбиении будут сохранены ключи исходного массива. В противном случае ключи элементов заменяются числовыми индексами, которые начинаются с нуля.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Пример 7.15. \b0  У нас есть список приглашенных, оформленный в виде массива их фамилий. У нас имеются столики на три персоны. Поэтому нужно распределить всех приглашенных по трое.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $persons = array("Иванов", "Петров",\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     "Сидорова","Зайцева", "Волкова");\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $triples = array_chunk($persons,3); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // делим массив на подмассивы \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // по три элемента\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 foreach ($triples as $k => $table)\{ \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // выводим полученные тройки\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   echo "За столиком номер $k сидят: <ul>";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   foreach ($table as $pers) \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      echo "<li>$pers";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   echo "</ul>";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В результате получим:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 за столиком номер 0 сидят:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Иванов\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Петров\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Сидорова\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 за столиком номер 1 сидят:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Зайцева\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Волкова\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Сумма элементов массива\b0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В этом разделе мы познакомимся с функцией, вычисляющей сумму всех элементов массива. Сама задача вычисления суммы значений массива предельно проста. Но зачем писать лишний раз один и тот же код, если можно воспользоваться специально созданной и всегда доступной функцией. Функция эта называется, как можно догадаться, array_sum(). И в качестве параметра ей передается только имя массива, сумму значений элементов которого нужно вычислить.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В качестве примера использования этой функции приведем решение более сложной задачи, чем просто вычисление суммы элементов. Этот пример также иллюстрирует применение функции array_slice(), которую мы обсуждали чуть раньше.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Пример 7.16. \b0  Пусть дан массив натуральных чисел. Нужно найти в нем такое число, что сумма элементов справа от него равна сумме элементов слева от него.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 //массив задается функцией array\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $arr = array(2,1,3,4,5,6,4);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // перебираем каждый элемент массива $arr.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // Внутри цикла текущий ключ массива \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // содержится в переменной $k,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // текущее значение – в переменной $val\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 foreach ($arr as $k => $val)\{\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    $p = $k + 1;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // синтаксис array array_slice (\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0        array array,int offset [,int length])\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // array_slice выделяет подмассив \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // длины length в массиве array, \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // начиная с элемента offset.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    $out_next = array_slice($arr,$p); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    // получаем массив элементов, \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    // идущих после текущего\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    $out_prev = array_slice($arr,0,$k); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    // получаем массив элементов, \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    // идущих перед текущим\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // функция mixed array_sum (array array) \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // подсчитывает сумму элементов массива array\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    $next_sum = array_sum($out_next);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    $prev_sum = array_sum($out_prev);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // если сумма элементов до текущего равна \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // сумме элементов после, то выводим \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // значение текущего элемента\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    if ($next_sum==$prev_sum) \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0        echo "value:$val";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // можно посмотреть, что представляют собой \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // рассмотренные массивы на каждом шаге\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // print_r($out_next); echo "<br>";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // print_r($out_prev);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // echo "$next_sum, $prev_sum<br>"; \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    echo "<hr>";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Заключение\b0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Итак, подведем итоги. В этой лекции мы изучили ряд функций, упрощающих работу с массивами данных. Мы рассмотрели функции для поиска значения среди элементов массива; функции для сортировки элементов массива, как по их значениям, так и по ключам; функции, позволяющие применять ко всем элементам массива функцию, созданную пользователем. Кроме того, мы изучили функцию, выделяющую подмассивы из элементов массива, и функцию, вычисляющую сумму всех элементов массива. Использование всех этих функций было продемонстрировано на примерах. Все функции для работы с массивами доступны без каких-либо конфигурационных настроек PHP,  и пользоваться ими можно абсолютно свободно. Так что, прежде чем изобретать велосипед, загляните в руководство по языку PHP: – вполне возможно, что кто-то сделал это до вас.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Работа со строками\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Строки\b0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Вероятно, читатели примерно представляют, что такое тип данных «строка» и как создать переменную такого типа. В одной из первых лекций мы приводили три способа задания строк: с помощью одинарных кавычек, двойных кавычек и с помощью heredoc–синтаксиса. Отмечали мы и основные различия между этими способами. В основном они касаются обработки переменных и управляющих последовательностей внутри строки.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo 'В такой строке НЕ обрабатываются \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0       переменные и большинство \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0       последовательностей';\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo "Здесь переменные и последовательности\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0       обрабатываются";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo <<<EOT\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Здесь тоже обрабатываются как переменные, \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 так и управляющие последовательности.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 И кроме того, можно вводить символы кавычек\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 без их экранирования обратным слэшем.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 EOT;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Уже не раз, начиная с самой первой лекции, мы использовали функцию echo. На самом деле, echo – не функция, а языковая конструкция, поэтому использовать при ее вызове круглые скобки не обязательно. Echo позволяет выводить на экран строки, переданные ей в качестве параметров. Параметров у echo может быть сколько угодно. Их разделяют запятыми или объединяют с помощью оператора конкатенации и никогда не заключают в круглые скобки.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo "Пришел ", "увидел ", "победил "; \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // выведет строку "Пришел увидел победил"\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // многие предпочитают передавать несколько\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // параметров в echo с помощью конкатенации\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo "Пришел " . "увидел " . "победил "; \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // тоже выведет строку \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // "Пришел увидел победил"\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo ("Пришел ", "увидел ", "победил "); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // выдаст ошибку: unexpected ','\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Существует сокращенный синтаксис для команды echo:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?=строка_для_вывода?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Здесь параметр строка_для вывода содержит строку, заданную любым из известных способов, которая должна быть выведена на экран.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Например, такой скрипт выведет на экран красным цветом "Меня зовут Вася":\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <? $name="Вася" ?>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <font color=red>Меня зовут <?=$name?></font>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Кроме языковой конструкции echo существует ряд функций для вывода строк. Это в первую очередь функция print и ее разновидности printf, sprintf и т.п.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Функция print позволяет выводить на экран только одну строку и, как и echo, не может быть вызвана с помощью переменных функций, поскольку является языковой конструкцией.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Функция print_r не относится к строковым функциям, как можно было бы подумать. Она отображает информацию о переменной в форме, понятной пользователю.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Функции sprintf и printf обрабатывают переданную им строку в соответствии с заданным форматом. Но о них мы говорить не будем. А поговорим о том, как можно осуществлять поиск в тексте, представленном в виде строки.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Поиск элемента в строке\b0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для того чтобы определить, входит ли данная подстрока в состав строки, используется функция strpos(). Синтаксис strpos() такой:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 strpos (исходная строка,строка для поиска \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0        [,с какого символа искать])\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Она возвращает позицию появления искомой строки в исходной строке или возвращает логическое false, если вхождение не найдено. Дополнительный аргумент позволяет задавать символ, начиная с которого будет производиться поиск. Кроме логического false эта функция может возвращать и другие значения, которые приводятся к false (например, 0 или ""). Поэтому для того, чтобы проверить, найдена ли искомая строка, рекомендуют использовать оператор эквивалентности «===».\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $str = "Идея наносить данные на перфокарты\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 и затем считывать и обрабатывать их \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 автоматически принадлежала Джону Биллингсу,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 а ее техническое решение осуществил Герман\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Холлерит. Перфокарта Холлерита оказалась \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 настолько удачной, что без малейших изменений\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 просуществовала до наших дней.";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $pos = strpos($str,"Холлерит");\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 if ($pos !== false) echo "Искомая строка\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    встречена в позиции номер $pos ";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 else echo "Искомая строка не найдена";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 /* заметим, что мы проверяем значение \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $pos на эквивалентность с false. \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Иначе строка, находящаяся в первой позиции,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 не была бы найдена, так как 0\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 интерпретируется как false. */\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если значение параметра строка_для_поиска не является строкой, то оно преобразуется к целому типу и рассматривается как ASCII-код символа. Чтобы получить ASCII-код любого символа в PHP, можно воспользоваться функцией ord("символ")\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Например, если мы напишем $pos = strpos($str,228); то интерпретатор будет считать, что мы ищем символ «д». Если добавить эту строчку в приведенный выше пример и вывести результат, то получим сообщение, что искомая строка найдена в позиции 1.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Функция, обратная по смыслу ord, – это chr (код символа). Она по ASCII-коду выводит символ, соответствующий этому коду.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 С помощью функции strpos можно найти номер только первого появления строки в исходной строке. Естественно, есть функции, которые позволяют вычислить номер последнего появления строки в исходной строке. Это функция strrpos(). Ее синтаксис таков:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 strrpos (исходная строка, символ для поиска)\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В отличие от strpos() эта функция позволяет найти позицию последнего появления в строке указанного символа. Нельзя искать позицию строки, только символа.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Бывают ситуации, когда знать позицию, где находится искомая строка, необязательно, а нужно просто получить все символы, которые расположены после вхождения этой строки. Можно, конечно, воспользоваться и приведенными выше функциями strpos() и strrpos(), но можно сделать и проще – выделить подстроку с помощью предназначенных именно для этого функций.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Выделение подстроки\b0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Функция strstr\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Говоря о выделении подстроки из искомой строки в языке PHP, в первую очередь стоит отметить функцию strstr():\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 strstr (исходная строка, строка для поиска)\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Она находит первое появление искомой строки и возвращает подстроку, начиная с этой искомой строки до конца исходной строки.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если строка для поиска не найдена, то функция вернет false. Если строка для поиска не принадлежит строковому типу данных, то она переводится в целое число и рассматривается как код символа. Кроме того, эта функция чувствительна к регистру, т.е. если мы будем параллельно искать вхождения слов «Идея» и «идея», то результаты будут разными. Вместо strstr() можно использовать абсолютно идентичную ей функцию strchr().\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Пример 8.4.\b0   Выделим из строки, содержащей название и автора исследования, подстроку, начинающуюся со слова «Название»:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $str = "Автор: Иванов Иван (<a\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 href=mailto:van@mail.ru>написать письмо</a>),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    Название: 'Исследование языков \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0               программирования' ";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo "<b>Исходная строка: </b>",$str;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 if (!strstr($str, "Название")) \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    echo "Строка не найдена<br>";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 else echo "<p><b>Полученная подстрока: </b>",\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    strstr($str, "Название");\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В результате получим:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Исходная строка: Автор: Иванов Иван \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    (написать письмо),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    Название: 'Исследование языков \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0               программирования'\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Полученная подстрока: Название: \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    'Исследование языков программирования'\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для реализации регистронезависимого поиска подстроки существует соответствующий аналог этой функции – функция stristr (исходная строка, искомая строка). Действует и используется она точно так же, как и strstr(), за исключением того, что регистр, в котором записаны символы искомой строки, не играет роли при поиске.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Очевидно, что функция strstr() не слишком часто используется – на практике редко бывает нужно получить подстроку, начинающуюся с определенного слова или строки. Но в некоторых случаях и она может пригодиться. Кроме того, в PHP есть и более удобные функции для поиска вхождений. Наиболее мощные из них, конечно, связаны с регулярными выражениями. Их мы рассмотрим в одной из последующих лекций.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Функция substr\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Иногда мы не знаем, с каких символов начинается искомая строка, но знаем, например, что начинается она с пятого символа и заканчивается за два символа до конца исходной строки. Как выделить подстроку по такому описанию? Очень просто, с помощью функции substr(). Ее синтаксис можно записать следующим образом:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 substr (исходная строка, \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     позиция начального символа [, длина])\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эта функция возвращает часть строки длиной, заданной параметром длина, начиная с символа, указанного параметром позиция начального символа. Позиция, с которой начинается выделяемая подстрока, может быть как положительным целым числом, так и отрицательным. В последнем случае отсчет элементов производится с конца строки. Если параметр длина опущен, то substr() возвращает подстроку от указанного символа и до конца исходной строки. Длина выделяемой подстроки тоже может быть задана отрицательным числом. Это означает, что указанное число символов отбрасывается с конца строки.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Пример 8.5.\b0   Допустим, у нас есть фраза, выделенная жирным шрифтом с помощью тега <b> языка HTML. Мы хотим получить эту же фразу, но в обычном стиле. Напишем такую программу:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $word = "<b>Hello, world!</b>";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo $word , "<br>";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $pure_str = substr($word, 3, -4); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 /* выделяем подстроку, \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    начиная с 3-го символа, \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    не включая 4 символа с конца строки */\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo $pure_str;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В результате работы этого скрипта получим:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Hello, world!\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Hello, world!\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 На самом деле решить такую задачу можно гораздо проще, с помощью функции strip_tags:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 strip_tags (строка [, допустимые теги])\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эта функция возвращает строку, из которой удалены все html и php-теги. С помощью дополнительного аргумента можно задать теги, которые не будут удалены из строки. Список из нескольких тегов вводится без каких-либо знаков разделителей. Функция выдает предупреждение, если встречает неправильные или неполные теги.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $string = "<b>Bold text</b> \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0            <i>Italic text</i>";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $str = strip_tags($string); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    // удаляем все теги из строки\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $str1 = strip_tags($string, '<i>'); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    // удаляем все теги кроме тега <i>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $str2 = strip_tags($string, '<i><b>'); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    // удаляем все теги кроме тегов <i> и <b>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo $str,"<br>",$str1,"<br>", $str2;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В результате получим:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Bold text Italic text\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Bold text Italic text\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Bold text Italic text\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Приведем другой пример использования функции substr(). Допустим, у нас есть какое-то сообщение с приветствием и подписью автора. Мы хотим удалить сначала приветствие, а потом и подпись, оставив только содержательную часть сообщения.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $text = "Привет! Сегодня мы изучаем работу\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0          со строками. Автор.";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $no_hello = substr($text, 8); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // убираем приветствие\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $content = substr($text, 8, 39);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // то же самое, что substr($text, 8, -6).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // Убираем подпись.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo $text, "<br>", $no_hello, \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      "<br>", $content;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В результате получим:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Привет! Сегодня мы изучаем работу \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         со строками. Автор.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Сегодня мы изучаем работу со строками. Автор.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Сегодня мы изучаем работу со строками.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если нам нужно получить один конкретный символ из строки, зная его порядковый номер, то не следует задействовать функции типа substr. Можно воспользоваться более простым синтаксисом – записывая номер символа в фигурных скобках после имени строковой переменной. В контексте предыдущего примера букву «р», расположенную второй по счету, можно получить так:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo $text\{1\}; // выведет символ "р"\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Заметим, что номером этого символа является число один, а не два, так как нумерация символов строки производится начиная с нуля.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Раз уж мы начали говорить о символах в строке и их нумерации, то невольно возникает вопрос, сколько всего символов в строке и как это вычислить. Число символов в строке – это длина строки. Вычислить длину строки можно с помощью функции strlen (строка). Например, длина строки «Разработка информационной модели» вычисляется с помощью команды: strlen("Разработка информационной модели"); и равна 32 символам.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Итак, как выделять и находить подстроки, мы рассмотрели. Теперь научимся заменять строку, входящую в состав исходной строки, на другую строку по нашему выбору.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Замена вхождения подстроки\b0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Функция str_replace\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для замены вхождения подстроки можно использовать функцию str_replace(). Это простая и удобная функция, позволяющая решать множество задач, не требующих особых тонкостей при выборе заменяемой подстроки. Для того чтобы производить замены с более сложными условиями, используют механизм регулярных выражений и соответствующие функции ereg_replace() и preg_replace(). Синтаксис функции str_replace() такой:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 str_replace(искомое значение, \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     значение для замены, объект)\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Функция str_replace() ищет в рассматриваемом объекте значение и заменяет его значением, предназначенным для замены. Почему мы говорим здесь не про строки для поиска и замены и исходную строку, а про значения и объект, в котором происходит замена? Дело в том, что начиная с PHP 4.0.5 любой аргумент этой функции может быть массивом.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если объект, в котором производится поиск и замена, является массивом, то эти действия выполняются для каждого элемента массива и в результате возвращается новый массив.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $greeting = array("Привет", "Привет всем!",\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    "Привет, дорогая!"); // объект\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $new_greet = str_replace("Привет", \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    "Доброе утро", $greeting); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    // делаем замену\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 print_r($new_greet);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 /* получим: Array ([0]=>Доброе утро \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    [1]=>Доброе утро всем!\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    [2]=>Доброе утро, дорогая!) */\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если искомое значение и значение для замены – массивы, то берется по одному значению из каждого массива и производится их поиск и замена в объекте. Если значений для замены меньше, чем значений для поиска, то в качестве новых значений используется пустая строка.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $greeting = array("Привет", "Привет всем!",\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    "Привет, дорогая!","Здравствуйте", \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    "Здравствуйте, товарищи", "Hi"); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    // объект\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $search = array ("Привет",\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    "Здравствуйте", "Hi"); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    // значения, которые будем заменять\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $replace = array ("Доброе утро",\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    "День добрый"); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    // значения, которыми будем заменять\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $new_greet = str_replace($search, $replace,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                          $greeting);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    // делаем замену\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 print_r($new_greet); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    //выводим полученный массив\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В результате получим такой массив:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Array (\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 [0] => Доброе утро\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 [1] => Доброе утро всем!\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 [2] => Доброе утро, дорогая!\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 [3] => День добрый\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 [4] => День добрый, товарищи\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 [5] =>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 )\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если значения для поиска – массив, а значение для замены – строка, то эта строка будет использована для замены всех найденных значений.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $greeting = array("Привет", "Привет всем!",\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    "Привет, дорогая!", "Здравствуйте",\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    "Здравствуйте, товарищи"); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    // объект\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $search = array ("Привет","Здравствуйте"); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    // значения, которые будем заменять\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $replace = "День добрый"; \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    // значение, которым будем заменять\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $new_greet = str_replace($search, \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    $replace, $greeting);  // делаем замену\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 print_r($new_greet); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    //выводим полученный массив\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Получим:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Array (\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 [0] => День добрый\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 [1] => День добрый всем!\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 [2] => День добрый, дорогая!\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 [3] => День добрый\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 [4] => День добрый, товарищи\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 )\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Функция str_replace() чувствительна к регистру, но существует ее регистронезависимый аналог – функция str_ireplace(). Однако эта функция поддерживается не во всех версиях PHP.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Еще один пример использования функции str_replace() – обработка шаблонов.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Обратимся в очередной раз к описанию какого-либо документа, например статьи. Много раз мы уже создавали форму для ввода подобного описания и даже отображали данные, введенные пользователем в такого рода форму. Но как отображать эти данные, мы описывали непосредственно в коде нашей программы. Теперь мы хотим, чтобы способ отображения данных задавал сам пользователь. Для этого добавим в нашу форму еще один элемент для ввода шаблона.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <h2>Введите описание статьи</h2>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <form action=sbl.php>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <table border=0>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <tr><td>Название </td><td><input \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   type=text name=title > </td></tr>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <tr><td>Краткое содержание </td><td><input \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   type=text name=description > </td></tr>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <tr><td>Автор </td><td><input \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   type=text name=author > </td></tr>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <tr><td>Дата публикации </td><td><input \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   type=text name=published ></td></tr>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <tr><td>Шаблон документа </td><td><textarea\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   name=shablon ></textarea></td></tr>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 </table>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <input type=submit value="Отправить">\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 </form>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Однако просто поля для ввода шаблона недостаточно. Один человек введет в него одно, другой – другое. Нужно договориться о том, как создавать шаблоны, что можно в них использовать, т.е. нужно придумать язык шаблонов. Например, мы договариваемся, что при создании шаблона можно задействовать любые html-теги, а набор спецсимволов вида <!имя_элемента> определяет значение элемента с именем имя_элемента. Далее, как обрабатывать такого рода шаблоны? Можно использовать функцию str_replace():\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $tmpl = $_GET["shablon"]; \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 /* шаблон, введенный пользователем. \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Например, это может быть такая строка:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 "<h1><!title></h1> <p><font \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 size=-1><!description></font></p><p \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 align=right><!author><br><!published></p>" */\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 function Show()\{ \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   // функция, которая производит замену\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   // элемента шаблона на его значение\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 global $tmpl;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 foreach($_GET as $k => $v) \{\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    $tmpl = str_replace("<!$k>",$v,$tmpl);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo $tmpl;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Show();\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Как эти файлы выглядят для обычного пользователя? Если мы введем в форму такие данные как показано на рисунке 8.1, то в результате получим:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Первая машина для переписи населения\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Идея наносить данные на перфокарты и затем\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 считывать и обрабатывать их автоматически \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 принадлежала Джону Биллингсу, а ее \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 техническое решение осуществил Герман\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Холлерит. Перфокарта Холлерита оказалась \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 настолько удачной, что без малейших изменений\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 просуществовала до наших дней.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                                 А. М. Федотов\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                                      12.02.03\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      \par
\par
\qc\par\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 \b Рис. 8.1.\b0            Форма для ввода описания документа «статья»    и шаблона для его отображения\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Функция substr_replace\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эта функция сочетает в себе свойства двух уже рассмотренных нами функций – функции str_replace() и substr(). Ее синтаксис таков:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 substr_replace (исходная строка, \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     строка для замены, \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     позиция начального символа [, длина])\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эта функция заменяет часть строки строкой, предназначенной для замены. Заменяется та часть строки (т.е. подстрока), которая начинается с позиции, указанной параметром позиция начального символа. С помощью дополнительного аргумента длина можно ограничить число заменяемых символов. То есть, фактически, мы не указываем конкретно строку, которую нужно заменить, мы только описываем, где она находится и, возможно, какую длину имеет. В этом отличие функции substr_replace() от str_replace().\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Как и в случае с функцией substr() аргументы позиция начального символа и длина могут быть отрицательными. Если позиция начального символа отрицательна, то замена производится, начиная с этой позиции относительно конца строки. Отрицательная длина задает, сколько символов от конца строки не должно быть заменено. Если длина не указывается, то замена происходит до конца строки.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $text = "Меня зовут Вася.";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo "Исходная строка: $text<hr>\\n";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 /* Следующие две строки заменят всю \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 исходную строку строкой 'А меня – Петя' */\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo substr_replace($text, 'А меня – Петя',\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      0) . "<br>\\n";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo substr_replace($text, 'А меня – Петя',\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      0, strlen($text)) . "<br>\\n";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // Следующая строка добавит слово 'Привет! '\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // в начало исходной строки\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo substr_replace($text, 'Привет! ',\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      0, 0) . "<br>\\n";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // Следующие две строки заменят имя Вася\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // на имя Иван в исходной строке\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo substr_replace($text, 'Иван', 11,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     -1) . "<br>\\n";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo substr_replace($text, 'Иван', -5,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     -1) . "<br>\\n";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В результате работы этого скрипта получим:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Исходная строка: Меня зовут Вася.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ------------------------------------------\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 А меня – Петя\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 А меня – Петя\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Привет! Меня зовут Вася.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Меня зовут Иван.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Меня зовут Иван.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Разделение и соединение строки\b0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Очень полезные функции – функция разделения строки на части и обратная ей функция объединения строк в одну строку. Почему очень полезные? Например, если вы динамически генерируете форму по желанию пользователя, можно предложить ему вводить элементы для создания списка выбора, разделяя их каким-нибудь символом. И для того чтобы обработать полученный список значений, как раз и пригодится умение разбивать строку на кусочки. Для реализации такого разбиения в PHP можно использовать несколько функций:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 explode(разделитель,исходная строка \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     [,максимальное число элементов])\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 split (шаблон, исходная строка \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     [, максимальное число элементов])\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 preg_split (шаблон, исходная строка \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     [, максимальное число элементов \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     [,флаги]])\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Последние две функции работают с регулярными выражениями, поэтому в данной лекции мы их рассматривать не будем. Рассмотрим более простую функцию – explode().\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Функция explode()  делит исходную строку на подстроки, каждая из которых отделена от соседней с помощью указанного разделителя, и возвращает массив полученных строк. Если задан дополнительный параметр максимальное число элементов, то число элементов в массиве будет не больше этого параметра, в последний элемент записывается весь остаток строки. Если в качестве разделителя указана пустая строка «""», то функция explode() вернет false. Если символа разделителя в исходной строке нет, то возвращается исходная строка без изменений.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Пример 8.11.\b0   мы хотим создать элемент формы – выпадающий список и значения для этого списка должен ввести пользователь, не знакомый с языком html. Создадим такую форму:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <form action=exp.php>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    Введите варианты для выбора автора статьи\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0       через двоеточие (":"):<br>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    <input type=text name=author size=40>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    <br>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    <input type=submit value=Создать элемент>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 </form>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Скрипт, который будет ее обрабатывать (exp.php), может быть таким:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $str = $_GET["author"];\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $names = explode(":",$str); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // разбиваем строку введенную,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // пользователем с помощью ":"\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $s = "<select name=author>"; \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // создаем выпадающий список\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 foreach ($names as $k => $name) \{\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    $s .= "<option value=$k>$name"; \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // добавляем элементы к списку\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $s .= "</select>";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo $s;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В итоге, если мы введем такую строчку в форму:\par
\par
\qc\par\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 \b Рис. 8.2.\b0            Ввод значений для создания выпадающего списка\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 то получим следующий выпадающий список:\par
\par
\qc\par\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 \b Рис. 8.3.\b0            Выпадающий список, полученный       в результате обработки формы\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Кроме разделения строки на части иногда, наоборот, возникает необходимость объединения нескольких строк в одно целое. Функция, предлагаемая для этого языком PHP, называется implode():\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 implode (массив строк, объединяющий элемент)\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эта функция объединяет элементы массива с помощью переданного ей объединяющего элемента (например, запятой). В отличие от функции explode(), порядок аргументов в функции implode() не имеет значения.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Пример 8.12.\b0   Допустим, мы храним имя, фамилию и отчество человека по отдельности, а выводить их на странице нужно вместе. Чтобы соединить их в одну строку, можно использовать функцию implode():\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $data = array("Иванов","Иван","Иванович");\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $str = implode($data," ");\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo $str;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В результате работы этого скрипта получим  строку:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Иванов Иван Иванович\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 У функции implode() существует псевдоним – функция join(), т.е. эти две функции отличаются лишь именами.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Строки, содержащие html-код\b0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Достаточно часто мы работаем со  строками, содержащими html-теги. Если отобразить такую  строку в браузер с помощью обычных функций отображения данных echo() или print(), то мы не увидим самих html-тегов, а получим отформатированную в соответствии с этими тегами  строку. Браузер обрабатывает все html-теги в соответствии со стандартом языка HTML. Иногда нам нужно видеть непосредственно  строку, без обработки ее браузером. Чтобы этого добиться, нужно перед тем, как выводить, применить к ней функцию htmlspecialchars().\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Функция htmlspecialchars (строка [, стиль кавычек [, кодировка]]) переводит специальные символы, такие как «<», «>», «&», «"» , «'» в такие сущности языка HTML, как «&lt;», «&gt;», «&amp;», «&quot;», «&#039;» соответственно.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Дополнительный аргумент стиль кавычек определяет, как должны интерпретироваться двойные и одинарные кавычки. Он может иметь одно из трех значений: ENT_COMPAT, ENT_QUOTES, ENT_NOQUOTES. Константа ENT_COMPAT означает, что двойные кавычки должны быть переведены в спецсимволы, а одинарные должны остаться без изменений. ENT_QUOTES говорит, что должны конвертироваться и двойные и одинарные кавычки, а ENT_NOQUOTES оставляет и те и другие кавычки без изменений.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В параметре кодировка могут быть заданы такие кодировки, как UTF-8, ISO-8859-1 и другие, но ни одна русская кодировка здесь не поддерживается.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $new = htmlspecialchars("<a \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     href='mailto:au@mail.ru'>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     Написать письмо</a>", ENT_QUOTES);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo $new; \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 / * наша строка перекодируется в такую:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 &lt;a href=&#039;mailto:au@mail.ru&#039;&gt;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Написать письмо&lt;/a&gt; */\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В браузере мы увидим:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <a href='mailto:au@mail.ru'>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Написать письмо</a>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Функция htmlspecialchars() перекодирует только наиболее часто используемые спецсимволы. Если необходимо конвертировать все символы в сущности HTML, следует задействовать функцию htmlentities(). Русские буквы при использовании этой функции тоже кодируются специальными последовательностями. Например, буква «А» заменяется комбинацией «&Agrave;». Ее синтаксис и принцип действия аналогичен синтаксису и принципу действия htmlspecialchars().\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Заключение\b0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Итак, мы завершили знакомство с функциями работы со  строками языка PHP. Конечно же, мы затронули далеко не все существующие функции, а лишь малую часть. Мы изучили функции, позволяющие найти набор символов в строке, функции, заменяющие все вхождения одной  строки на другую, функции разделения строки на части и соединения нескольких строк в одну, а также рассмотрели функции, позволяющие выводить на экран строки, содержащие html–код без их форматирования браузером.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Работа с файловой системой\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Создание файла\b0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Функция fopen\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Вообще говоря, в PHP не существует функции, предназначенной именно для создания файлов . Большинство функций работают с уже существующими файлами в файловой системе сервера. Есть несколько функций, которые позволяют создавать временные файлы, или, что то же самое, файлы с уникальным для текущей директории именем. А вот для того, чтобы создать самый обычный файл, нужно воспользоваться функцией, которая открывает локальный или удаленный файл. Называется эта функция fopen(). Что значит «открывает файл»? Это значит, что fopen связывает данный файл с потоком управления программы. Причем связывание бывает различным в зависимости от того, что мы хотим делать с этим файлом: читать его, записывать  в него данные или делать и то и другое. Синтаксис этой функции такой:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 resource fopen ( имя_файла, тип_доступа \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     [, use_include_path])\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В результате работы эта функция возвращает указатель (типа ресурс) на открытый ею файл. В качестве параметров этой функции передаются: имя файла, который нужно открыть, тип доступа к файлу  (определяется тем, что мы собираемся делать с ним) и, возможно, параметр, определяющий, искать ли указанный файл в include_path. Есть еще один опциональный параметр, но о нем мы говорить не будем, дабы не усложнять изложение. Обсудим подробнее каждый из этих трех параметров.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Параметр имя_файла должен быть строкой, содержащей правильное локальное имя файла или URL-адрес файла в сети. Если имя файла начинается с указания протокола доступа (например, http://... или ftp://...), то интерпретатор считает это имя адресом URL и ищет обработчик указанного в URL протокола. Если обработчик найден, то PHP проверяет, разрешено ли работать с объектами URL как с обычными файлами (директива allow_url_fopen ). Если allow_url_fopen=off, то функция  fopen вызывает ошибку и генерируется предупреждение. Если имя файла не начинается с протокола, то считается, что указано имя локального файла. Чтобы открыть локальный файл, нужно, чтобы PHP имел соответствующие права доступа к этому файлу.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Параметр use_include_path, установленный в значение 1 или TRUE, заставляет интерпретатор искать указанный в fopen() файл в include_path. Напомним, что include_path - это директива из файла настроек PHP, задающая список директорий, в которых могут находиться файлы для включения. Кроме функции fopen() она используется функциями include() и require().\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Параметр тип_доступа может принимать одно из следующих значений (см. таб. 9.1).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Итак, чтобы создать файл, нужно, как бы нелепо это ни звучало, открыть несуществующий файл на запись.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $h = fopen("my_file.html","w"); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 /* открывает на запись файл my_file.html,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 если он существует, или создает пустой \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 файл с таким именем, если его еще нет */\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $h = fopen("dir/another_file.txt","w+"); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 /* открывает на запись и чтение или создает\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 файл another_file.txt в директории dir */\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $h = fopen(\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   "http://www.server.ru/dir/file.php","r");\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 /* открывает на чтение файл, находящийся по \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 указанному адресу*/\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Создавая файл, нужно учитывать, под какой операционной системой вы работаете, и под какой ОС предположительно этот файл будет читаться. Дело в том, что разные операционные системы по-разному отмечают конец строки. В Unix-подобных ОС конец строки обозначается \\n, в системах типа Windows - \\r\\n. Windows предлагает специальный флаг t для перевода символов конца строки систем типа Unix в свои символы конца строки. В противоположность этому существует флаг b, используемый чаще всего для бинарных файлов, благодаря которому такой трансляции не происходит. Использовать эти флаги можно, просто дописав их после последнего символа выбранного типа доступа к файлу . Например, открывая файл на чтение, вместо r следует использовать rt, чтобы перекодировать все символы конца строки в \\r\\n. Если не использовать флаг b при открытии бинарных файлов, то могут появляться ошибки,  связанные с изменением содержимого файла. Из соображений переносимости программы на различные платформы рекомендуется всегда использовать флаг b при открытии файлов с помощью fopen().\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 r\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Открывает файл только для чтения; устанавливает указатель позиции в файле на начало файла.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 r+\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Открывает файл для чтения и записи; устанавливает указатель файла на его начало.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 w\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Открывает файл только для записи; устанавливает указатель файла на его начало и усекает файл до нулевой длины. Если файл не существует, то пытается создать его.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 w+\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Открывает файл для чтения и записи; устанавливает указатель файла на его начало и усекает файл до нулевой длины. Если файл не существует, то пытается создать его.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 a\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Открывает файл только для записи; устанавливает указатель файла в его конец. Если файл не существует, то пытается создать его.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 a+\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Открывает файл для чтения и записи; устанавливает указатель файла в его конец. Если файл не существует, то пытается создать его.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 x\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Создает и открывает файл только для записи; помещает указатель файла на его начало. Если файл уже существует, то fopen() возвращает false и генерируется предупреждение. Если файл не существует, то делается попытка создать его.  Этот тип доступа поддерживается начиная с версии PHP 4.3.2 и работает только с локальными файлами.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 x+\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Создает и открывает файл для чтения и записи; помещает указатель файла на его начало. Если файл уже существует, то fopen() возвращает false и генерируется  предупреждение. Если файл не существует, то делается  попытка создать его. Этот тип доступа поддерживается,  начиная с версии PHP 4.3.2, и работает только с локальными файлами.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Что происходит, если открыть или создать файл с помощью fopen не удается? В этом случае PHP генерирует предупреждение, а функция fopen возвращает как результат своей работы значение false. Такого рода предупреждения можно «подавить» (запретить) с помощью символа @ .\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Например, такая команда не выведет предупреждения, даже если открыть файл не удалось:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $h = @fopen("dir/another_file.txt","w+");\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Таким образом, функция fopen() позволяет создать только лишь пустой файл и сделать его доступным для записи. Как же  записать данные в этот файл? Как прочитать данные из уже существующего файла?\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Прежде чем ответить на эти вопросы, рассмотрим, как закрыть  установленное с помощью fopen() соединение.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Закрытие соединения с файлом\b0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 После выполнения необходимых действий с файлом, будь то чтение или запись данных или что-либо другое, соединение, установленное с этим файлом функцией fopen(), нужно закрыть . Для этого используют функцию fclose(). Синтаксис у нее следующий:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 fclose (указатель на файл)\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эта функция возвращает TRUE, если соединение успешно закрыто, и FALSE - в противном случае. Параметр этой функции должен указывать на файл, успешно открытый, например, с помощью функции fopen().\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $h = fopen("my_file.html","w");\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 fclose($h);\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Конечно, если не закрывать соединение с файлом, никаких ошибок выполнения скрипта не произойдет. Но в целом для сервера это может иметь серьезные последствия. Например, хакер может воспользоваться открытым соединением и записать в файл вирус, не говоря уже о лишней трате ресурсов сервера. Так что советуем всегда закрывать соединение с файлом после выполнения необходимых действий.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Запись данных в файл\b0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Функция fwrite\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для того чтобы записать данные в файл, доступ к которому открыт функцией fopen(), можно использовать функцию fwrite(). Синтаксис у нее следующий:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 int fwrite ( указатель на файл, \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0              строка [, длина])\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эта функция записывает содержимое строки в файл, на который указывает указатель на файл. Если указан дополнительный аргумент длина, то запись заканчивается после того, как записано количество символов, равное значению этого аргумента, или когда будет достигнут конец строки.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В результате своей работы функция fwrite() возвращает число записанных байтов или false, в случае ошибки.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Пример 9.3.\b0   Пусть в нашей рабочей директории нет файла my_file.html. Создадим его и запишем в него строку текста:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $h = fopen("my_file.html","w");\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $text = "Этот текст запишем в файл.";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 if (fwrite($h,$text)) \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   echo "Запись прошла успешно";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 else \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   echo "Произошла ошибка при записи данных";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 fclose($h);\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В результате работы этого скрипта в браузере мы увидим сообщение о том, что запись прошла успешно, а в файле my_file.html появится строка "Этот текст запишем в файл.". Если бы этот файл существовал до того, как мы выполнили этот скрипт, все находящиеся в нем данные были бы удалены.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если же мы напишем такой скрипт:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $h = fopen("my_file.html","a"); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $add_text = "Добавим текст в файл.";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 if(fwrite($h,$add_text,7)) \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   echo "Добавление текста прошло \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     успешно<br>";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 else echo "Произошла ошибка при \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    добавлении данных<br>";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 fclose($h);\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 то к строке, уже существующей в файле my_file.html, добавится еще семь символов из строки, содержащейся в переменной $add_text, т.е. слово «Добавим»\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Функция fwrite() имеет псевдоним fputs(), используемый таким же образом, что и сама функция.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Далее мы рассмотрим, какие методы чтения данных из файла предлагает язык PHP.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Чтение данных из файла\b0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если мы хотим прочитать данные из существующего файла, одной функции fopen(), как и в случае с записью данных, недостаточно. Она лишь возвращает указатель на открытый файл, но не считывает  ни одной строки из этого файла. Поэтому для того, чтобы прочитать данные из файла, нужно воспользоваться одной из специальных функций: file, readfile, file_get_contents,  fread, fgets и т.п.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Функция fread\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эта функция осуществляет чтение данных из файла. Ее можно использовать и для чтения данных из бинарных файлов, не опасаясь их повреждения. Синтаксис fread() такой:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 string fread (указатель на файл, длина)\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 При вызове этой функции происходит чтение данных длины (в байтах), определенной параметром длина, из файла, на который указывает указатель на файл. Параметр указатель на файл должен быть реально существующей переменной типа ресурс, содержащей в себе связь с файлом, открытую, например, с помощью функции fopen(). Чтение данных происходит до тех пор, пока не встретится конец файла или пока не будет прочитано указанное параметром длина число байтов.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В результате работы функция fread() возвращает строку со считанной из файла информацией.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Как вы заметили, в этой функции параметр длина - обязательный. Следовательно, если мы хотим считать весь файл в строку, нужно знать его длину. PHP может самостоятельно вычислить длину указанного файла. Для этого нужно воспользоваться функцией filesize(имя файла). В случае ошибки эта функция вернет false. К сожалению, ее можно использовать только для получения размера локальных файлов.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Пример 9.4.\b0   Прочитаем содержимое файла my_file.html\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $h = fopen("my_file.html","r+");    \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // отрываем файл на запись и чтение\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $content = fread($h, \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      filesize("my_file.html"));\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // считываем содержимое файла в строку\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 fclose($h); // закрываем соединение с файлом\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo $content; \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // выводим содержимое файла \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // на экран браузера\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для того чтобы считать содержимое бинарного файла, например изображения, в таких системах, как Windows, рекомендуется открывать файл с помощью флага rb или ему подобных, содержащих символ b в конце.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Функция filesize() кэширует результаты своей работы. Если изменить содержимое файла my_file.html и снова запустить приведенный выше скрипт, то результат его работы не изменится. Более того, если запустить скрипт, считывающий данные из этого файла с помощью другой функции (например, fgetss), то результат может оказаться таким, как если бы файл не изменился. Чтобы этого избежать, нужно очистить статический кэш, добавив в код программы команду clearstatcache();\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Функция fgets\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 С помощью функции fgets() можно считать из файла строку текста. Синтаксис этой функции практически такой же, как и у fread(), за исключением того, что длину считываемой строки указывать необязательно:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 string fgets ( указатель на файл [, длина])\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В результате работы функция fgets() возвращает строку длиной (длина-1) байт из файла, на который указывает указатель на файл. Чтение заканчивается, если прочитано (длина-1) символов и встретился символ перевода строки или конец файла. Напомним, что в PHP один символ - это один байт. Если длина считываемой строки не указана (данная возможность появилась начиная с PHP 4.2.0), то считывается 1 Кбайт (1024 байт) текста или, что то же самое, 1024 символа. Начиная с версии PHP 4.3, если параметр длина не задан, считывается строка целиком. В случае ошибки функция fgets() возвращает false. Для версий PHP начиная с 4.3 эта функция безопасна для двоичных файлов.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $h = fopen("my_file.html","r+"); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $content = fgets($h,2); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // считает первый символ из \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // первой строки файла my_file.html\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 fclose($h);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo $content;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Обе функции, fread() и fgets(), прекращают считывание данных из файла, если встречают конец файла. В PHP есть специальная функция, проверяющая, смотрит ли указатель позиции файла на конец файла. Это булева функция feof(), в качестве параметра которой передается указатель на соединение с файлом.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Например, вот так можно считать все строки файла my_file.html:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $h = fopen("my_file.html","r"); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 while (!feof ($h)) \{\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     $content = fgets($h);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     echo $content,"<br>";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 fclose($h);\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Функция fgetss\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Существует разновидность функции fgets() - функция fgetss(). Она тоже позволяет считывать строку из указанного файла, но при этом удаляет из него все встретившиеся html-теги, за исключением, быть может, некоторых. Синтаксис fgetss() такой:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 string fgetss(указатель на файл, \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    длина [, допустимые теги])\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Обратите внимание, что здесь аргумент длина обязательный.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Пример 9.6.\b0   Пусть у нас имеется файл my_file.html следующего содержания:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <h1>Без труда не вынешь и рыбку из пруда.</h1>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <b>Тише едешь - дальше будешь</b>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 У семи нянек<i> дитя без глазу</i>.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Выведем на экран все строки файла my_file.html, удалив из них все теги, кроме <b> и <i>:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $h = fopen("my_file.html","r");\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 while (!feof ($h)) \{\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     $content = fgetss($h,1024,'<b><i>');\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    echo $content,"<br>";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 fclose($h);\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В результате работы этого скрипта получим:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Без труда не вынешь и рыбку из пруда.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Тише едешь - дальше будешь \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 У семи нянек дитя без глазу.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Функция fgetc\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Естественно, если можно считывать информацию из файла построчно, то можно считывать  ее и посимвольно. Для этого предназначена функция fgetc(). Легко догадаться, что синтаксис у нее следующий:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 string fgetc ( указатель на файл )\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эта функция возвращает символ из файла, на который ссылается указатель на файл, и значение, вычисляемое как FALSE, если встречен конец строки.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Вот так, например, можно считать файл по одному символу:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $h = fopen("my_file.html","r"); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 while (!feof ($h)) \{\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     $content = fgetc($h);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     echo $content,"<br>";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 fclose($h);\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 На самом деле для того чтобы прочитать содержимое файла, открывать соединение с ним посредством функции fopen() совсем не обязательно. В PHP есть функции, которые позволяют делать это, используя лишь имя файла. Это функции readfile( ), file( ) и file_get_contents( ). Рассмотрим каждую их них подробнее.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Функция readfile\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Синтаксис:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 int readfile ( имя_файла \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     [, use_include_path])\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Функция readfile() считывает файл, имя которого передано ей в качестве параметра имя_файла, и выводит его содержимое на экран. Если дополнительный аргумент use_include_path имеет значение TRUE, то поиск файла с заданным именем производится и по директориям, входящим в include_path.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В программу эта функция возвращает число считанных байтов (символов) файла, а в случае ошибки - FALSE. Сообщения об ошибке в этой функции можно подавить оператором @ .\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Пример 9.7.\b0   Следующий скрипт выведет на экран содержимое файла my_file1.html и размер этого файла, если он существует. В противном случае выведется наше сообщение об ошибке - строка "Error in readfile".\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $n = @readfile ("my_file1.html"); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 /* выводит на экран содержимое файла и \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 записывает его размер в переменную $n */\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 if (!$n) echo "Error in readfile"; \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 /* если функция readfile() выполнилась \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 с ошибкой, то $n=false и выводим \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 сообщение об ошибке */\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 else echo $n;   \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   // если ошибки не было, то выводим число\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   // считанных символов\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 С помощью функции readfile() можно читать содержимое удаленных файлов, указывая их URL-адрес в качестве имени файла, если эта опция не отключена в настройках сервера.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Сразу же выводить содержимое файла на экран не всегда удобно. Порой нужно записать информацию из файла в переменную, чтобы в дальнейшем произвести с ней какие-либо действия. Для этого можно использовать функцию file() или file_get_contents().\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Функция file\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Функция file() предназначена для считывания информации из файла в переменную типа массив. Синтаксис у нее такой же, как и у функции readfile(), за исключением того, что в результате работы она возвращает массив:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 array file ( имя_файла \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     [, use_include_path])\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Что за массив возвращает эта функция? Каждый элемент данного массива является строкой в файле, информацию из которого мы считываем (его имя задано аргументом имя_файла). Символ новой строки тоже включается в каждый из элементов массива. В случае ошибки функция file(), как и все уже рассмотренные, возвращает false. Дополнительный аргумент use_include_path опять же определяет, искать или нет данный файл в директориях include_path. Открывать удаленные файлы с помощью этой функции тоже можно, если не запрещено сервером. Начиная с PHP 4.3 работа с бинарными файлами посредством этой функции стала безопасной.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Например, у нас имеется файл my_file.html следующего содержания:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <h1>Без труда не вынешь \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     и рыбку из пруда.</h1>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <b>Тише едешь - дальше будешь</b>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Прочитаем его содержимое с помощью функции file():\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $arr = file ("my_file.html"); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 foreach($arr as $i => $a) echo $i,": ", \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     htmlspecialchars($a), "<br>";\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В результате на экран будет выведено следующее сообщение:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 0: <h1>Без труда не вынешь \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     и рыбку из пруда.</h1>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 1: <b>Тише едешь - дальше будешь</b>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Функция file_get_contents\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В версиях PHP начиная с 4.3 появилась возможность считывать содержимое файла в строку. Делается это с помощью функции file_get_contents(). Как и две предыдущие функции, в качестве параметров она принимает значение имени файла и, возможно, указание искать его в директориях include_path. Для порядка все равно приведем ее синтаксис:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 string file_get_contents ( \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     имя_файла [, use_include_path])\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эта функция абсолютно идентична функции file(), только возвращает она содержимое файла в виде строки. Кроме того, она безопасна для обработки бинарных данных и может считывать информацию из удаленных файлов, если это не запрещено настройками сервера.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Проверка существования файла\b0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Итак, создавать файл мы научились, записывать данные в него - научились, считывать данные из файла - тоже научились. Но вот вопрос: а что если файла, с которым мы пытаемся проделать все эти операции, не существует? Или он недоступен для чтения или записи? Очевидно, что в таком случае ни одна из изученных нами функций работать не будет и PHP выдаст сообщение об ошибке. Чтобы отслеживать такого рода ошибки, можно использовать функции file_exists(),   is_writable(),  is_readable(). \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Функция file_exists\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Синтаксис:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 bool file_exists (имя файла или директории)\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Функция file_exists() проверяет, существует ли файл или директория, имя которой передано ей в качестве аргумента. Если директория или файл в файловой системе сервера существует, то функция возвращает TRUE, в противном случае - FALSE. Результат работы этой функции кэшируется. Соответственно очистить кэш можно, как уже отмечалось, с помощью функции clearstatcache(). Для нелокальных файлов использовать функцию file_exists() нельзя.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $filename = 'c:/users/files/my_file.html';\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 if (file_exists($filename)) \{\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   print "Файл <b>$filename</b> существует";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \} else \{\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   print "Файл <b>$filename</b> \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         НЕ существует";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \}\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Функция is_writable \i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если кроме проверки существования файла нужно узнать еще, разрешено ли записывать информацию в этот файл, следует использовать функцию is_writable() или ее псевдоним - функцию is_writeable().\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Синтаксис:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 bool is_writable (имя файла или директории)\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эта функция возвращает TRUE, если файл (или директория) существует и доступен для записи. Доступ к файлу осуществляется под той учетной записью пользователя, под которой работает сервер (чаще всего это пользователь nobody или www). Результаты работы функции is_writable кэшируются.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Функция is_readable\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если кроме проверки существования файла нужно узнать еще, разрешено ли читать информацию из него, нужно использовать функцию is_readable().\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Синтаксис:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 bool is_readable (имя файла)\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эта функция работает подобно функции is_writable().\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $filename = 'c:/users/files/my_file.html';\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 if (is_readable($filename)) \{\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   print "Файл <b>$filename</b> существует\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      и доступен для чтения";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \} else \{\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   print "Файл <b>$filename</b> \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      НЕ существует или \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      НЕ доступен для чтения";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \}\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Удаление файла\b0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Последнее, что мы хотим изучить из действий над файлами, - это удаление файлов. Для того чтобы удалить файл с помощью языка PHP, нужно воспользоваться функцией unlink(). Синтаксис этой функции можно описать следующим образом:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 bool unlink ( имя_файла)\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Данная функция удаляет файл, имеющий имя имя_файла, возвращает TRUE в случае успеха этой операции и FALSE - в случае ошибки. Чтобы удалить файл, нужно тоже иметь соответствующие права доступа к нему (например, доступа только на чтение для удаления файла недостаточно).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $filename = 'c:/users/files/my_file.html';\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 unlink($filename);  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   // удаляем файл с именем \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   // c:/users/files/my_file.html\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Загрузка файла на сервер\b0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь решим более сложную и часто возникающую на практике задачу загрузки файла на сервер. Первое, что нужно сделать, чтобы загрузить файл на сервер, это создать html-форму. Для того чтобы с помощью этой формы можно было загружать файлы, она должна содержать атрибут enctype в теге form со значением multipart/form-data, а также элемент input типа file.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Пример 9.11.\b0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <form enctype="multipart/form-data" \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     action="parse.php" method="post">\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   <input type="hidden" name="MAX_FILE_SIZE"\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     value="30000" />\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   Загрузить файл: <input type="file" \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     name="myfile" /><br>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   <input type="submit" \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     value="Отправить файл" />\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 </form>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Заметим, что мы добавили в форме скрытое поле, которое содержит в себе максимальный допустимый размер загружаемого файла в байтах. При попытке загрузить файл, размер которого больше указанного в этом поле значения, будет зафиксирована ошибка. В браузере созданная нами форма будет выглядеть как строка для ввода текста с дополнительной кнопкой для выбора файла с локального диска (рис 9.1).\par
\par
\qc\par\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 \b Рис. 9.1.\b0            Пример формы для загрузки файла на сервер\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь нужно написать скрипт, который будет обрабатывать полученный файл.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Вся информация о загруженном на сервер файле содержится в глобальном массиве $_FILES. Этот массив появился начиная с PHP 4.1.0. Если включена директива register_globals, то значения переданных переменных доступны просто по их именам.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если мы загрузили с компьютера-клиента файл с именем critics.htm  размером 15136 байт, то скрипт с единственной командой print_r($_FILES); выведет на экран следующее:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Array ( [myfile] => \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   Array ( [name] => critics.htm \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     [type] => text/html \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     [tmp_name] => C:\\WINDOWS\\TEMP\\php49F.tmp\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     [error] => 0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     [size] => 15136 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     )\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 )\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Вообще говоря, массив $_FILES всегда имеет следующие элементы:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - $_FILES['myfile']['name'] - имя, которое имел файл на машине клиента.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - $_FILES['myfile']['type'] - mime-тип отправленного файла, если браузер предоставил эту информацию. В нашем примере это text/html.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  -  $_FILES['myfile']['size'] - размер загруженного файла в байтах.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - $_FILES['myfile']['tmp_name'] - временное имя файла, под которым он был сохранен на сервере.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - $_FILES['myfile']['error'] - код ошибки, появившейся при загрузке.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Здесь 'myfile' - это имя элемента формы, с помощью которого была произведена загрузка файла на сервер. То есть оно может быть другим, если элемент формы назвать иначе. Но вот другие ключи (name, type и т. д.) остаются неизменными для любой формы.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если register_globals=On, то доступны также дополнительные переменные, такие как $myfile_name, которая эквивалентна $_FILES['myfile']['name'], и т.п.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Ошибок при загрузке в PHP выделяют пять типов и соответственно $_FILES['myfile']['error'] может иметь пять значений:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 0 - ошибки не произошло, файл загружен успешно\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 1 - загружаемый файл превышает размер, установленный директивой upload_max_filesize в файле настроек php.ini\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 2 - загружаемый файл превышает размер, установленный элементом MAX_FILE_SIZE формы html\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 3 - файл был загружен частично\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 4 - файл загружен не был\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 По умолчанию загруженные файлы сохраняются во временной директории сервера, если другая директория не указана с помощью опции upload_tmp_dir в файле настроек php.ini. Переместить загруженный файл в нужную директорию можно с помощью функции move_uploaded_file().\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Функция move_uploaded_file() имеет следующий синтаксис:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 bool move_uploaded_file (временное_имя_файла,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                          место_назначения )\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эта функция проверяет, действительно ли файл, обозначенный строкой временное_имя_файла, был загружен через механизм загрузки HTTP методом POST. Если это так, то файл перемещается в файл, заданный параметром место_назначения (этот параметр содержит как путь к новой директории для хранения, так и новое имя файла).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если временное_имя_файла задает неправильный загруженный файл, то никаких действий произведено не будет, и move_uploaded_file() вернет FALSE. То же самое произойдет, если файл по каким-то причинам не может быть перемещен. В этом случае интерпретатор выведет соответствующее предупреждение. Если файл, заданный параметром место_назначения, существует, то функция move_uploaded_file() перезапишет его.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 /* В версиях PHP, более ранних, \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 чем 4.1.0, вместо массива \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $_FILES нужно использовать \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 массив $HTTP_POST_FILES */\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $uploaddir = 'c:/uploads/';     \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // будем сохранять загружаемые \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // файлы в эту директорию\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $destination = $uploaddir . \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      $_FILES['myfile']['name'];\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // имя файла оставим неизменным\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 print "<pre>";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 if (move_uploaded_file(\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     $_FILES['myfile']['tmp_name'], \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     $destination)) \{ \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 /* перемещаем файл из временной папки \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 в выбранную директорию для хранения */\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     print "Файл успешно загружен <br>";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \} else \{\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   echo "Произошла ошибка при загрузке файла.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     Некоторая отладочная информация:<br>";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     print_r($_FILES);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 print "</pre>"; \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Заключение\b0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Подведем итоги. В этой лекции мы изучили, как создавать файлы с помощью языка PHP, как записывать данные в файлы посредством PHP, как считывать из них информацию различными способами, как проверять существование и доступность файла для записи и чтения. Кроме того, мы рассмотрели задачу загрузки файла на сервер и обсудили основные связанные с ней переменные и функции языка PHP.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Базы данных и СУБД. Введение в SQL\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В данной лекции мы рассмотрим основные понятия теории баз данных и познакомим читателей с системой управления базами данных MySql, способами работы с ней, ее особенностями и реализацией языка запросов SQL в этой СУБД. В основе приводимых в лекции примеров лежит информационная модель виртуального музея истории информатики. Эта модель есть набор коллекций описания исторических личностей, экспонатов музея (артефактов), статей и изображений.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Базы данных: основные понятия\b0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В жизни мы часто сталкиваемся с необходимостью хранить какую-либо информацию, а потому часто имеем дело и с базами данных. Например, мы используем записную книжку для хранения номеров телефонов своих друзей и планирования своего времени. Телефонная книга содержит информацию о людях, живущих в одном городе. Все это своего рода базы данных. Ну а раз это базы данных, то посмотрим, как в них хранятся данные. Например, телефонная книга представляет собой таблицу (табл. 10.1).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В этой таблице данные – это собственно номера телефонов, адреса и ФИО., т.е. строки «Иванов Иван Иванович», «32-43-12» и т.п., а названия столбцов этой таблицы, т.е. строки «ФИО», «Номер телефона» и «Адрес» задают смысл этих данных, их семантику.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Иванов Иван Иванович\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 32-43-12\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ул. Ленина, 12, 43\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Ильин Федор Иванович\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  32-32-34\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 пр. Маркса, 32, 45\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь представьте, что записей в этой таблице не две, а две тысячи, вы занимаетесь созданием этого справочника и где-то произошла ошибка (например, опечатка в адресе). Видимо, тяжеловато будет найти и исправить эту ошибку вручную. Нужно воспользоваться какими-то средствами автоматизации. Для управления большим количеством данных программисты (не без помощи математиков) придумали системы управления базами данных (СУБД). По сравнению с текстовыми базами данных электронные СУБД имеют огромное число преимуществ, от возможности быстрого поиска информации, взаимосвязи данных между собой до использования этих данных в различных прикладных программах и одновременного доступа к данным нескольких пользователей.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для точности дадим определение базы данных, предлагаемое Глоссарий.ру\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b База данных\b0   – это совокупность связанных данных, организованных по определенным правилам, предусматривающим общие принципы описания, хранения и манипулирования, независимая от прикладных программ. База данных является информационной моделью предметной области. Обращение к базам данных осуществляется с помощью системы управления базами данных (\b СУБД\b0  ). СУБД обеспечивает поддержку создания баз данных, централизованного управления и организации доступа к ним различных пользователей.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Итак, мы пришли к выводу, что хранить данные независимо от программ, так, что они связаны между собой и организованы по определенным правилам, целесообразно. Но вопрос, как хранить данные, по каким правилам они должны быть организованы, остался открытым. Способов существует множество (кстати, называются они моделями представления или хранения данных). Наиболее популярные – объектная и реляционная модели данных.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Автором \b реляционной модели\b0   считается Э. Кодд, который первым предложил использовать для обработки данных аппарат теории множеств (объединение, пересечение, разность, декартово произведение) и показал, что любое представление данных сводится к совокупности двумерных таблиц особого вида, известного в математике как отношение.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Таким образом, реляционная база данных представляет собой набор таблиц (точно таких же, как приведенная выше), связанных между собой. Строка в таблице соответствует сущности реального мира (в приведенном выше примере это информация о человеке).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Примеры реляционных СУБД: MySql, PostgreSql.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В основу \b объектной модели\b0   положена концепция объектно-ориентированного программирования, в которой данные представляются в виде набора объектов и классов, связанных между собой родственными отношениями, а работа с объектами осуществляется с помощью скрытых (инкапсулированных) в них методов.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Примеры объектных СУБД: Cache, GemStone (от Servio Corporation), ONTOS (ONTOS).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В последнее время производители СУБД стремятся соединить два этих подхода и проповедуют объектно-реляционную модель представления данных. Примеры таких СУБД – IBM DB2 for Common Servers, Oracle8.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Поскольку мы собираемся работать с Mysql, то будем обсуждать аспекты работы только с реляционными базами данных. Нам осталось рассмотреть еще два важных понятия из этой области: ключи и индексирование, после чего мы сможем приступить к изучению языка запросов SQL.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Ключи\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для начала давайте подумаем над таким вопросом: какую информацию нужно дать о человеке, чтобы собеседник точно сказал, что это именно тот человек, сомнений быть не может, второго такого нет? Сообщить фамилию, очевидно, недостаточно, поскольку существуют однофамильцы. Если собеседник человек, то мы можем приблизительно объяснить, о ком речь, например вспомнить поступок, который совершил тот человек, или еще как-то. Компьютер же такого объяснения не поймет, ему нужны четкие правила, как определить, о ком идет речь. В системах управления базами данных для решения такой задачи ввели понятие первичного ключа.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Первичный ключ (primary key, PK) – минимальный набор полей, уникально идентифицирующий запись в таблице. Значит, первичный ключ – это в первую очередь набор полей таблицы, во-вторых, каждый набор значений этих полей должен определять единственную запись (строку) в таблице и, в-третьих, этот набор полей должен быть минимальным из всех обладающих таким же свойством. Поскольку первичный ключ определяет только одну уникальную запись, то никакие две записи таблицы не могут иметь одинаковых значений первичного ключа.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Например, в нашей таблице (см. выше) ФИО и адрес позволяют однозначно выделить запись о человеке. Если же говорить в общем, без связи с решаемой задачей, то такие знания не позволяют точно указать на единственного человека, поскольку существуют однофамильцы, живущие в разных городах по одному адресу. Все дело в границах, которые мы сами себе задаем. Если считаем, что знания ФИО, телефона и адреса без указания города для наших целей достаточно, то все замечательно, тогда поля ФИО и адрес могут образовывать первичный ключ. В любом случае проблема создания первичного ключа ложится на плечи того, кто проектирует базу данных (разрабатывает структуру хранения данных). Решением этой проблемы может стать либо выделение характеристик, которые естественным образом определяют запись в таблице (задание так называемого логического, или естественного, PK), либо создание дополнительного поля, предназначенного именно для однозначной идентификации записей в таблице (задание так называемого суррогатного, или искусственного, PK). Примером логического первичного ключа является номер паспорта в базе данных о паспортных данных жителей или ФИО и адрес в телефонной книге (таблица выше). Для задания суррогатного первичного ключа в нашу таблицу можно добавить поле id (идентификатор), значением которого будет целое число, уникальное для каждой строки таблицы. Использование таких суррогатных ключей имеет смысл, если естественный первичный ключ представляет собой большой набор полей или его выделение нетривиально.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Кроме однозначной идентификации записи, первичные ключи используются для организации связей с другими таблицами.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Например, у нас есть три таблицы: содержащая информацию об исторических личностях (Persons), содержащая информацию об их изобретениях (Artifacts) и содержащая изображения как личностей, так и артефактов (Images) (рис 10.1).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Первичным ключом во всех этих таблицах является поле id (идентификатор). В таблице Artifacts есть поле author, в котором записан идентификатор, присвоенный автору изобретения в таблице Persons. Каждое значение этого поля является \b внешним ключом\b0   для первичного ключа таблицы Persons. Кроме того, в таблицах Persons и Artifacts есть поле photo, которое ссылается на изображение в таблице Images. Эти поля также являются внешними ключами для первичного ключа таблицы Images и устанавливают однозначную логическую связь Persons-Images и Artifacts-Images. То есть если значение внешнего ключа photo в таблице личности равно 10, то это значит, что фотография этой личности имеет id=10 в таблице изображений. Таким образом, \b внешние ключи\b0   используются для организации связей между таблицами базы данных (родительскими и дочерними) и для поддержания ограничений ссылочной целостности данных.\par
\par
\qc\par\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 \b Рис. 10.1.\b0            Пример использования первичных ключей для организации связей с другими таблицами\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Индексирование\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Одна из основных задач, возникающих при работе с базами данных, – это задача поиска. При этом, поскольку информации в базе данных, как правило, содержится много, перед программистами встает задача не просто поиска, а эффективного поиска, т.е. поиска за сравнительно небольшое время и с достаточной точностью. Для этого (для оптимизации производительности запросов) производят \b индексирование\b0   некоторых полей таблицы. Использовать индексы полезно для быстрого поиска строк с указанным значением одного столбца. Без индекса чтение таблицы осуществляется по всей таблице, начиная с первой записи, пока не будут найдены соответствующие строки. Чем больше таблица, тем больше накладные расходы. Если же таблица содержит индекс по рассматриваемым столбцам, то база данных может быстро определить позицию для поиска в середине файла данных без просмотра всех данных. Это происходит потому, что база данных помещает проиндексированные поля поближе в памяти, так, чтобы можно было побыстрее найти их значения. Для таблицы, содержащей 1000 строк, это будет как минимум в 100 раз быстрее по сравнению с последовательным перебором всех записей. Однако в случае, когда необходим доступ почти ко всем 1000 строкам, быстрее будет последовательное чтение, так как при этом не требуется операций поиска по диску. Так что иногда индексы бывают только помехой. Например, если копируется большой объем данных в таблицу, то лучше не иметь никаких индексов. Однако в некоторых случаях требуется задействовать сразу несколько индексов (например, для обработки запросов к часто используемым таблицам).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если говорить о MySQL, то там существует три вида индексов: PRIMARY, UNIQUE, и INDEX, а слово ключ (KEY) используется как синоним слова индекс (INDEX). Все индексы хранятся в памяти в виде B-деревьев.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 PRIMARY – уникальный индекс (ключ) с ограничением, что все индексированные им поля не могут иметь пустого значения (т.е. они NOT NULL). Таблица может иметь только один первичный индекс, но он может состоять из нескольких полей.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 UNIQUE – ключ (индекс), задающий поля, которые могут иметь только уникальные значения.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 INDEX – обычный индекс (как мы описали выше). В MySqL, кроме того, можно индексировать строковые поля по заданному числу символов от начала строки.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b СУБД MySQL\b0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Продолжим разговор о СУБД MySQL. MySQL – это реляционная система управления базами данных. То есть данные в ее базах хранятся в виде логически связанных между собой таблиц, доступ к которым осуществляется с помощью языка запросов SQL. MySQL – свободно распространяемая система, т.е. платить за ее применение не нужно. Кроме того, это достаточно быстрая, надежная и, главное, простая в использовании СУБД, вполне подходящая для не слишком глобальных проектов.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Работать с MySQL можно не только в текстовом режиме, но и в графическом. Существует очень популярный визуальный интерфейс (кстати, написанный на PHP) для работы с этой СУБД. Называется он PhpMyAdmin. Этот интерфейс позволяет значительно упростить работу с базами данных в MySQL.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В текстовом режиме работа с базой данных выглядит просто как ввод команд в командную строку (рис 10.2), а результаты выборок возвращаются в виде своеобразных таблиц, поля в которых налезают друг на друга, если данные не помещаются на экран (рис 10.3).\par
\par
\qc\par\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 \b Рис. 10.2.\b0            Работа с MySQL в коммандной строке. Команда show databases — вывести все имеющиеся базы данных\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 PhpMyAdmin позволяет пользоваться всеми достоинствами браузера, включая прокрутку изображения, если оно не умещается на экран. Многие из базовых SQL-функций работы с данными в PhpMyAdmin сведены к интуитивно понятным интерфейсам и действиям, напоминающим переход по ссылкам в Internet. Но тем не менее стоит все же поработать и в текстовом режиме.\par
\par
\qc\par\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 \b Рис. 10.3.\b0            Работа с MySQL в коммандной строке. Результат обработки команды show databases\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Перед тем как переходить к детальному изучению языка SQL, несколько слов об установке MySQL и подготовке к работе. Если вы не собираетесь заниматься администрированием сервера, то информация, приведенная ниже, пригодится вам только для общего развития. Итак, устанавливается MySQL очень просто – автоматически, пару раз нажмите OK, и все. После этого вы можете зайти в директорию, где лежат файлы типа mysql.exe, mysqld.exe и т.п. (у нас под Windows XP это c:\\mysql\\bin) Последний файл запускает Mysql-сервер. В некоторых системах сервер запускается в виде сервиса. После запуска сервера следует запустить mysql-клиент, запустив программу mysql.exe. Здесь даже пароля не спросят. Более того, если вы наберете\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 shell> mysql.exe -u root\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 или\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 shell>mysql -u root mysql\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 то получите все права администратора mysql сервера. Кстати, выполнять эти команды надо, находясь в той директории, где лежат файлы mysql.exe.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для начала, не вдаваясь в подробности команд, исправим эти два недочета (отсутствие пароля у администратора и возможность входа анонимным пользователям):\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 shell> mysql -u root mysql\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 mysql> UPDATE user SET Password=PASSWORD('new_password')\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     WHERE user='root';\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 mysql> DELETE FROM user WHERE user='';\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 mysql> FLUSH PRIVILEGES;\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Все данные о пользователях MySQL хранит в таблице user в специальной базе данных mysql, доступ к которой имеет только администратор сервера. Поэтому, чтобы изменить какой-либо пароль, нужно изменить эту таблицу. Пароль задается с помощью функции PASSWORD, которая кодирует введенные данные. Кроме изменения пароля администратора, нужно еще удалить всех пользователей, не имеющих логина (команда DELETE). Команда Flush Privileges заставляет вступить в действие изменения, произошедшие в системной базе данных (mysql).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь создадим базу данных, с которой будем работать (мы все еще работаем как администратор сервера):\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 mysql>create database book;\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Как можно заметить, все команды в MySQL заканчиваются точкой с запятой. Если вы забыли поставить этот знак, то выдается приглашение его поставить до тех пор, пока это не будет сделано:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 mysql> show tables\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     ->\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     ->\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь последнее действие – создадим простого пользователя, предоставим ему доступ к созданной базе данных, и начнем работать.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 mysql> GRANT ALL PRIVILEGES ON book.* TO nina@localhost \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     IDENTIFIED BY '123';\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Команда GRANT наделяет пользователя nina, зашедшего на сервер с этой же машины (c localhost) и идентифицируемого паролем «123», определенными правами (в данном случае всеми) на все таблицы базы данных book. Теперь мы можем выйти и зайти как пользователь nina с соответствующим паролем:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 shell>mysql -u nina -p\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Enter password: *** \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Welcome to the MySQL monitor!...\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 mysql>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если вы собираетесь пользоваться базой данных на чужом сервере, то его администратор проделает все описанные выше действия за вас, т.е. все настроит и создаст пользователя и базу данных. В следующей главе описаны команды языка SQL, которые пригодятся для работы с данными, хранящимися в СУБД MySQL.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Язык SQL\b0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Итак, мы в общих чертах познакомились с основными понятиями теории баз данных, установили и настроили для работы MySQL. Теперь самое время научиться манипулировать данными, хранящимися в базах данных. Для этого нам понадобится SQL – структурированный язык запросов. Этот язык дает возможность создавать, редактировать и удалять информацию, хранящуюся в базах данных, создавать новые базы данных и многое другое. SQL является стандартом ANSI (Американский национальный институт стандартов) и ISO (Международная организация по стандартизации).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Немного истории\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Первый международный стандарт языка SQL был принят в 1989 г., его часто называют SQL/89. Среди недостатков этого стандарта выделяют в первую очередь то, что многие важные свойства он устанавливал как определяемые в реализации. Отсюда произошло множество расхождений в реализациях языка разными производителями. Кроме того, высказывались претензии по поводу отсутствия в этом стандарте упоминаний о практических аспектах языка, таких как его встраивание в язык программирования Си.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Следующий международный стандарт языка SQL был принят в конце 1992 г. И стал называться SQL/92. Он получился гораздо более точным и полным, чем SQL/89, хотя и не был лишен недостатков. В настоящее время большинство систем почти полностью реализуют этот стандарт. Однако, как известно, прогресс не остановишь, и в 1999 году появился новый стандарт SQL:1999, также известный как SQL3. SQL3 характеризуется как «объектно-ориентированный SQL» и является основой нескольких объектно-реляционных систем управления базами данных (например, ORACLE8 компании Oracle, Universal Server компании Informix и DB2 Universal Database компании IBM). Этот стандарт является не просто слиянием SQL-92 и объектной технологии. Он содержит ряд расширений традиционного SQL, а сам документ составлен таким образом, чтобы добиться более эффективной работы в области стандартизации в будущем.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если говорить о MySQL, то она соответствует начальному уровню SQL92, содержит несколько расширений этого стандарта и стремится к полной поддержке стандарта ANSI SQL99, но без ущерба для скорости и качества кода.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Далее, говоря об основах языка SQL, будем придерживаться его реализации в СУБД MySQL.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Основные операторы языка SQL\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Функции любой СУБД включают:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - создание, удаление, изменение базы данных (БД);\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - добавление, изменение, удаление, назначение прав пользователя;\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - внесение, удаление и изменение данных в БД (таблиц и записей);\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - выборку данных из БД.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 К первым двум функциям имеют доступ только администраторы СУБД или привилегированные пользователи. Рассмотрим, как решаются последние две задачи (на самом деле это семь задач).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Прежде чем что-либо делать с данными, нужно создать таблицы, в которых эти данные будут храниться, научиться изменять структуру этих таблиц и удалять их, если потребуется. Для этого в языке SQL существуют операторы CREATE TABLE, ALTER TABLE и DROP TABLE.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Оператор CREATE TABLE\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Оператор CREATE TABLE создает таблицу с заданным именем в текущей базе данных. Правила для допустимых имен таблицы приведены в документации. Если нет активной текущей базы данных или указанная таблица уже существует, то возникает ошибка выполнения команды.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В версии MySQL 3.22 и более поздних имя таблицы может быть указано как имя_базы_данных.имя_таблицы. Эта форма записи работает независимо от того, является ли указанная база данных текущей.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В версии MySQL 3.23 при создании таблицы можно использовать ключевое слово TEMPORARY. Временная таблица автоматически удаляется по завершении соединения, а ее имя действительно только в течение данного соединения. Это означает, что в двух разных соединениях могут использоваться временные таблицы с одинаковыми именами без конфликта друг с другом или с существующей таблицей с тем же именем (существующая таблица скрыта, пока не удалена временная таблица). В версии MySQL 4.0.2 для создания временных таблиц необходимо иметь привилегии CREATE TEMPORARY TABLES.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В версии MySQL 3.23 и более поздних можно использовать ключевые слова IF NOT EXISTS для того, чтобы не возникала ошибка, если указанная таблица уже существует. Следует учитывать, что при этом идентичность структур этих таблиц не проверяется.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Каждая таблица представлена набором определенных файлов в директории базы данных.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Синтаксис\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 CREATE [TEMPORARY] TABLE [IF NOT EXISTS]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      имя_таблицы [(определение_столбца,...)]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     [опции_таблицы] [select_выражение]\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В выражении определение_столбца перечисляют, какие столбцы должны быть созданы в таблице. Каждый столбец таблицы может быть пустым (NULL), иметь значение по умолчанию, являться ключом или автоинкрементом. Кроме того, для каждого столбца обязательно указывается тип данных, которые будут в нем храниться. Если не указывается ни NULL, ни NOT NULL, то столбец интерпретируется так, как будто указано NULL. Если поле помечают как автоинкремент (AUTO_INCREMENT), то его значение автоматически увеличивается на единицу каждый раз, когда происходит добавление данных в таблицу и в это поле записывается пустое значение (NULL, т.е. ничего не записывается) или 0. Автоинкремент в таблице может быть только один, и при этом он обязательно должен быть проиндексирован. Последовательность AUTO_INCREMENT начинается с 1. Наличие автоинкремента является одной из особенностей MySQL. Формально описание столбца (определение_столбца) выглядит так:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 имя_столбца тип [NOT NULL | NULL] \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     [DEFAULT значение_по_умолчанию]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     [AUTO_INCREMENT][PRIMARY KEY] \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     [reference_definition]\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Тип столбца (тип в выражении определение_столбца) может быть одним из следующих:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - целый: INT[(length)] [UNSIGNED] [ZEROFILL]\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - действительный: REAL[(length,decimals)] [UNSIGNED] [ZEROFILL]\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - символьный: CHAR(length) [BINARY] и VARCHAR(length) [BINARY]\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - дата и время: DATE и TIME\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - для работы с большими объектами: BLOB\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - текстовый: TEXT\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - перечислимое множество: ENUM(value1,value2,value3,...) и SET(value1,value2,value3,...)\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Полный список типов смотрите в документации MySQL.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Вместо перечисления столбцов и их свойств в определении_столбца можно задавать списки ключевых и индексных полей, ограничения и проверки:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 PRIMARY KEY (имя_индексируемого_столбца, ...)\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 или\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 KEY [имя_индекса] (имя_индексируемого_столбца,...)\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 или\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 INDEX [имя_индекса] (имя_индексируемого_столбца,...)\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 или\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 UNIQUE [INDEX] [имя_индекса] \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     (имя_индексируемого_столбца,...)\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 или\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 FULLTEXT [INDEX] [имя_индекса] \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     (имя_индексируемого_столбца,...)\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 или\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 [CONSTRAINT symbol] \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 FOREIGN KEY [имя_индекса] \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     (имя_индексируемого_столбца,...) \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 [reference_definition]\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 или\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 CHECK (expr)\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 При задании всех этих элементов указывается список полей (столбцов), которые будут входить в индекс, ключ или ограничение, имя_индексируемого_столбца записывается следующим образом:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 имя_столбца [(длина_индекса)]\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 FOREIGN KEY, CHECK и REFERENCES на самом деле ничего не делают в MySQL. Они добавлены только для совместимости с другими SQL-серверами. Поэтому на них мы останавливаться не будем.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Кроме всего перечисленного, при создании таблицы можно указать некоторые ее свойства (опции_таблицы), например такие:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - тип таблицы: TYPE = \{BDB | HEAP | ISAM | InnoDB | MERGE | MRG_MYISAM | MYISAM \}\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - начальное значение счетчика автоинкремента: AUTO_INCREMENT = число\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - средняя длина строк в таблице: AVG_ROW_LENGTH = число\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - комментарии к таблице (строка из 60 символов): COMMENT = "строка"\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - максимальное и минимальное предполагаемое число строк: MAX_ROWS = число и MIN_ROWS = число\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 И последний (опять же опциональный) элемент команды CREATE – это выражение SELECT (select_выражение). Синтаксис такой:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 [IGNORE | REPLACE] SELECT ... \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     (любое корректное выражение SELECT)\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если при создании таблицы в команде CREATE указывается выражение SELECT, то все поля, полученные выборкой, добавляются в создаваемую таблицу.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Пример 10.1\b0  . Создадим таблицу Persons, структура  которой была приведена на рисунке 10.1.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 mysql>CREATE TABLE Persons \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     (id INT PRIMARY KEY AUTO_INCREMENT,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    first_name VARCHAR(50), last_name \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     VARCHAR(100), death_date INT, \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    description TEXT, photo INT, \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    citienship CHAR(50) DEFAULT 'Russia');\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 С помощью специфичной для MySql команды SHOW можно просмотреть существующие базы данных, таблицы в базе данных и поля в таблице.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Показать все базы данных:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 mysql>SHOW databases;\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Сделать текущей базу данных book и показать все таблицы в ней:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 mysql>use book;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 mysql>show tables;\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Показать все столбцы в таблице Persons:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 mysql> show columns from Persons;\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Оператор DROP TABLE\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Оператор DROP TABLE удаляет одну или несколько таблиц. Все табличные данные и определения удаляются, так что при работе с этой командой следует соблюдать осторожность.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Синтаксис:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 DROP TABLE [IF EXISTS] имя_таблицы \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     [, имя_таблицы,...] \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     [RESTRICT | CASCADE]\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В версии MySQL 3.22 и более поздних можно использовать ключевые слова IF EXISTS, чтобы предупредить ошибку, если указанные таблицы не существуют.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Опции RESTRICT и CASCADE позволяют упростить перенос программы с других СУБД. В данный момент они не задействованы.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 mysql> DROP TABLE IF EXISTS Persons,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0        Artifacts, test;\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Оператор ALTER TABLE\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Оператор ALTER TABLE обеспечивает возможность изменять структуру существующей таблицы. Например, можно добавлять или удалять столбцы, создавать или уничтожать индексы или переименовывать столбцы либо саму таблицу. Можно также изменять комментарий для таблицы и ее тип.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Синтаксис:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ALTER [IGNORE] TABLE имя_таблицы \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     alter_specification \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     [, alter_specification ...]\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Можно производить следующие изменения в таблице  (все они записываются в alter_specification):\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     ADD [COLUMN] определение_столбца \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 [FIRST | AFTER имя_столбца ]\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 или\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ADD [COLUMN] (определение_столбца, \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     определение_столбца,...)\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Здесь, как и далее, определение_столбца записывается так же, как при создании таблицы.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ADD INDEX [имя_индекса] (имя_индексируемого_столбца,...) или ADD PRIMARY KEY (имя_индексируемого_столбца,...) или ADD UNIQUE [имя_индекса] (имя_индексируемого_столбца,...) или ADD FULLTEXT [имя_индекса] (имя_индексируемого_столбца,...)\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ALTER [COLUMN] имя_столбца \{SET DEFAULT literal | DROP DEFAULT\} или CHANGE [COLUMN] старое_имя_столбца  определение_столбца или MODIFY [COLUMN] определение_столбца\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    DROP [COLUMN] имя_столбца\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     DROP PRIMARY KEY\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     DROP INDEX имя_индекса\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 RENAME [TO] новое_имя_таблицы\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ORDER BY поле\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 или\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 опции_таблицы\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если оператор ALTER TABLE используется для изменения определения типа столбца, но DESCRIBE имя_таблицы показывает, что столбец не изменился, то, возможно, MySQL игнорирует данную модификацию по одной из причин, описанных в специальном разделе документации. Например, при попытке изменить столбец VARCHAR на CHAR MySQL будет продолжать использовать VARCHAR, если данная таблица содержит другие столбцы с переменной длиной.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Оператор ALTER TABLE во время работы создает временную копию исходной таблицы. Требуемое изменение выполняется на копии, затем исходная таблица удаляется, а новая переименовывается. Это делается для того, чтобы в новую таблицу автоматически попадали все обновления, кроме неудавшихся. Во время выполнения ALTER TABLE исходная таблица доступна для чтения другими клиентами. Операции обновления и записи в этой таблице приостанавливаются, пока не будет готова новая таблица. Следует отметить, что при использовании любой другой опции для ALTER TABLE, кроме RENAME, MySQL всегда будет создавать временную таблицу, даже если данные, строго говоря, и не нуждаются в копировании (например, при изменении имени столбца).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Пример10.3\b0  . Добавим в созданную таблицу Persons поле для записи года рождения человека:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 mysql> ALTER TABLE Persons \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     ADD bday INTEGER AFTER last_name;\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Итак, мы научились работать с таблицами: создавать, удалять и изменять их. Теперь разберемся, как делать то же самое с данными, которые в этих таблицах хранятся.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Оператор SELECT\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Оператор SELECT применяется для извлечения строк, выбранных из одной или нескольких таблиц. То есть с его помощью мы задаем столбцы или выражения, которые надо извлечь (select_выражения), таблицы (table_references), из которых должна производиться выборка, и, возможно, условие (where_definition), которому должны соответствовать данные в этих столбцах, и порядок, в котором эти данные нужно выдать.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Кроме того, оператор SELECT можно использовать для извлечения строк, вычисленных без ссылки на какую-либо таблицу. Например, чтобы вычислить, чему равно 2*2, нужно просто написать\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 mysql> SELECT 2*2;\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Упрощенно структуру оператора SELECT можно представить следующим образом:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 SELECT select_выражение1, select_выражение2,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     ...\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     [FROM table_references\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         [WHERE where_definition]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         [ORDER BY \{число | имя_столбца |\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                  формула\}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0             [ASC | DESC], ...]]\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Квадратные скобки [ ] означают, что использование находящегося в них оператора необязательно, вертикальная черта | означает перечисление возможных вариантов. После ключевого слова ORDER BY указывают имя столбца, число (целое беззнаковое) или формулу и способ упорядочения (по возрастанию – ASC, или по убыванию – DESC). По умолчанию используется упорядочение по возрастанию.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Когда в select_выражении мы пишем «*», это значит выбрать все столбцы. Кроме «*» в select_выражения могут использоваться функции типа max, min и avg.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Пример 10.4\b0  . Выбрать из таблицы Persons все данные, для которых поле first_name имеет значение 'Александр':\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 mysql> SELECT * FROM Persons \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0        WHERE first_name='Александр';\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Выбрать название и описание (title, description) артефакта под номером 10:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 mysql> SELECT title,description \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      FROM Artifacts WHERE id=10;\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Оператор INSERT\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Оператор INSERT вставляет новые строки в существующую таблицу. Оператор имеет несколько форм. Параметр имя_таблицы во всех этих формах задает таблицу, в которую должны быть внесены строки. Столбцы, для которых задаются значения, указываются в списке имен столбцов (имя_столбца) или в части SET.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Синтаксис:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 INSERT [LOW_PRIORITY | DELAYED] [IGNORE]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     [INTO] имя_таблицы [(имя_столбца,...)]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     VALUES (выражение,...),(...),...\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эта форма команды INSERT вставляет строки в соответствии с точно указанными в команде значениями. В скобках после имени таблицы перечисляются столбцы, а после ключевого слова VALUES – их значения.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Например:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 mysql> INSERT INTO Persons \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     (last_name, bday) VALUES \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     ('Иванов', '1934');\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 вставит в таблицу Persons строку, в которой значения фамилии (last_name) и даты рождения (bday) будут заданы соответственно как «Иванов» и «1934».\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 INSERT [LOW_PRIORITY | DELAYED] [IGNORE]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     [INTO] имя_таблицы [(имя_столбца,...)]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     SELECT ...\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эта форма команды INSERT вставляет строки, выбранные из другой таблицы или таблиц.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Например:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 mysql> INSERT INTO Artifacts (author)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0        SELECT id FROM Persons \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0           WHERE last_name='Иванов' \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0             AND bday='1934'; \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 вставит в таблицу Artifacts в поле «автор» (author) значение идентификатора, выбранного из таблицы Persons по условию, что фамилия человека Иванов.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 INSERT [LOW_PRIORITY | DELAYED] [IGNORE]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     [INTO] имя_таблицы\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     SET имя_столбца=выражение, \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0        имя_столбца=выражение, ...\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Например:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 mysql> INSERT INTO Persons \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0           SET last_name='Петров',\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0               first_name='Иван';\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эта команда вставит в таблицу Persons в поле last_name значение «Петров», а в поле first_name – строку «Иван».\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  -  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Форма INSERT ... VALUES со списком из нескольких значений поддерживается в версии MySQL 3.22.5 и более поздних. Синтаксис выражения имя_столбца=выражение поддерживается в версии MySQL 3.22.10 и более поздних.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Действуют следующие соглашения.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - Если не указан список столбцов для INSERT ... VALUES или INSERT ... SELECT, то величины для всех столбцов должны быть определены в списке VALUES() или в результате работы SELECT. Если порядок столбцов в таблице неизвестен, для его получения можно использовать DESCRIBE имя_таблицы.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - Любой столбец, для которого явно не указано значение, будет установлен в свое значение по умолчанию. Например, если в заданном списке столбцов не указаны все столбцы в данной таблице, то не упомянутые столбцы устанавливаются в свои значения по умолчанию.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 mysql> INSERT INTO имя_таблицы (col1,col2)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0        VALUES(15,col1*2);\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Но нельзя указать:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 mysql> INSERT INTO имя_таблицы (col1,col2)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0        VALUES(col2*2,15);\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Мы еще не обсудили три необязательных параметра, присутствующих во всех трех формах команды: LOW_PRIORITY, DELAYED и IGNORE.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Параметры LOW_PRIORITY и DELAYED используются, когда с таблицей работает большое число пользователей. Они предписывают устанавливать приоритет данной операции перед операциями других пользователей. Если указывается ключевое слово LOW_PRIORITY, то выполнение данной команды INSERT будет задержано до тех пор, пока другие клиенты не завершат чтение этой таблицы. В этом случае клиент должен ожидать, пока данная команда вставки не будет завершена, что в случае интенсивного использования таблицы может потребовать значительного времени. В противоположность этому команда INSERT DELAYED позволяет данному клиенту продолжать операцию сразу же, независимо от других пользователей.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если в команде INSERT указывается ключевое слово IGNORE, то все строки, имеющие дублирующиеся ключи PRIMARY или UNIQUE в этой таблице, будут проигнорированы и не внесены в таблицу. Если не указывать IGNORE, то данная операция вставки прекращается при обнаружении строки, имеющей дублирующееся значение существующего ключа.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Оператор UPDATE\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Синтаксис:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 UPDATE [LOW_PRIORITY] [IGNORE] имя_таблицы\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     SET имя_столбца1=выражение1 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    [, имя_столбца2=выражение2, ...]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     [WHERE where_definition]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     [LIMIT число]\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Оператор UPDATE обновляет значения существующих столбцов таблицы в соответствии с введенными значениями. В выражении SET указывается, какие именно столбцы следует модифицировать и какие величины должны быть в них установлены. В выражении WHERE, если оно присутствует, задается, какие строки подлежат обновлению. В остальных случаях обновляются все строки. Если задано выражение ORDER BY, то строки будут обновляться в указанном в нем порядке.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если указывается ключевое слово LOW_PRIORITY, то выполнение данной команды UPDATE задерживается до тех пор, пока другие клиенты не завершат чтение этой таблицы.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если указывается ключевое слово IGNORE, то команда обновления не будет прервана, даже если возникнет ошибка дублирования ключей. Строки, из-за которых возникают конфликтные ситуации, обновлены не будут.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если в выражении, которое задает новое значение столбца, используется имя этого поля, то команда UPDATE использует для этого столбца его текущее значение. Например, следующая команда устанавливает столбец death_date в значение, на единицу большее его текущей величины:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 mysql> UPDATE Persons \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0        SET death_date=death_date+1;\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В версии MySQL 3.23 можно использовать параметр LIMIT #, чтобы убедиться, что было изменено только заданное количество строк.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Например, такая операция заменит в первой строке нашей таблицы экспонатов название title на строку «Ламповая ЭВМ»:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 mysql> UPDATE Artifacts \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0        SET title='Ламповая ЭВМ' Limit 1;\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Оператор DELETE\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Оператор DELETE удаляет из таблицы имя_таблицы строки, удовлетворяющие заданным в where_definition условиям, и возвращает число удаленных записей.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если оператор DELETE запускается без определения WHERE, то удаляются все строки.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Синтаксис:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 DELETE [LOW_PRIORITY] FROM имя_таблицы\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     [WHERE where_definition]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     [LIMIT rows]\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Например, следующая команда удалит из таблицы Persons все записи, у которых поле «год рождения» (bday) больше 2003:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 mysql> DELETE FROM Persons WHERE bday>2003;\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Удалить все записи в таблице можно еще и с помощью такой команды:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 mysql> DELETE FROM Persons WHERE 1>0;\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Но этот метод работает гораздо медленнее, чем использование той же команды без условия:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 mysql> DELETE FROM Persons;\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Специфическая для MySQL опция LIMIT для команды DELETE указывает серверу максимальное количество строк, которые следует удалить до возврата управления клиенту. Эта опция может использоваться для гарантии того, что данная команда DELETE не потребует слишком много времени для выполнения.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Заключение\b0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Итак, мы разобрались с основами реляционных баз данных, научились создавать простые и не очень SQL-запросы. Надеюсь, что большое количество технических деталей не помешало читателям получить представление о базовых элементах языка, поскольку все это наверняка пригодится для решения практических задач.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Взаимодействие PHP и MySQL\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В дистрибутив PHP входит расширение, содержащее встроенные функции для работы с базой данных MySQL. В этой лекции мы познакомимся с некоторыми основными функциями для работы с MySQL, которые потребуются для решения задач построения web-интерфейсов с целью отображения и наполнения базы данных. Возникает вопрос, зачем строить такие интерфейсы? Для того чтобы вносить информацию в базу данных и просматривать ее содержимое могли люди, не знакомые с языком запросов SQL. При работе с web-интерфейсом для добавления информации в базу данных человеку нужно просто ввести эти данные в html-форму и отправить их на сервер, а наш скрипт сделает все остальное. А для просмотра содержимого таблиц достаточно просто щелкнуть по ссылке и зайти на нужную страницу.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для наглядности будем строить эти интерфейсы для таблицы Artifacts, в которой содержится информация об экспонатах виртуального музея информатики. В предыдущей лекции мы уже приводили структуру этой коллекции, а также ее связи с коллекциями описания персон (Persons) и изображений (Images). Напомним, что каждый экспонат в коллекции Artifacts описывается с помощью следующих характеристик:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - название (title);\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - автор (author);\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - описание (description);\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - альтернативное название (alternative);\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - изображение (photo).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Название и альтернативное название являются строками менее чем 255 символов длиной (т.е. имеют тип VARCHAR(255)), описание - текстовое поле (имеет тип TEXT), а в полях "автор" и "изображение" содержатся идентификаторы автора из коллекции Persons и изображения экспоната из коллекции Images соответственно.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Построение интерфейса для добавления информации\b0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Итак, у нас есть какая-то таблица в базе данных. Чтобы построить интерфейс для добавления информации в эту таблицу, нужно ее структуру (т.е. набор ее полей) отобразить в html-форму.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Разобьем эту задачу на следующие подзадачи:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - установка соединения с БД;\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - выбор рабочей БД;\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - получение списка полей таблицы;\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - отображение полей в html-форму.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 После этого данные, введенные в форму, нужно записать в базу данных. Рассмотрим все эти задачи по порядку.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Установка соединения\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Итак, первое, что нужно сделать, - это установить соединение с базой данных. Воспользуемся функцией mysql_connect.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Синтаксис mysql_connect\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ресурс mysql_connect ( [строка server \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     [, строка username [, строка password\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    [, логическое new_link \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     [, целое client_flags]]]]])\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Данная функция устанавливает соединение с сервером MySQL и возвращает указатель на это соединение или FALSE в случае неудачи. Для отсутствующих параметров устанавливаются следующие значения по умолчанию:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 server = 'localhost:3306' \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 username = имя пользователя владельца \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0            процесса сервера\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 password = пустой пароль \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если функция вызывается дважды с одними и теми же параметрами, то новое соединение не устанавливается, а возвращается ссылка на старое соединение. Чтобы этого избежать, используют параметр new_link, который заставляет в любом случае открыть еще одно соединение.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Параметр client_flags - это комбинация следующих констант: MYSQL_CLIENT_COMPRESS (использовать протокол сжатия), MYSQL_CLIENT_IGNORE_SPACE (позволяет вставлять пробелы после имен функций), MYSQL_CLIENT_INTERACTIVE (ждать interactive_timeout секунд - вместо wait_timeout - до закрытия соединения).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Параметр new_link появился в PHP 4.2.0, а параметр client_flags - в PHP 4.3.0.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Соединение с сервером закрывается при завершении исполнения скрипта, если оно до этого не было закрыто с помощью функции mysql_close().\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Итак, устанавливаем соединение с базой данных на локальном сервере для пользователя nina с паролем "123":\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $conn = mysql_connect(\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     "localhost", "nina","123")\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 or die("Невозможно установить \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         соединение: ". mysql_error());\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo "Соединение установлено";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 mysql_close($conn);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Действие mysql_connect равносильно команде\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0       \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 shell>mysql -u nina -p123   \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Выбор базы данных\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 После установки соединения нужно выбрать базу данных, с которой будем работать. Наши данные хранятся в базе данных book. В MySQL  выбор базы данных осуществляется с помощью команды use:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 mysql>use book;\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В PHP для этого существует функция mysql_select_db.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Синтаксис mysql_select_db:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 логическое mysql_select_db ( \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     строка database_name \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     [, ресурс link_identifier])\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эта функция возвращает TRUE в случае успешного выбора базы данных и FALSE - в противном случае.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Сделаем базу данных book рабочей:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $conn = mysql_connect(\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     "localhost","nina","123") \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 or die("Невозможно установить \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         соединение: ". mysql_error());\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo "Соединение установлено";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 mysql_select_db("book");\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Получение списка полей таблицы\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь можно заняться собственно решением задачи. Как получить список полей таблицы? Очень просто. В PHP и на этот случай есть своя команда - mysql_list_fields.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Синтаксис  mysql_list_fields\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ресурс mysql_list_fields (\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     строка database_name, \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     строка table_name \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    [, ресурс link_identifier])\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эта функция возвращает список полей в таблице table_name в базе данных database_name. Получается, что выбирать базу данных нам было необязательно, но это пригодится позже. Как можно заметить, результат работы этой функции - переменная типа ресурс. То есть это не совсем то, что мы хотели получить. Это ссылка, которую можно использовать для получения информации о полях таблицы, включая их названия, типы и флаги.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Функция mysql_field_name возвращает имя поля, полученного в результате выполнения запроса. Функция mysql_field_len возвращает длину поля. Функция mysql_field_type возвращает тип поля, а функция mysql_field_flags возвращает список флагов поля, записанных через пробел. Типы поля могут быть int, real, string, blob и т.д. Флаги могут быть not_null, primary_key, unique_key, blob, auto_increment и т.д.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Синтаксис у всех этих команд одинаков:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 строка mysql_field_name (\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     ресурс result, целое field_offset)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 строка mysql_field_type ( \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     ресурс result, целое field_offset)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 строка mysql_field_flags ( \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     ресурс result, целое field_offset)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 строка mysql_field_len ( \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     ресурс result, целое field_offset)\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Здесь result - это идентификатор результата запроса (например, запроса, отправленного функциями mysql_list_fields или mysql_query (о ней будет рассказано позднее)), а field_offset - порядковый номер поля в результате.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Вообще говоря, то, что возвращают функции типа mysql_list_fields или mysql_query, представляет собой таблицу, а точнее, указатель на нее. Чтобы получить из этой таблицы конкретные значения, нужно задействовать специальные функции, которые построчно читают эту таблицу. К таким функциям и относятся mysql_field_name и т.п. Чтобы перебрать все строки в таблице результата выполнения запроса, нужно знать число строк в этой таблице. Команда mysql_num_rows(ресурс result) возвращает число строк во множестве результатов result.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 А теперь попробуем получить список полей таблицы Artifacts (коллекция экспонатов).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $conn = mysql_connect(\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     "localhost","nina","123")\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 or die("Невозможно установить \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         соединение: ". mysql_error());\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo "Соединение установлено";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 mysql_select_db("book");\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $list_f = mysql_list_fields (\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   "book","Artifacts",$conn);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   $n = mysql_num_fields($list_f);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 for($i=0;$i<$n; $i++)\{\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   $type = mysql_field_type($list_f, $i);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   $name_f = mysql_field_name($list_f,$i);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   $len = mysql_field_len($list_f, $i);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   $flags_str =  mysql_field_flags (\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                $list_f, $i);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo "<br>Имя поля: ". $name_f;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo "<br>Тип поля: ". $type;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo "<br>Длина поля: ". $len;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo "<br>Строка флагов поля: ".\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     $flags_str . "<hr>";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В результате должно получиться примерно вот что (если в таблице всего два поля, конечно):\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0       \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Имя поля: id\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Тип поля: int\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Длина поля: 11\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Строка флагов поля: \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    not_null primary_key auto_increment\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Имя поля: title\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Тип поля: string\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Длина поля: 255\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Строка флагов поля: \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Отображение списка полей в html-форму\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь немножко подкорректируем предыдущий пример. Будем не просто выводить информацию о поле, а отображать его в подходящий элемент html-формы. Так, элементы типа BLOB переведем в textarea (заметим, что поле description, которое мы создавали с типом TEXT, отображается как имеющее тип BLOB), числа и строки отобразим в текстовые строки ввода <input type=text>, а элемент, имеющий метку автоинкремента, вообще не будем отображать, поскольку его значение устанавливается автоматически.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Все это решается довольно просто, за исключением выделения из списка флагов флага auto_increment. Для этого нужно воспользоваться функцией explode.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Синтаксис explode:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 массив explode( строка separator, \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     строка string [, int limit])\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эта функция разбивает строку string на части с помощью разделителя separator и возвращает массив полученных строк.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В нашем случае в качестве разделителя нужно взять пробел " ", а в качестве исходной строки для разбиения - строку флагов поля.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Итак, создадим форму для ввода данных в таблицу Artifacts:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Запись данных в базу данных\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Итак, форма создана. Теперь нужно сделать самое главное - отправить данные из этой формы в нашу базу данных. Как вы уже знаете, для того чтобы записать данные в таблицу, используется команда INSERT языка SQL. Например:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 mysql> INSERT INTO Artifacts \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0            SET title='Петров';\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Возникает вопрос, как можно воспользоваться такой командой (или любой другой командой SQL) в PHP скрипте. Для этого существует функция mysql_query().\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Синтаксис mysql_query\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ресурс mysql_query ( строка query \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     [, ресурс link_identifier])\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 mysql_query() посылает SQL-запрос активной базе данных MySQL сервера, который определяется с помощью указателя link_identifier (это ссылка на какое-то соединение с сервером MySQL). Если параметр link_identifier опущен, используется последнее открытое соединение. Если открытые соединения отсутствуют, функция пытается соединиться с СУБД, аналогично функции mysql_connect() без параметров. Результат запроса буферизируется.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Замечание:\b0   строка запроса НЕ должна заканчиваться точкой с запятой.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Только для запросов SELECT, SHOW, EXPLAIN, DESCRIBE, mysql_query() возвращает указатель на результат запроса, или FALSE, если запрос не был выполнен. В остальных случаях mysql_query() возвращает TRUE, если запрос выполнен успешно, и FALSE - в случае ошибки. Значение, не равное FALSE, говорит о том, что запрос был выполнен успешно. Оно не говорит о количестве затронутых или возвращенных рядов. Вполне возможна ситуация, когда успешный запрос не затронет ни одного ряда. mysql_query() также считается ошибочным и вернет FALSE, если у пользователя недостаточно прав для работы с указанной в запросе таблицей.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Итак, теперь мы знаем, как отправить запрос на вставку строк в базу данных. Заметим, что в предыдущем примере элементы формы мы назвали именами полей таблицы. Поэтому они будут доступны в скрипте insert.php, обрабатывающем данные формы, как переменные вида\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $_POST['имя_поля'].\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Итак, задачу добавления данных с помощью web-интерфейса мы решили. Однако тут есть одна тонкость. При решении мы не учитывали тот факт, что значения некоторых полей (author, photo) должны браться из других таблиц (Persons, Images). Поскольку MySQL с внешними ключами не работает, этот момент остается на совести разработчиков системы, т.е. на нашей совести. Нужно дописать программу таким образом, чтобы была возможность вводить в такие поля правильные значения. Но мы делать этого не будем, поскольку задача лекции состоит в том, чтобы познакомить читателя с элементами технологии, а не в том, чтобы создать работающую систему. Кроме того, имеющихся у читателя знаний вполне достаточно, чтобы решить эту проблему самостоятельно. Мы же обратимся к другой задаче - отображение данных, хранящихся в базе данных СУБД MySQL.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Отображение данных, хранящихся в MySQL\b0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Чтобы отобразить какие-то данные в браузер с помощью PHP, нужно сначала получить эти данные в виде переменных PHP. При работе с MySQL без посредника (такого, как PHP) выборка данных производится с помощью команды SELECT языка SQL:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 mysql> SELECT * FROM Artifacts;\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В предыдущей главе мы говорили, что любой запрос, в том числе и на выборку, можно отправить на сервер с помощью функции mysql_query(); Там у нас стояла немного другая задача - получить данные из формы и отправить их с помощью запроса на вставку в базу данных. Результатом работы mysql_query() там могло быть только одно из выражений, TRUE или FALSE. Теперь же требуется отправить запрос на выбор всех полей, а результат отобразить в браузере. И здесь результат - это целая таблица значений, а точнее, указатель на эту таблицу. Так что нужны какие-то аналоги функции mysql_field_name(), только чтобы они извлекали из результата запроса не имя, а значение поля. Таких функций в PHP несколько. Наиболее популярные - mysql_result() и mysql_fetch_array().\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Синтаксис mysql_result\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 смешанное mysql_result (ресурс result, \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     целое row [, смешанное field])\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 mysql_result() возвращает значение одной ячейки результата запроса. Аргумент field может быть порядковым номером поля в результате, именем поля или именем поля с именем таблицы через точку tablename.fieldname. Если для имени поля в запросе применялся алиас ('select foo as bar from...'), используйте его вместо реального имени поля.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Работая с большими результатами запросов, следует задействовать одну из функций, обрабатывающих сразу целый ряд результата (например, mysql_fetch_row(), mysql_fetch_array() и т.д.). Так как эти функции возвращают значение нескольких ячеек сразу, они НАМНОГО быстрее mysql_result(). Кроме того, нужно учесть, что указание численного смещения (номера поля) работает намного быстрее, чем указание колонки или колонки и таблицы через точку.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Вызовы функции mysql_result() не должны смешиваться с другими функциями, работающими с результатом запроса.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Синтаксис mysql_fetch_array\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 массив mysql_fetch_array ( ресурс result \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     [, целое result_type])\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эта функция обрабатывает ряд результата запроса, возвращая массив (ассоциативный, численный или оба) с обработанным рядом результата запроса, или FALSE, если рядов больше нет.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 mysql_fetch_array() - это расширенная версия функции mysql_fetch_row(). Помимо хранения значений в массиве с численными индексами, функция возвращает значения в массиве с индексами по названию колонок.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если несколько колонок в результате будут иметь одинаковые названия, будет возвращена последняя колонка. Чтобы получить доступ к первым, следует использовать численные индексы массива или алиасы в запросе. В случае алиасов именно их вы не сможете использовать настоящие имена колонок, как, например, не сможете использовать "photo" в описанном ниже примере.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 select Artifacts.photo as art_image, \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     Persons.photo as pers_image \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    from Artifacts, Persons\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Важно заметить, что mysql_fetch_array() работает НЕ медленнее, чем mysql_fetch_row(), и предоставляет более удобный доступ к данным.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Второй опциональный аргумент result_type в функции mysql_fetch_array() является константой и может принимать следующие значения: MYSQL_ASSOC, MYSQL_NUM и MYSQL_BOTH. Эта возможность добавлена в PHP 3.0.7. Значением по умолчанию является: MYSQL_BOTH.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Используя MYSQL_BOTH, получим массив, состоящий как из ассоциативных индексов, так и из численных. MYSQL_ASSOC вернет только ассоциативные соответствия, а MYSQL_NUM - только численные.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Замечание:\b0   имена полей, возвращаемые этой функцией, регистрозависимы.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь отобразим данные из Artifacts в виде таблицы в браузере:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Сделаем то же самое с помощью mysql_fetch_array():\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Заключение\b0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В этой лекции мы решили две задачи: добавление данных в базу данных и их отображение в браузере с помощью языка PHP. Для этого мы рассмотрели ряд функций, которые позволяют отправлять SQL-запросы к базе данных и обрабатывать полученные ответы. Используя приведенную здесь технологию, можно решить целый ряд похожих задач, таких как задачи изменения и удаления данных, задачи манипулирования таблицами базы данных (т.е. их создание, изменение и удаление) и т.п. Все это типовые задачи, возникающие при разработке систем управления данными, и умение их решать, как и умение работать с базами данных в целом, очень важно для web-программиста.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Авторизация доступа с помощью сессий\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В этой лекции мы разберем, что такое сессии и в чем их специфика в PHP, решим одну из основных задач, возникающих при построении более-менее сложных информационных систем (сайтов) - задачу авторизации доступа пользователей к ресурсам системы, а также обсудим безопасность построенного решения.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Авторизация доступа\b0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Что такое авторизация доступа? Попробуем объяснить на примере из обычной жизни. Вы хотите взять в библиотеке книгу. Но эта услуга доступна только тем, у кого есть читательский билет. Можно сказать, что с помощью этого билета производится "авторизация доступа" к библиотечным ресурсам. Библиотекарь после предъявления ему читательского билета знает, кто берет книгу, и в случае необходимости (например, книгу долго не возвращают) может принять меры (позвонить должнику домой). Библиотекарь имеет гораздо больше прав, чем обычный посетитель: он может давать или не давать книги определенному посетителю, может выставлять напоказ новинки и убирать в архив редко читаемые книги и т.п.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В информационных технологиях все примерно так же. В сети существует огромное количество ресурсов, т.е. множество "библиотек". У каждой из них свой "библиотекарь", т.е. человек или группа людей, отвечающих за содержание ресурса и предоставление пользователям информации. Их называют администраторами. Функции администратора, как правило, включают добавление новой информации, удаление и редактирование существующей, настройка способов отображения информации пользователю. А в функции пользователя (простого посетителя ресурса) входит только поиск и просмотр информации.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Как же отличить пользователя от администратора? В реальной библиотеке это как-то очевидно, но если роли библиотекаря и посетителя библиотеки перенести в виртуальную реальность, то эта очевидность исчезает. Библиотекарь, как и посетитель, имеет доступ к библиотечным ресурсам через Internet. А согласно протоколу HTTP все клиенты абсолютно равноправны. Как же понять, кто зашел на сайт? Обычный пользователь (посетитель) или администратор (библиотекарь)? Если это простой пользователь, то как сохранить это знание, чтобы не допустить посетителя в закрытые архивы сайта? То есть возникает вопрос, как идентифицировать клиента, который послал запрос, и сохранять сведения о нем, пока он находится на сайте?\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Самый простой вариант, который приходит в голову, - это регистрация человека в системе и выдача ему аналога читательского билета, а именно логина и пароля для входа в административную часть системы. Эта информация хранится на компьютере-сервере, и при входе в систему проверяется соответствие введенных пользователем логина и пароля тем, что хранятся в системе. Правда, здесь по сравнению с реальной библиотекой ситуация изменяется: читательский билет требуется библиотекарю для входа в закрытую часть системы, а читатель может заходить на сайт свободно. В принципе можно регистрировать и простых посетителей. Тогда всех зарегистрированных пользователей нужно разделить на группы: библиотекари (администраторы) и читатели (простые пользователи), наделив их соответствующими правами. Мы не будем вдаваться в эти тонкости и воспользуемся самым простым вариантом, когда ввод логина и пароля требуется для доступа к некоторым страницам сайта.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Пример 12.1.\b0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 У нас имеется файл index.html - домашняя страничка Васи Петрова\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <html>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <head><title>My home page</title></head>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <body>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Привет всем! \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Меня зовут Вася Петров и \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 это моя домашняя страничка.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <a href="secret_info.html">Для Пети</a>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 </body></html>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 и файл secret_info.html, который содержит секретную информацию, читать которую разрешено только Васиному другу Пете.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <html>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <head><title>Secret info</title></head>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <body>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Здесь я хочу делиться секретами \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 с другом Петей.</p>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 </body></html>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если оставить оба эти файла как есть, то любой посетитель, кликнув на ссылку "Для Пети", попадет на секретную страничку. Чтобы этого избежать, нужно добавить промежуточный скрипт, который будет проверять, действительно ли Петя хочет попасть на секретную страничку. И сделать так, чтобы главный файл ссылался не сразу на secret_info.html, а сначала на этот скрипт.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <html>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <head><title>My home page</title></head>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <body>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <p>Привет всем! \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Меня зовут Вася Петров и \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 это моя домашняя страничка.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 </p>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <a href="authorize.php">Для Пети</a>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 </body>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 </html>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Сам скрипт авторизации должен предоставлять форму для ввода логина и пароля, проверять их правильность и перенаправлять на секретную страничку, если проверка прошла успешно, и выдавать сообщение об ошибке в противном случае.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 if (!isset($_GET['go']))\{   \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // проверяем, отправлены ли данные формой\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     echo "<form> \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // форма для авторизации \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     //(ввода логина и пароля)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     Login: <input type=text name=login>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     Password: <input type=password \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                         name=passwd>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     <input type=submit name=go value=Go>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     </form>";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \}else \{ \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // если форма заполнена, то сравниваем логин\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // и пароль с правильными логином и  паролем\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     if ($_GET['login']=="pit" && \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         $_GET['passwd']=="123") \{ \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     Header("Location: secret_info.html");\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     //и перенаправляем на секретную страницу\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     \}else echo "Неверный ввод, \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                 попробуйте еще раз<br>";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Вроде бы все достаточно просто. Но допустим, у нас не одна секретная страничка, а несколько. Причем они связаны между собой перекрестными ссылками. Тогда возникает необходимость постоянно помнить пароль и логин посетителя сайта (если он таковой имеет). Чтобы решить эту проблему, можно в каждую страницу встроить скрипт, который будет передавать логин и пароль от страницы к странице в качестве скрытых параметров формы. Но такой способ не совсем безопасен: эти параметры можно перехватить и подделать. В PHP существует более удобный и безопасный метод решения проблемы хранения данных о посетителе в течение сеанса его работы с сайтом - это механизм сессий.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Механизм сессий\b0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Cессии - это механизм, который позволяет создавать и использовать переменные, сохраняющие свое значение в течение всего времени работы пользователя с сайтом.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эти переменные для каждого пользователя имеют различные значения и могут использоваться на любой странице сайта до выхода пользователя из системы. При этом каждый раз, заходя на сайт, пользователь получает новые значения переменных, позволяющие идентифицировать его в течение этого сеанса или сессии работы с сайтом. Отсюда и название механизма - сессии.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Задача идентификации пользователя решается путем присвоения каждому пользователю уникального номера, так называемого идентификатора сессии (SID, Session IDentifier). Он генерируется PHP в тот момент, когда пользователь заходит на сайт, и уничтожается, когда пользователь уходит с сайта, и представляет собой строку из 32 символов (например, ac4f4a45bdc893434c95dcaffb1c1811). Этот идентификатор передается на сервер вместе с каждым запросом клиента и возвращается обратно вместе с ответом сервера.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Существует несколько способов передачи идентификатора сессии:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 С помощью cookies.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Cookies были созданы специально как метод однозначной идентификации клиентов и представляют собой расширение протокола HTTP. В этом случае идентификатор сессии сохраняется во временном файле на компьютере клиента, пославшего запрос. Метод, несомненно, хорош, но многие пользователи отключают поддержку cookies на своем компьютере из-за проблем с безопасностью.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 С помощью параметров командной строки.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В этом случае идентификатор сессии автоматически встраивается во все запросы (URL), передаваемые серверу, и хранится на стороне сервера.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Например: адрес http://green.nsu.ru/test.php превращается в адрес http://green.nsu.ru/test.php?PHPSESSID=ac4f4a45bdc893434c95dcaffb1c1811\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Этот способ передачи идентификатора используется автоматически, если у браузера, отправившего запрос, выключены cookies. Он достаточно надежный - передавать параметры в командной строке можно всегда. С другой стороны, идентификатор сессии можно подглядеть, воспользоваться сохраненным вариантом в строке браузера или подделать. Хотя, конечно, все эти проблемы либо надуманны либо их можно решить. Например, кто сможет запомнить строку из 32 различных символов? А если правильно организовать работу с сессиями (вовремя их уничтожать), то даже сохранившийся в браузере номер сессии ничего не даст. К вопросам безопасности мы еще вернемся в конце лекции.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Кроме перечисленных вариантов передачи идентификатора сессии, известно еще несколько, но мы их рассматривать не будем ввиду их сложности.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Настройка сессий\b0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Прежде чем начать работать с сессиями, следует разобраться в том, как корректно настраивать их обработку интерпретатором PHP. Сама работа с сессиями в PHP поддерживается по умолчанию. Это значит, что устанавливать никаких дополнительных элементов не нужно. А вот знать, что записано в настройках этого модуля, полезно, чтобы избежать ошибок при работе с ним.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Настройки PHP, в том числе и для работы с сессиями, прописываются в файле php.ini. Обратимся к этому файлу.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Как мы уже знаем, идентификатор сессии (число, по которому можно уникально идентифицировать клиента, пославшего запрос) сохраняется либо на компьютере-сервере, либо на компьютере-клиенте, либо и там, и там.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Параметр session.save_path в php.ini, определяет, где на сервере будут храниться данные сессии. Из-за него чаще всего возникают проблемы для Windows-серверов, потому что по умолчанию значение session.save_path установлено в /tmp. И если в корневой директории сервера такой папки нет, то при запуске сессий будет выдаваться ошибка.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Сервер может обрабатывать большое количество сессий одновременно, и все их временные файлы будут храниться в директории, заданной параметром session.save_path. Если система плохо работает с папками большого размера, то удобно использовать поддиректории. Для этого, кроме названия папки, в значение параметра добавляют еще и число, определяющее глубину вложенности поддиректорий в этой папке: N;/dir. Это значение нужно обязательно взять в кавычки, поскольку точка с запятой является одним из символов комментариев в файле настроек PHP. Все директории и поддиректории для хранения данных сессии нужно создать самостоятельно.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Например: 2;/Temp определяет, что переменные сессий будут храниться в папках вида c:\\Temp\\0\\a\\, c:\\Temp\\0\\b\\ и т.п.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Хранение данных на стороне клиента осуществляется с помощью cookies. Работу PHP с cookies можно настроить, в частности, с помощью параметров session.use_cookies, session.cookie_lifetime и т.п.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Параметр session.use_cookies определяет, использовать ли cookies при работе с сессиями. По умолчанию эта опция включена (т.е. принимает значение "1").\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Параметр session.cookie_lifetime задает длительность жизни cookies в секундах. По умолчанию это "0", т.е. данные в cookies считаются правильными до закрытия окна браузера.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Кроме этих параметров, полезными могут оказаться session.name, определяющий имя сессии, session.auto_start, позволяющий автоматически запускать сессии, session.serialize_handler, задающий способ кодировки данных сессии, и параметр session.cache_expire, определяющий, через сколько минут устаревает документ в кэше.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Имя сессии  session.name по умолчанию устанавливается как PHPSESSID и используется в cookies как имя переменной, в которой хранится идентификатор сессии. Автоматический запуск сессий по умолчанию отключен, но его можно задать, сделав значение session.auto_start равным "1". Для кодирования данных сессии по умолчанию используется php. Устаревание данных, сохраненных в кэше, происходит через 180 минут.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Существует еще множество настроек, с которыми можно познакомиться в документации или непосредственно в файле настроек php.ini. На наш взгляд, знакомства с перечисленными выше параметрами достаточно для работы с сессиями в PHP. Так что приступим.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Работа с сессиями\b0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Создание сессии\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Первое, что нужно сделать для работы с сессиями (если они уже настроены администратором сервера), это запустить механизм сессий. Если в настройках сервера переменная session.auto_start установлена в значение "0" (если session.auto_start=1, то сессии запускаются автоматически), то любой скрипт, в котором нужно использовать данные сессии, должен начинаться с команды\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 session_start();\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Получив такую команду, сервер создает новую сессию или восстанавливает текущую, основываясь на идентификаторе сессии, переданном по запросу. Как это делается? Интерпретатор PHP ищет переменную, в которой хранится идентификатор сессии (по умолчанию это PHPSESSID) сначала в cookies, потом в переменных, переданных с помощью POST- и GET-запросов. Если идентификатор найден, то пользователь считается идентифицированным, производится замена всех URL и выставление cookies. В противном случае пользователь считается новым, для него генерируется новый уникальный идентификатор, затем производится замена URL и выставление cookies.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Команду session_start() нужно вызывать во всех скриптах, в которых предстоит использовать переменные сессии, причем до вывода каких-либо данных в браузер. Это связано с тем, что cookies выставляются только до вывода информации на экран.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Получить идентификатор текущей сессии можно с помощью функции session_id().\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для наглядности сессии можно задать имя с помощью функции session_name([имя_сессии]). Делать это нужно еще до инициализации сессии. Получить имя текущей сессии можно с помощью этой же функции, вызванной без параметров: session_name();\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Пример 12.2.\b0   Создание сессии\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Переименуем наш файл index.html, чтобы обрабатывались php-скрипты, например в Index.php, создадим сессию и посмотрим, какой она получит идентификатор и имя.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 session_start(); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // создаем новую сессию или\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // восстанавливаем текущую\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo session_id(); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // выводим идентификатор сессии\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <html>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <head><title>My home page</title></head>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ... // домашняя страничка\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 </html>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo session_name(); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // выводим имя текущей сессии. \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // В данном случае это PHPSESSID \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если проделать то же самое с файлом authorize.php, то значения выводимых переменных (id сессии и ее имя) будут такими же, если перейти на него с index.php и не закрывать перед этим окно браузера (тогда идентификатор сессии изменится).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Регистрация переменных сессии\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Однако от самих идентификатора и имени сессии нам пользы для решения наших задач немного. Мы же хотим передавать и сохранять в течение сессии наши собственные переменные (например, логин и пароль). Для того чтобы этого добиться, нужно просто зарегистрировать свои переменные:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 session_register(имя_переменной1, \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                  имя_переменной2, ...);\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Заметим, что регистрируются не значения, а имена переменных. Зарегистрировать переменную достаточно один раз на любой странице, где используются сессии. Имена переменных передаются функции session_register() без знака $. Все зарегистрированные таким образом переменные становятся глобальными (т.е. доступными с любой страницы) в течение данной сессии работы с сайтом.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Зарегистрировать переменную также можно, просто записав ее значение в ассоциативный массив $_SESSION, т.е. написав\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $_SESSION['имя_переменной'] = \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0        'значение_переменой';\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В этом массиве хранятся все зарегистрированные (т.е. глобальные) переменные сессии.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Доступ к таким переменным осуществляется с помощью массива $_SESSION['имя_переменной'] (или $HTTP_SESSION_VARS['имя_переменной'] для версии PHP 4.0.6 и более ранних). Если же в настройках php включена опция register_globals, то к сессионным переменным можно обращаться еще и как к обычным переменным, например так: $имя_переменной.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если register_globals=off (отключены), то пользоваться session_register() для регистрации переменных переданных методами POST или GET, нельзя, т.е. это просто не работает. И вообще, не рекомендуется одновременно использовать оба метода регистрации переменных, $_SESSION и session_register().\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Пример 12.3.\b0   Регистрация переменных\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Зарегистрируем логин и пароль, вводимые пользователем на странице авторизации.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 session_start();\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // создаем новую сессию или \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // восстанавливаем текущую\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 if (!isset($_GET['go']))\{\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   echo "<form>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     Login: <input type=text name=login>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     Password: <input type=password \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                         name=passwd>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     <input type=submit name=go value=Go>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   </form>";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \}else \{\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    $_SESSION['login']=$_GET['login']; \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    // регистрируем переменную login\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    $_SESSION['passwd']=$_GET['passwd']; \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    // регистрируем переменную passwd\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // теперь логин и пароль - глобальные \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // переменные для этой сессии\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     if ($_GET['login']=="pit" && \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         $_GET['passwd']=="123") \{\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         Header("Location: secret_info.php"); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         // перенаправляем на страницу \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         // secret_info.php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     \}else echo "Неверный ввод, \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                 попробуйте еще раз<br>";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 print_r($_SESSION); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // выводим все переменные сессии\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь, попав на страничку secret_info.php, да и на любую другую страницу сайта, мы сможем работать с введенными пользователем логином и паролем, которые будут храниться в массиве $_SESSION. Таким образом, если изменить код секретной странички (заметьте, мы переименовали ее в secret_info.php) так:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 session_start(); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // создаем новую сессию или \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // восстанавливаем текущую\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 print_r($_SESSION); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // выводим все переменные сессии\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <html>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <head><title>Secret info</title></head>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <body>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <p>Здесь я хочу делиться секретами \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 с другом Петей.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 </body>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 </html>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 То мы получим в браузере на секретной странице следующее:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Array ( [login] => pit [passwd] => 123 )\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Здесь я хочу делиться секретами \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 с другом Петей. \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В итоге получим список переменных, зарегистрированных на authorize.php и, собственно, саму секретную страничку.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Что это нам дает? Допустим, хакер хочет прочитать секреты Васи и Пети. И он как-то узнал, как называется секретная страничка (или странички). Тогда он может попытаться просто ввести ее адрес в строке браузера, минуя страницу авторизации (ввода пароля). Чтобы избежать такого проникновения в наши тайны, нужно дописать всего пару строк в код секретных страничек:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 session_start(); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // создаем новую сессию или \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // восстанавливаем текущую\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 print_r($_SESSION); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // выводим все переменные сессии\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 if (!($_SESSION['login']=="pit" && \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     $_SESSION['passwd']==123))  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // проверяем правильность \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // пароля-логина\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     Header("Location: authorize.php"); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // если ошибка, то перенаправляем на \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // страницу авторизации\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <html>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <head><title>Secret info</title></head>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ... // здесь располагается \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     //секретная информация :)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 </html>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Удаление переменных сессии\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Кроме умения регистрировать переменные сессии (т.е. делать их глобальными на протяжении всего сеанса работы), полезно также уметь удалять такие переменные и сессию в целом.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Функция session_unregister(имя_переменной) удаляет глобальную переменную из текущей сессии (т.е. удаляет ее из списка зарегистрированных переменных). Если регистрация производилась с помощью $_SESSION ($HTTP_SESSION_VARS для версии PHP 4.0.6 и более ранних), то используют языковую конструкцию unset(). Она не возвращает никакого значения, а просто уничтожает указанные переменные.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Где это может пригодиться? Например, для уничтожения данных о посетителе (в частности, логина и пароля) после его ухода с секретной странички. Если правильные логин и пароль сохранятся и окно браузера после посещения сайта не закрыли, то любой другой пользователь этого компьютера сможет прочитать закрытую информацию.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Пример 12.4.\b0   Уничтожение переменных сессии\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В файл secret_info.php добавим строчку для выхода на главную страницу:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // ... php код \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <html>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <head><title>Secret info</title></head>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ... // здесь располагается \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // секретная информация :)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <a href="index.php">На главную</a>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 </html>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В Index.php уничтожим логин и пароль, введенные ранее:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 session_start();\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 session_unregister('passwd'); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // уничтожаем пароль\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 unset($_SESSION['login']); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // уничтожаем логин\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 print_r($_SESSION); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // выводим глобальные переменные сессии\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <html>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <head><title>My home page</title></head>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ... // домашняя страничка\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 </html>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь, чтобы попасть на секретную страницу, нужно будет опять вводить логин и пароль.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для того чтобы сбросить значения всех переменных сессии, можно использовать функцию session_unset();\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Уничтожить текущую сессию целиком можно командой session_destroy(); Она не сбрасывает значения глобальных переменных сессии и не удаляет cookies, а уничтожает все данные, ассоциируемые с текущей сессией.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 session_start(); // инициализируем сессию\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $test = "Переменная сессии";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $_SESSION['test']= $test; \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // регистрируем переменную $test.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // если register_globals=on, \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // то можно использовать \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // session_register('test');\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 print_r($_SESSION); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // выводим все глобальные переменные \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo session_id(); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // выводим идентификатор сессии\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo "<hr>";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 session_unset(); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // уничтожаем все глобальные \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // переменные сессии\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 print_r($_SESSION);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo session_id();\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo "<hr>";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 session_destroy(); // уничтожаем сессию\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 print_r($_SESSION);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo session_id();\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В результате работы этого скрипта будут выведены три строки: в первой - массив с элементом test и его значением, а также идентификатор сессии, во второй - пустой массив и идентификатор сессии, в третьей - пустой массив. Таким образом, видно, что после уничтожения сессии уничтожается и ее идентификатор, и мы больше не можем ни регистрировать переменные, ни вообще производить какие-либо действия с сессией.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Безопасность\b0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Вообще говоря, cледует понимать, что использование механизма сессий не гарантирует полной безопасности системы. Для этого нужно принимать дополнительные меры. Обратим внимание на проблемы с безопасностью, которые могут возникнуть при работе с сессиями и, в частности, с теми программами, что мы написали.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Во-первых, опасно передавать туда-сюда пароль, его могут перехватить. Кроме того, мы зарегистрировали его как глобальную переменную сессии, значит, он сохранился в cookies на компьютере-клиенте. Это тоже плохо. И вообще, пароли и логины по-хорошему должны храниться в базе данных. Пусть информация о пользователях хранится в базе данных "test" (в таблице "users"), а мы имеем к ней доступ под логином my_user и паролем my_passwd.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Во-вторых, что делать, если кто-то написал скрипт подбора пароля для секретной страницы? В этом случае на страницу авторизации много раз должен стучаться какой-то посторонний скрипт. Поэтому нужно просто проверять, с нашего ли сайта пришел запрос на авторизацию, и если нет, то не пускать его дальше. Адрес страницы, с которой поступил запрос, можно получить с помощью глобальной переменной $_SERVER['HTTP_REFERER']). Хотя, конечно, если за взлом сайта взялись всерьез, то значение этой переменной тоже подменят (например, с помощью того же PHP). Тем не менее проверку ее значения можно считать одним из важнейших шагов на пути к обеспечению безопасности своего сайта.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Вроде бы первые две проблемы решены. Но есть еще одна. Что делать, если хакер просто допишет в строку запроса значение какой-нибудь глобальной переменной (например, логина)? Вообще это возможно, только если register_globals=On. Просто иначе мы используем для работы с глобальными переменными массив $_SESSION и с ним такие фокусы не проходят. Все же попробуем решить и эту проблему. Для этого нужно очистить строку запроса перед тем, как сравнивать значения параметров. То есть сначала сбросим значение $user_login. Потом данную переменную нужно опять зарегистрировать, но не как новую, а как уже существующую. Для этого знак доллара при регистрации НЕ опускается. Вот что получилось:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 unset($user_login); // уничтожаем переменную\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 session_start(); // создаем новую сессию или\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                  // восстанавливаем текущую\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 session_register($user_login);  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // регистрируем переменную \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // как уже существующую\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 if (!($user_login=="pit")) // проверяем логин\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     Header("Location: authorize.php"); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // если ошибка, то перенаправляем \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // на страницу авторизации\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <html>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <head><title>Secret info</title></head>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ... // здесь располагается \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // секретная информация :)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 </html>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Заключение\b0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Итак, мы познакомились с сессиями и основными способами работы с ними, проблемами, возникающими при их использовании, и возможными решениями этих проблем. Надеюсь, что после прочтения лекции читателям стало ясно, насколько удобны и просты в использовании сессии, а приведенные примеры пригодятся на практике.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Регулярные выражения\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Понятие регулярного выражения\b0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Регулярное выражение (regular expression, сокращенно РВ) – это технология, которая позволяет задать шаблон и осуществить поиск данных, соответствующих этому шаблону, в заданном тексте, представленном в виде строки.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Кроме того, с помощью регулярных выражений можно изменить и удалить данные, разбить строку по шаблону на подстроки и многое другое.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Одно из распространенных применений РВ – это проверка строки на соответствие каким-либо правилам. Например, следующее РВ предназначено для проверки того, что строка содержит корректный e-mail–адрес:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 /^\\w+([\\.\\w]+)*\\w@\\w((\\.\\w)*\\w+)*\\.\\w\{2,3\}$/\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Выглядит, конечно, жутко, но зато работает. И если уметь пользоваться этим механизмом виртуозно, то жить становится легче.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Вернемся к нашему определению РВ. В нем несколько раз повторяется термин «шаблон». Что это такое? В принципе, интуитивно понятно, но попробуем все же пояснить.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Давайте подумаем, что представляет собой корректный e-mail–адрес. Это набор букв, цифр и символов подчеркивания, после которых идет специальный символ «собака» @, затем еще один такой же набор, содержащий имя сервера, точку (.) и две или три буквы, указывающие на зону домена, к которой принадлежит почтовый ящик (ru, com, org и т.д.). Приведенное выше РВ формализует данное описание на языке, понятном компьютеру. И описывает не какой-то конкретный электронный адрес, а все возможные корректные электронные адреса. Таким образом, производится формальное задание множества правильных e-mail'ов с помощью шаблона регулярного выражения. Другие примеры шаблонов – это шаблоны MS Word и html-формы.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Механизм регулярных выражений задает правила построения шаблонов и осуществляет поиск данных по этому шаблону в указанной строке.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В дальнейшем изложении термины РВ и «шаблон» часто будут использоваться как синонимы, но важно понимать, что это не совсем одно и то же. Шаблон задает какой-то тип данных, а РВ – это механизм, который производит поиск и включает в себя шаблон и опции поиска, а также задает язык написания шаблонов.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Регулярные выражения в PHP\b0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Регулярные выражения пришли из UNIX и Perl. Как упоминалось выше, с помощью регулярных выражений можно искать и изменять текст, разбивать строку на подстроки и т.д. В PHP существуют такие удобные и мощные средства работы со строками, как explode (разбиение строки на подстроки), strstr (нахождение подстроки), str_replace (замена всех вхождений подстроки). Возникает вопрос – зачем придумывать что-то еще?\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Основное преимущество РВ заключается в том, что они позволяют организовать более гибкий поиск, т.е. найти то, о чем нет точного знания, но есть примерное представление. Например, нужно найти все семизначные номера телефонов, встречающиеся в тексте. Мы не ищем какой-то заранее известный нам номер телефона, мы знаем только, что искомый номер состоит из семи цифр. Для этого можно воспользоваться следующим РВ:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 /\\d\{3\}-\\d\{2\}-\\d\{2\}/m\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В PHP существует два различных механизма для обработки регулярных выражений: POSIX-совместимые и Perl-совместимые (сокращенно PCRE). Их синтаксис во многом похож, однако Perl-совместимые регулярные выражения более мощные и к тому же работают намного быстрее. Начиная с версии PHP 4.2.0, PCRE входят в набор базовых модулей и подключены по умолчанию. POSIX-совместимые РВ  включены по умолчанию только в версию PHP для Windows.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Основные функции для работы с Perl-совместимыми регулярными выражениями: preg_match(pattern, string, [result, flags]) и preg_match_all(pattern, string, result, [flags])>, где:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 pattern  – шаблон регулярного выражения;\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 string  – строка, в которой производится поиск;\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 result  – содержит массив результатов (нулевой элемент массива содержит соответствие всему шаблону, первый – первому «захваченному» подшаблону и т.д.);\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 flags   – необязательный параметр, определяющий то, как упорядочены результаты поиска.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эти функции осуществляют поиск по шаблону и возвращают информацию о том, сколько раз произошло совпадение. Для preg_match() это 0 (нет совпадений) или 1, поскольку поиск прекращается, как только найдено первое совпадение. Функция preg_match_all() производит поиск до конца строки и поэтому находит все совпадения. Все точные совпадения содержатся в первом элементе массива result у каждой из этих функций (для preg_match_all() этот элемент – тоже массив).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Про «захват» элементов будет рассказано в разделе, посвященном подвыражениям.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Аналогом preg_match является булева функция POSIX-расширения ereg(string pattern, string string [, array regs])\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Функция ereg() возвращает TRUE, если совпадение найдено, и FALSE – в противном случае.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Приводимые далее примеры можно тестировать на перечисленных функциях. Например, так:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 //строка, в которой нужно что-то найти\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $str = "Мой телефонный номер: ".\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 "33-22-44. Номер моего редактора: ".\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 "222-44-55 и 323-22-33";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 //шаблон, по которому искать.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 //Задает поиск семизначных номеров.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $pattern = "/\\d\{3\}-\\d\{2\}-\\d\{2\}/m";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 //функция, осуществляющая поиск\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $num_match = preg_match_all ($pattern,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                        $str, $result);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 //вывод результатов поиска\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 for ($i=0;$i<$num_match;$i++) \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     echo "Совпадение $i: ".\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                $result[0][$i]."<br>";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Синтаксис регулярных выражений\b0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Строгое определение регулярного выражения выглядит довольно громоздко. Начнем с неформального описания.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Регулярное выражение представляет собой строку. Эта строка состоит из собственно регулярного выражения (шаблона), выделенного с помощью специального символа разделителя (это могут быть символы «/» , «|», «\{«, «!» и т.п ) и модификатора, влияющего на способ обработки РВ.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В дальнейшем это описание будет расширено.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Например, в регулярном выражении /\\d\{3\}-\\d\{2\}-\\d\{2\}/m символ «/»является разделителем, \\d\{3\}-\\d\{2\}-\\d\{2\} – непосредственно регулярное выражение (шаблон), а m – модификатор.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Мощь регулярных выражений порождена в основе своей их способностью включать в шаблон альтернативы и повторения. Они кодируются в шаблоне с помощью метасимволов. Метасимвол отличается от любого другого символа тем, что имеет специальное значение.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Одним из основных метасимволов является обратный слэш «\\». Он меняет тип символа, следующего за ним, на противоположный, т.е. если это был обычный символ, то он МОЖЕТ превратиться в метасимвол, если это был метасимвол, то он теряет свое специальное значение и становится обычным символом (это нужно для того, чтобы вставлять в текст специальные символы как обычные). Например, символ d в обычном режиме не имеет никаких специальных значений, но \\d есть метасимвол, означающий «любая цифра». Символ «.» в обычном режиме означает «любой единичный символ», а «\\.» означает просто точку.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Другое назначение обратного слэша – кодирование непечатных символов, таких как :\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \\n  – cимвол перевода строки;\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \\e  – символ escape;\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \\t  – cимвол табуляции;\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \\xhh    – символ в шестнадцатеричном коде, например \\x41 есть буква A и т.д.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Еще одно назначение обратного слэша – обозначение генерируемых символьных типов, таких как:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \\d  – любая десятичная цифра (0-9);\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \\D  – любой символ, не являющийся десятичной цифрой;\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \\s  – любой пустой символ (пробел или табуляция);\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \\S  – любой символ, не являющийся пустым;\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \\w  –  символ, используемый для написания Perl-слов (это буквы, цифры и символ подчеркивания), так называемый «словарный символ»;\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \\W  – несловарный символ (все символы, кроме определяемых \\w).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Что имеется в виду под «символьным типом»? Просто каждый метасимвол принимает значение (одно) из класса возможных значений, заданных автоматически или вручную. Символьные типы, задаваемые пользователем, описываются с помощью квадратных скобок (подробнее об этом позже). Выше приведены символьные типы, диапазон значений которых заранее определен языком программирования.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Пример использования приведенных выше метасимволов:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 /\\d\\d\\d plus \\d is \\w\\w\\w/ \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Это РВ означает: трехзначное число, за которым следует подстрока plus, любая цифра, затем is и слово из трех словарных символов. В частности, данному РВ удовлетворяют строки: «123 plus 3 is sum», «213 plus 4 is 217».\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Вообще различают два множества метасимволов: те, что распознаются в любом месте шаблона, за исключением внутренности квадратных скобок, и те, что распознаются внутри квадратных скобок.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Квадратные скобки [ ] применяются для описания подмножеств и внутри регулярного выражения рассматриваются как один символ, который может принимать значения, перечисленные внутри этих скобок. Однако если первым символом внутри скобок является ^, то значением символьного класса могут быть только символы, НЕ перечисленные внутри скобок.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Примеры:\b0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - Символьный класс [абвгд] задает один из символов а, б, в, г, д, а класс [^абвгд] задает любой символ, кроме а, б, в, г, д.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - Если написать [2бул]ки], то это выражение интерпретируется как один из символов 2, б, у, л, за которым следует строка ки], потому что первая встретившаяся закрывающая квадратная скобка (разбор происходит слева направо) заканчивает определение символьного класса. То есть это РВ совпадет с одной из строк 2ки], бки], уки] или лки].\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - С помощью РВ [0-9А-Яа-я] можно задать любую букву или цифру.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Метасимволы, распознаваемые вне квадратных скобок, можно разделить на группы следующим образом: определяющие положение искомого текста в строке, связанные с подвыражениями, ограничивающие символьный класс, квантификаторы и перечисление альтернатив.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Примеры (^ и $)\b0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $str = "11 aaa bbb ".\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0            "ccc 22 ddd ".\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0               "eee ggg 33";\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \\\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Переходный символ со множеством назначений\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ^\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Отрицание класса, но только если это первый символ (например, «^\\d» задает все, кроме цифр)\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 -\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Задает диапазон символов (например, «0-9» задает все цифры, «A-Z» – все латинские буквы)\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ]\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Вычисляет символьный класс\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Регулярное выражение /\\d\\d/m может быть сопоставлено следующим подстрокам: 11, 22, 33. Если в начале РВ стоит ^, то совпадения ищутся в начале строки, поэтому выражение /^\\d\\d/m найдет только 11.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Когда в конце РВ стоит знак доллара $, поиск производится в конце строки, поэтому выражение /\\d\\d$/m найдет только 33.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Шаблону же /^\\d\\d\\d$/ будет удовлетворять строка, целиком состоящая из трехзначного числа (т.е. она и начинается и заканчивается этим числом).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  -\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 //считываем файл в строку\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $str = file_get_contents('1.htm');\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $pattern = "!^<[^/]+>!mU";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // осуществляем поиск\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $n = preg_match_all ($pattern, \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                      $str, $res);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // выводим результаты \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 for ($i=0;$i<$n;$i++)  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    echo htmlspecialchars($res[0][$i]).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                          "<br>";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \\\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Переходный символ со множеством назначений\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ^\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Объявляет начало объекта (или строки в  многострочном режиме). То есть этот символ определяет, что искомый текст должен находиться в начале строки. Альтернатива: «\\A»\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Объявляет конец объекта (или строки в  многострочном режиме). То есть этот символ определяет, что искомый текст должен находиться в конце строки. Альтернативы: «\\Z», «\\z»\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 .\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Совпадает с любым символом, кроме символа  перевода строки (по умолчанию)\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 [\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Начинает определение символьного класса\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ]\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Заканчивает определение символьного класса\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 |\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Разделяет перечисление альтернативных вариантов\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Начинает подшаблон регулярное (подвыражение)\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 )\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Заканчивает подшаблон\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Расширяет значение «(», квантификаторов 0 или 1, и квантификатор минимизации\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 *\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 0 или больше повторений (квантификатор)\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 +\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 1 или больше повторений (квантификатор)\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \{\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Начинает минимальный/максимальный квантификатор\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \}\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Заканчивает минимальный/максимальный квантификатор\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Шаблон ограничен восклицательными знаками. Первая «^» значит, что мы ищем совпадения в начале строк, потом идет символ «<» – его и ищем в строке, после него должно идти все, что угодно, кроме обратного слэша (конструкция «[^\\]» ), «+» говорит, что стоящий перед ним символ повторяется один и более раз и заканчивается все это символом «>». Таким образом, выделяются все теги в начале строк.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  -\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 //считываем файл в строку\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $str = file_get_contents('1.htm');\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $pattern = "!\\s[А-Яа-я]+".\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  "\\s([А-Я]\\.\\s*)([А-Я]\\.\\s*)$!m";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // шаблон ограничен восклицатель-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // ными знаками, m – модификатор,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // включающий многострочный режим\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // первый \\s означает, что перед \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // фамилией должен идти пустой \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // символ (например, пробел)  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // [А-Яа-я] задает одну из букв  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // алфавита в любом регистре,а в  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // комбинации со знаком плюс \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // определяет,что эта буква \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // повторяется один и более \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // раз следующий \\s означает, что \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // между фамилией  и инициалами \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // должен быть пробел\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // Далее идет подвыражение,  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // определяющее инициалы.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // Это буква от А до Я, после\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // которой стоит точка ('\\.')\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // Экранируем точку, чтобы   \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // избавиться от ее специального   \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // значения. После буквы с точкой \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // может идти или не идти пробел \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // или несколько. Вся конструкция \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // повторяется минимум два раза.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // Последний символ $ означает,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // что фамилия с инициалами\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // должны находиться в конце \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // строки. \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 //осуществляем поиск\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $n = preg_match_all ($pattern,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                      $str, $res);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // выводим результаты\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 for ($i=0;$i<$n;$i++) \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    echo htmlspecialchars($res[0][$i]).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                          "<br>"; \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Примеры ( | и .)\b0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - Пусть имеется некий текст. Нам нужно найти всех упомянутых в нем людей со званиями.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $str = "Доцент Смирнов совершил". \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    "открытие. Его учителем была ".\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      "профессор Иванова. ".\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0        "Этим открытием Смирнов ".\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         "завоевал себе степень ".\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0           "доктора. Раньше он был ".\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0            "только кандидат.";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $pattern = "/(профессор|доцент)".\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0             "\\s[А-Яа-я]+(\\s|\\.)/i";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // осуществляем поиск\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $n = preg_match_all ($pattern, $str,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                                 $res);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // выводим результаты\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 for ($i=0;$i<$n;$i++) \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    echo htmlspecialchars($res[0][$i]).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                          "<br>";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Метасимвол прямая черта « | » позволяет задавать альтернативные варианты. В примере мы хотели найти всех профессоров или доцентов. Для этого было создано подвыражение «(профессор|доцент)». После звания через пробел фамилия человека, которому оно принадлежит, – для этого существует комбинация «\\s[А-Яа-я]+». После фамилии идет либо опять пробел, либо точка, если это конец предложения. Получаем опять два альтернативных варианта: «(\\s|\\.)» (здесь точка экранируется обратным слэшем, чтобы она понималась как обычная точка, без специального значения).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Подвыражения (подшаблоны)\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В нескольких примерах мы уже использовали подвыражения. Настало время разобраться, что же это такое и какими свойствами они обладают\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В РВ подшаблоны выделяют, заключая в круглые скобки. Для их обозначения кроме термина «подшаблон» также используют термин «подвыражение». Подшаблоны могут быть вложенными. Выделение части регулярного выражения в виде регулярного подвыражения делает следующее.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Например, шаблон\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 жар(кое|птица|)\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  -  совпадает с одним из слов «жаркое», «жарптица» и «жар». Тогда как без скобок это было бы «жаркое», «птица» и пустая строка.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Например, имеется такой шаблон:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 победитель получит \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0        ((золотую|позолоченный)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                   (медаль|кубок))\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  -  и строка, в которой ищутся совпадения с этим шаблоном: «победитель получит золотую медаль». Тогда кроме этой фразы будут еще захвачены и выданы как результаты поиска следующие совпадения в подвыражениях: «золотую медаль», «золотую», «медаль», пронумерованные 1, 2, 3 соответственно.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Однако это не всегда удобно. Для того чтобы избавиться от «захватывающего» эффекта подвыражения, после открывающей скобки пишут «?:». Тогда это подвыражение в результат поиска не включается и при нумерации остальных подшаблонов с «захватывающим» эффектом не учитывается.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 победитель получит \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0       ((?:золотую|позолоченный)\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                   (медаль|кубок))\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Тогда в условиях предыдущего примера получим искомую строку «победитель получит золотую медаль» и строки «золотую медаль», «медаль», пронумерованные 1 и 2 соответственно.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если в html-файле название находится после <body> и отделено от него только пробелами или переводами строк, заключено в тег <h1> и после него тоже может идти сколько-то пробелов и переводов строк, то его можно найти с помощью следующего скрипта:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 //считываем файл в строку\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $str = file_get_contents('1.htm');\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $pattern = "/<body.*?>[\\n\\s]*<h1>".\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0               "(.*?)<\\/h1>[\\n\\s]*/m";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // осуществляем поиск\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $n = preg_match_all ($pattern, $str, $res);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo $res[1][0]; // выводим заголовок\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Заметим, что здесь выводится первое захваченное подвыражение, поскольку нам интересно только само название, а не все РВ. Так как в этом РВ есть только одно подвыражение, то его значение содержится в нулевом элементе первого массива результатов.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Повторения (квантификаторы)\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В предыдущих примерах мы часто писали комбинации типа \\d\\d. Это значит, что цифра должна повторяться два раза. А что же делать, если повторений очень много или мы не знаем, сколько именно? Оказывается, нужно использовать специальные метасимволы.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Повторения описываются с помощью так называемых квантификаторов (метасимволов, задающих количественные отношения). Существует два типа квантификаторов: общие (задаются с помощью фигурных скобок) и сокращенные (это исторически сложившиеся сокращения наиболее распространенных квантификаторов).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Квантификаторы могут следовать за любым из перечисленных элементов:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - одиночный символ (возможно, в комбинации с обратным слэшем);\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - метасимвол «точка»;\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - символьный класс;\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - обратная ссылка (о них расскажем позднее);\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - подшаблон.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Общие квантификаторы задают минимальное и максимальное число дозволенных повторений элемента; эти два числа, разделенные запятой, заключаются в фигурные скобки. Числа не должны превышать 65 536 и первое число должно быть меньше или равно второму. Например,\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 x\{1,3\}\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 говорит о том, что символ «x» должен повторяться минимум один, а максимум три раза. Соответственно этому шаблону удовлетворяют строки: x, xx, xxx.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если второй параметр отсутствует, но запятая есть, то повторений может быть сколько угодно. Таким образом,\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 [aeuoi]\{2,\}\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 значит, что любой из символов «a», «e», «u», «o», «i» в строке может повторяться два и более раз, а регулярное выражение\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \\d\{3\}\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 задает ровно три цифры.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Сокращенные квантификаторы задают наиболее используемые количественные отношения (повторения). Они придуманы для удобства, чтобы не перегружать и без того сложные выражения лишним синтаксисом.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Исходя из исторических традиций три наиболее часто встречающихся квантификатора имеют следующие обозначения:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 * эквивалентно \{0,\}     – то есть это ноль и более повторений;\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 + эквивалентно \{1,\}     – то есть это одно и более повторений;\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ? эквивалентно \{0,1\}    – то есть это ноль или одно повторение.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Есть еще один важный момент, на который стоит обратить внимание при изучении квантификаторов. По умолчанию все квантификаторы «жадные», они стараются захватить как можно больше повторений элемента. То есть если указать, что символ должен повторяться один и более раз (например, с помощью *), совпадение произойдет со строкой, содержащей наибольшее число повторений указанного символа. Это может создать проблемы, например, при попытке выделить комментарии в программе на языке Cи или PHP. Комментарии в Cи и PHP записываются между символами /* и */, внутри которых тоже могут встречаться символы * и /. И попытка выявить Си-комментарии с помощью шаблона\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 /\\* .* \\*/\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 в строке\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 /* первый комментарий */ \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      не комментарий \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 /* второй комментарий */\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 не увенчается успехом из-за «жадности» элемента «.*» (будет найдена также строка «не комментарий»).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для решения этой проблемы нужно написать знак вопроса после квантификатора. Тогда он перестанет быть «жадным» и попытается захватить как можно меньшее число повторений элемента, к которому он применен (квантификатор применяется к элементу, что стоит перед ним). Так что шаблон\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 /\\* .*? \\*/\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 успешно выделяет Си-комментарии.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В PHP существует опция PCRE_UNGREEDY, которая делает все квантификаторы «не жадными» по умолчанию и «жадными», если после них идет знак вопроса.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 //Рассмотрим html-файл, где имеется \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 //следующая строка:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $str = "<div id=1>Привет</div> ".\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    "<p>Текст, не заключенный в тег ".\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         "div</p><div id=2>Пока</div>";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // Если мы хотим найти текст,  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // содержащийся между тегами div, \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // естественно написать такой шаблон:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $pattern = "!<div id=1>.*</div>!si";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // Но этот шаблон слишком "жадный"  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // и захватит также и текст, \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // заключенный в нашем примере между \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // тегами <p>. Чтобы этого избежать, \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // нужно написать следующий шаблон, \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // отличающийся только наличием знака \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // вопроса, который запрещает \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // квантификатору быть "жадным".\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $pattern1 = "!<div id=1>.*?</div>!si";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // Запускаем поиск в строке $str\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // совпадений с шаблонами \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // $pattern и $pattern1\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $s = preg_match_all ($pattern, $str,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                                 $res);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $js = preg_match_all ($pattern1,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                          $str, $res1);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 //выводим результаты поиска\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // функция htmlspecialchars позволяет \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // выводить html без \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // его обработки браузером\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo "Жадный шаблон:". \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0        htmlspecialchars($res[0][0]).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                                "<br>";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo "Нежадный шаблон:".\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         htmlspecialchars($res1[0][0]);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Результаты работы скрипта:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 «Жадный» шаблон:<div id=1>Привет</div> \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <p>Текст,не заключенный в тег div</p>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <div id=2>Пока</div> \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 «Нежадный» шаблон:<div id=1>Привет</div> \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь мы в принципе можем решить задачу выделения содержания из html-файла, если оно заключено в теге <div id=content>. Предлагаем читателям проделать это самостоятельно.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Модификаторы PCRE\b0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Еще один немаловажный элемент регулярного выражения – это список применяемых к нему модификаторов. Модификаторы – это выдаваемая интерпретатору регулярных выражений инструкция по обработке данного выражения. Например, считать, что все символы регулярного выражения соответствуют как большим, так и маленьким буквам в строке, где производится поиск. Примеры модификаторов приведены в таблице 13.3.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 i (PCRE_CASELESS)\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если указан этот модификатор, то буквы в шаблоне совпадают с буквами и верхнего, и нижнего регистра в строке\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 m (PCRE_MULTILINE)\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 По умолчанию строка, подающаяся на вход интерпретатору РВ, рассматривается как состоящая из одной линии. Этот модификатор включает поддержку многострокового режима\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 s (PCRE_DOTALL)\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если установлен этот модификатор,  то метасимвол точка «.» совпадает с любым символом, ВКЛЮЧАЯ символ перевода строки\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 x (PCRE_EXTENDED)\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Заставляет интерпретатор игнорировать пробелы между символами в шаблоне, за исключением пробелов, экранированных обратным слэшем или находящихся внутри символьного класса, а также между неэкранированным символом # вне символьного класса и символом новой строки\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 U (PCRE_UNGREEDY)\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Этот модификатор инвертирует «жадность» квантификаторов, т.е. они становятся «нежадными» по умолчанию и «жадными» если предшествуют символу «?»\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Регулярные выражения для «продвинутых»\b0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В последующих разделах обсуждаются более сложные конструкции работы с регулярными выражениями, без которых в принципе можно обойтись. Поэтому мы не будем в них особо углубляться, а приведем лишь общие сведения.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Обратная ссылка\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Вне определения символьного класса (это тот, что задается квадратными скобками) комбинация обратный слэш и цифра больше нуля (например, \\1) называется обратной ссылкой и представляет собой ссылку на захваченное ранее регулярное подвыражение. Этих подвыражений ровно столько, сколько открывающихся круглых скобок (перед которыми нет знака вопроса) стоит левее данного элемента.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Обратная ссылка совпадает с конкретным выбранным значением подвыражения, на которое она ссылается, а не с любым возможным значением этого подвыражения. Таким образом, шаблон\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (ответствен|надеж)ный проявляет \\1ность\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 совпадет со строками «ответственный проявляет ответственность», «надежный проявляет надежность» и не совпадет со строкой «ответственный проявляет надежность».\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Обратные ссылки могут использоваться внутри подвыражений. При первом использовании подвыражения ссылка внутри него не срабатывает, но при последующих повторениях подшаблона она работает, как описано выше.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Утверждения\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Утверждение – это проверка символов, следующих до или после текущего символа. Простейшие утверждения закодированы последовательностями \\A, \\Z, ^, $ и т.д. Более сложные утверждения кодируются с помощью подшаблонов. Постараемся вкратце описать, как это делается.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Существует два типа утверждений: те, что смотрят за текущую позицию в исходной строке («смотрящие вперед»), и те, что смотрят на символы перед текущей позицией («смотрящие назад»).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Утверждения, закодированные подшаблонами, сравниваются как обычные подшаблоны, за исключением того, что при их обработке не происходит изменения текущей позиции.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 «Смотрящие вперед» утверждения ищут совпадения в строке за текущей позицией поиска и начинаются с (?= для позитивных утверждений и с (?! для негативных. Например,\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \\w+(?=;)\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 совпадает со словом, заканчивающимся точкой с запятой (не включая точку с запятой в результат поиска), и\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 foo(?!bar)\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 совпадает с любым появлением foo, после которого нет bar. Как все происходит? Берем строку и ищем в ней foo. Как только нашли, заглядываем вперед (текущая позиция при этом не меняется) и смотрим, идет ли далее bar. Если нет, то совпадение с шаблоном найдено, иначе продолжаем поиск.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Регулярное выражение\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (?!foo)bar\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 не найдет все вхождения bar, перед которыми нет foo, потому что оно «смотрит вперед», а перед ним никаких символов нет. Поэтому в данном шаблоне ?!foo всегда верно.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 «Смотрящие назад» утверждения ищут совпадения перед текущей позицией. Позитивные утверждения этого типа начинаются с (?<= , негативные – с (?<! . Смотрящим назад утверждениям позволено искать только строки фиксированной длины, т.е. в них нельзя использовать квантификаторы. Например,\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (?<!foo)bar\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 находит все появления bar, перед которыми нет foo.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В начале лекции мы хотели научиться находить в html-файле упоминание об авторе. Это можно сделать с помощью «смотрящих назад» утверждений в РВ (хотя можно и проще).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 //считываем файл в строку\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $str = file_get_contents('1.htm');\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $pattern = "/(?<=Автор:)\\s[А-Я]".\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         "[а-я]*\\s([А-Я]\\.\\s*)\{1,2\}/m";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // осуществляем поиск\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $n = preg_match_all ($pattern, $str, $res);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // выводим результаты\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 for ($i=0;$i<$n;$i++)  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    echo htmlspecialchars($res[0][$i]).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                          "<br>";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Часть РВ после утверждения определяет, что мы ищем строку (ФИО), которая начинается с пробела, большой буквы, затем идут маленькие буквы в произвольном количестве, пробел и инициалы через точку. Утверждение задает то, что перед данной строкой должно стоять «Автор:».\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Дату можно вычислить похожим образом. Оставляем это в качестве упражнения.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Условные подвыражения\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Как в любом языке программирования, в РВ существуют условные конструкции. Применяются они к подвыражениям. То есть можно заставить процессор РВ выбирать подшаблон в зависимости от условия или выбирать между двумя альтернативными шаблонами в зависимости от результата утверждения или от того, совпал ли предыдущий захваченный подшаблон. Существуют две формы условных подвыражений:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (?(условие)шаблон_выполняемый_если_\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0            условие_верно)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (?(условие)шаблон_если_условие_верно\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     |шаблон_если_условие_неверно)\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Существует два типа условий. Если текст между круглыми скобками состоит из последовательности цифр, то условие удовлетворяется, если захваченное подвыражение с этим номером ранее совпало.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ( \\( )?  [^()]+  (?(1) \\) )\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Первая часть этого РВ опционально совпадает с открывающейся круглой скобкой, и если этот символ присутствует, то устанавливает его как первое захваченное подвыражение.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Вторая часть совпадает с одним или более символами, не заключенными в круглые скобки.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Третья часть РВ – это условное подвыражение, которое проверяет, совпало ли первое множество скобок или нет (попалась ли нам в строке открывающая круглая скобка). Если попалась, то есть объект (строка) начинается с символа «(», то условие верно и вычисляется условный шаблон, а именно требуется наличие закрывающей круглой скобки. В противном случае подшаблон ни с чем не совпадает.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если условие – не последовательность цифр, то оно должно быть утверждением. Это может быть позитивное или негативное «смотрящее вперед» или «смотрящее назад» утверждение.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (?(?=[^a-z]*[a-z])\\d\{2\}-[a-z]\{3\}-\\d\{2\}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      |\\d\{2\}-\\d\{2\}-\\d\{2\})\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Условие здесь – позитивное «смотрящее вперед» утверждение. Оно совпадает с любой последовательностью не букв, после которых идет буква. Другими словами, оно проверяет присутствие хотя бы одной буквы в строке для поиска. Если буква найдена, то производится сравнение по первому альтернативному варианту шаблона (\\d\{2\}-[a-z]\{3\}-\\d\{2\}), иначе – по второму (\\d\{2\}-\\d\{2\}-\\d\{2\}). Этому шаблону удовлетворяют строки двух типов: dd-aaa-dd или dd-dd-dd, где d – любая цифра, a – любая буква.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Заключение\b0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Итак, мы рассмотрели механизм регулярных выражений, их синтаксис и семантику, показали примеры их использования. Безусловно, эта лекция не охватывает все тонкости данного механизма. О регулярных выражениях пишут целые книги! Мы же постарались лишь в общих чертах познакомить читателей с их основами. Вообще механизм регулярных выражений присутствует почти во всех языках программирования с небольшими отличиями, но суть остается той же. Так что надеемся, что знания, полученные в процессе чтения этой лекции, помогут при изучении других языков и пригодятся на практике.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Взаимодействие PHP и XML\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Введение\b0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Прежде чем начать изучать способы работы PHP с XML, полезно хотя бы вкратце ознакомиться с самой технологией XML. В первой части лекции будут рассмотрены основные понятия этой технологии, базовый синтаксис XML–документов, области ее применения, а также понятие DOM XML. Вторая часть лекции посвящена непосредственно вопросам обработки XML при помощи PHP. Сюда входит установка расширения DOM XML, описание и примеры использования некоторых встроенных в PHP функций для обработки XML-документов.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В качестве примера рассмотрим XML-файл, содержащий описания личностей, и попытаемся научиться добавлять, удалять и находить личность или отдельные элементы ее описания в этом файле с помощью PHP.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b XML\b0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Основные понятия\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 XML (Extensible Markup Language) – это расширяемый язык разметки, являющийся подмножеством языка SGML и поэтому имеющий общие с ним цели – разметка любого типа документов.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 XML имеет много общего с языком разметки HTML, но они различны по своему назначению. HTML, как и XML, является подмножеством SGML, но предназначен только для отображения информации в браузере. XML же предназначен для структурированного хранения информации и не содержит никаких конструкций для отображения этих данных.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для отображения данных, хранящихся в XML-формате, используются различного рода преобразователи, например язык трансформаций XSLT. Комбинация XML + преобразователь позволяет достичь того же результата, что и использование HTML-форматированного отображения документа пользователю. Однако в случае использования XML и преобразователя данные хранятся отдельно от их представления, т. е. от инструкций о том, как они должны отображаться.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 XML очень похож на HTML по своему синтаксису, за исключением того, что теги XML можно придумывать собственные. По аналогии с HTML внутри XML-тегов можно использовать атрибуты. Каждый тег XML должен иметь соответствующий закрывающий тег (в HTML это не является обязательным). Каждый XML-документ начинается со строки декларации, например:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?xml version='1.0' encoding='UTF-16'\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                     standalone='yes' ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 которая указывает на версию языка XML (атрибут version), кодировку текста в этом документе (атрибут encoding) и показывает, существует ли документ сам по себе или зависит от других файлов (атрибут standalone).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Приведем пример XML-документа.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Пусть у нас имеется письмо. Содержащуюся в нем информацию можно хранить в следующем виде:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?xml version='1.0' encoding='KOI8-R'\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                     standalone='yes' ?>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <note title="Письмо">\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     <to>Маша Петрова</to>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     <body>Привет, Маша! \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     Как у тебя дела? \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     У меня все хорошо. \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     Собираюсь приехать \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     к тебе в гости.</body>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     <from>Вася Иванов</from>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 </note>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Сохранив этот файл, например, как note.xml, мы можем переслать его кому-нибудь, просмотреть с помощью браузера или использовать в программе. В частности, можно использовать этот XML-документ в своей PHP-программе.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 С помощью XML можно создать документ для описания любой информации. Для того чтобы другие разработчики могли создавать документы в этом же XML-языке (т.е. используя те же теги) и чтобы можно было проверить правильность созданного документа (его соответствие выбранному XML-языку), нужно формально описать используемый XML-язык. Это делается с помощью механизмов DTD (Document Type Definition) или Schemas, которые дают возможность создавать шаблоны для новых типов документов. Для экспериментов в домашних условиях создавать DTD-описания необязательно. Важно понимать, что XML на самом деле вовсе не язык, а стандарт для создания языков, отвечающих критериям XML.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Между XML-документами могут быть установлены ссылки, один документ может включать в себя другой, т.е. структура документа может быть сколь угодно сложной.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Элементы в XML-документах могут быть связаны между собой отношениями родитель/потомок или родственник/родственник. В нашем примере <note> является родителем <to> , который в свою очередь является потомком <note>, а <to>, <body> и <from> являются родственниками. Собственно текст тоже является потомком элемента, например, «Вася Иванов» – потомок элемента <from>. Такая структура называется деревом; любые части дерева, имеющие потомков, называются ветвями, а не имеющие – листьями.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Объектная модель XML-документа\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Структура XML-документа очень напоминает объектную модель: она иерархична, одни элементы могут быть потомками других. Любой XML-документ можно представить в качестве объектной модели. При этом одни элементы (например, теги) становятся объектами, другие (атрибуты и текстовые элементы) – их свойствами. Например, для документа\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <parent>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   <child id="text">Добрый день!</child>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 </parent>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 объектная модель может выглядеть как показано на рис. 14.1\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Прямоугольниками изображены объекты, овалом – свойства объектов.\par
\par
\qc\par\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 \b Рис. 14.1.\b0            Пример объектной модели\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для каждого конкретного XML-документа можно создать свою объектную модель, но есть более общая объектная модель, применимая для любого XML-документа, вне зависимости от его структуры. Эта модель называется DOM (Document Object Model).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Обычно DOM добавляется как слой между XML-парсером и приложением, которому требуется информация из документа. То есть парсер берет данные из документа и передает их в DOM. Затем DOM используется приложениями более высокого уровня.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Хотя DOM расшифровывается как «объектная модель документа», работает DOM преимущественно с интерфейсами, а не с объектами. Интерфейс – это соглашение, по которому поддерживаются определенные свойства и методы, применяемые к некоему объекту. На рис. 14.2 показано, как приведенный выше XML-документ представляется в DOM:\par
\par
\qc\par\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 \b Рис. 14.2.\b0            Пример DOM (Document Object Model)\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Каждый прямоугольник представляет собой объект, имена в прямоугольниках соответствуют интерфейсам, которые будут реализованы каждым объектом. Каждый объект может реализовывать несколько подходящих интерфейсов. Например, объект представляющий символьные данные «Hello,World!», реализует интерфейсы Text, CharacterData, Node.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Преимущество модели DOM состоит в том, что она универсальна, т.е. может применяться для документов любого типа. Ее использование может существенно упростить обработку XML-документов.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Но вернемся к технологии XML. Для чего она используется? В основном для хранения и передачи данных. В последнее время хранение данных в виде набора XML-файлов рассматривается даже как альтернатива реляционным базам данных. Но наиболее прогрессивные разработчики стремятся задействовать совместно XML и базы данных, пользуясь достоинствами обеих технологий. В частности, XML удобнее использовать для передачи данных, а базу данных – для их хранения и обработки.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Например, главная компания и ее филиал в другом городе имеют два разных сайта поддержки, написанных на PHP. На сайте филиала нужно сообщать обо всех основных событиях, происходящих в главной компании, и наоборот. Поэтому обе организации ежедневно обмениваются новостями в универсальном формате XML, а эти файлы создаются и обрабатываются PHP-скриптами и отображаются на обоих сайтах.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Взаимодействие PHP и XML\b0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Расширения SAX и DOM XML\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для работы с XML-документами можно использовать язык PHP. В \b PHP\b0   для этого существует два модуля, реализующие два разных стандарта обработки XML-данных: SAX (Simple API for XML) и DOM (Document Object Model).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Стандарт SAX (http://www.saxproject.org) не является стандартом W3C и описывает метод обработки XML-документов для получения из них данных. То есть этот метод обработки XML-документов позволит только прочитать данные из XML-документа, и не более того. Создавать и изменять XML-документы с его помощью невозможно.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 SAX основан на так называемом событийном программировании. Его особенность заключается в том, что вы предоставляете парсеру XML набор собственных функций, которые будут заниматься обработкой различных типов XML-данных (элементов (тегов), текста и т.п.), а парсер затем будет сам вызывать ваши функции в процессе обработки XML-документа, передавая им найденные данные. Функции будут вызываться в той же последовательности, в которой соответствующие данные располагаются в XML-документе.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Другим стандартом для обработки XML-данных является DOM – стандарт \b W3C\b0  , спецификацию которого можно найти на сайте консорциума (http://www.w3c.org/DOM). В отличие от SAX, этот метод позволяет производить любые операции с XML-данными в достаточно удобной форме – представляя XML-документ как дерево объектов.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Модуль, реализующий этот стандарт, называется DOM XML. Он не входит в основной набор модулей PHP, но может быть установлен как расширение. API этого модуля старается как можно более точно следовать стандарту DOM level 2. Кроме того, существует множество дополнительных функций. Эти функции включены для совместимости с предыдущими версиями расширения, и использовать их в новых скриптах не рекомендуется. Кроме того, у расширения DOMXML есть проблемы с русской кодировкой. Парсер обрабатывает текст только в кодировке UTF-8, поэтому текст нужно каждый раз перекодировать с помощью функции iconv. Отсюда и необходимость установки расширения iconv вместе с DOM XML.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Модуль DOM XML является мощным и удобным в использовании средством обработки XML-документов. В данной лекции мы будем рассматривать именно его.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Установка расширения DOM XML\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для того чтобы установить расширение DOM XML, нужно сделать следующее.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - В файле настроек PHP (php.ini) раскомментировать строку, касающуюся этого расширения (extension=php_domxml.dll для Windows, либо extension=php_domxml.so для Linux-платформ).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - Скопировать файл расширения (php_domxml.dll или php_domxml.so) в папку, где находятся расширения (extension_dir).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - Подключить расширение iconv так же, как в пунктах выше (иногда это расширение устанавливается автоматически вместе с domxml).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - Скопировать дополнительные библиотеки в системную папку system (Windows 98) или system32 (WindowsNT/2000/XP). В первую очередь это библиотеки libxml2 и iconv, затем libxslt, libexslt и zlib.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - Перезапустить сервер.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Следует проверить, правильно ли установлена переменная extension_dir в файле настройки php.ini. Если она не указывает на директорию, где находятся библиотеки расширений PHP, то ни одно из расширений подключить не удастся.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Чтобы проверить, установилось ли расширение, можно создать простейший скрипт, который будет выводить все настройки PHP-интерпретатора (это делает функция phpinfo() ). Другой вариант – попробовать использовать какую-нибудь функцию из данного расширения. Например, можно попробовать получить версию используемой библиотеки libxml с помощью функции domxml_version(). Но этот способ не очень хорош, поскольку расширение экспериментальное (это значит, что некоторые функции в каких-то определенных условиях могут и не работать), да и функции еще надо изучить, прежде чем их использовать.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // выводит информацию о настройках PHP\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 phpinfo(); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // отображает используемую версию\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // библиотеки libxml\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo domxml_version();\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Взаимодействие PHP и XML посредством DOM XML\b0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Что происходит, если взаимодействие PHP и XML осуществляется с помощью объектной модели стандарта DOM? Модуль DOM XML определяет в PHP несколько классов, таких как DomNode, DomDocument, DomElement, DomText и DomAttribute, большинство из которых идут из ядра стандарта DOM. Почти для всех классов (в частности, для перечисленных выше) класс DomNode является родительским, поэтому его свойства и методы наследуются всеми остальными классами.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если рассмотреть произвольный XML-документ, то классу DomDocument будет соответствовать сам этот документ, классу DomElement – каждый XML-тег, классу DomAttribute – атрибуты тегов, а классу DomText – содержание XML-элементов. В то же время классу DomNode будет соответствовать каждый из перечисленных элементов XML-документа.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Рассмотрим коллекцию, содержащую описания персон. Если каждую из них мы описываем с помощью таких характеристик, как фамилия, имя, дата рождения и электронный адрес, то структура коллекции «Личности», где хранится информация обо всех известных нам персонах, может быть представлена следующим образом.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?xml version="1.0"?>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <collection>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     <person id="10">\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         <name>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0             <first>Nick</first>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0             <last>Petrov</last>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         </name>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         <birth>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0             <day>23</day>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0             <month>12</month>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0             <year>89</year>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         </birth>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         <email> nick@ngs.ru \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         </email>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     </person>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     <person id="20">\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         <name>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0             <first>Bob</first>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0             <last>Ivanov</last>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         </name>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         <birth>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0             <day>03</day>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0             <month>05</month>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0             <year>90</year>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         </birth>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         <email> bob@ngs.ru \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         </email>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     </person>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 </collection>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В дальнейшем, приводя примеры, мы будем использовать этот файл.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Нам необходимо научиться читать, добавлять, изменять и искать информацию, находящуюся в XML-файлах.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Перевод данных XML-файла в объекты и классы PHP\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Первое, что нужно сделать, если мы хотим работать с XML-данными в PHP при помощи расширения DOM XML, это перевести имеющиеся данные в объекты и классы DOM. Это можно сделать несколькими способами.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Синтаксис:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 object domxml_open_mem (string str)\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  -  В качестве параметра эта функция принимает строку str, содержащую XML-документ. Результатом ее работы является объект класса, называемого DOMDocument.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Синтаксис:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 object domxml_open_file (string filename)\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  -  Эта функция обрабатывает XML-файл, имя которого задается параметром filename, и переводит его в объект класса DOMDocument. Доступ к файлу производится только на чтение.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Такие функции, как domxml_open_mem() и domxml_open_file(), как правило, нужно вызывать перед вызовом любых других функций, связанных с расширением DOM.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эти функции преобразуют XML-файл в дерево объектов. К таким объектам можно обращаться с помощью различных методов. В частности, для выделения корневого элемента используется метод DomDocument->document_element().\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Еще существует функция domxml_new_doc(string version), которая создает новый пустой XML-документ. Ее параметром является номер версии создаваемого документа. Но ее мы касаться не будем, а будем считать, что XML-файл уже создан.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 //считываем файл "persons.xml" в строку\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $xmlstr = join('',file('persons.xml'));\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // переводим строку с xml-файлом\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // в дерево объектов. Если операция\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // прошла неудачно, то выводим\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // ошибку и прекращаем работу.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 if(!$dom = domxml_open_mem($xmlstr)) \{\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   echo "Ошибка при разборе документа\\n";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   exit;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // можно посмотреть, как выглядит\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // этот объект\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 print_r($dom);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo "<hr>";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // выделяем корневой элемент\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // дерева объектов.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // В нашем случае это будет\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // элемент <collection>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $root = $dom->document_element();\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 print_r($root);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo "<hr>";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Итак, каждому элементу XML-файла мы поставили в соответствие какой-то объект. Теперь нужно научиться перемещаться по дереву объектов и обращаться с этими объектами: получать и изменять их значения, находить их потомков и предков, удалять объекты.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Обход дерева объектов\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для получения значения текущего узла (вне зависимости от его типа) используют метод DomNode->node_value() или DomNode->get_content() для получения содержимого узла.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для получения значения атрибута используется метод DomElement->get_attribute (attr_name). А метод DomNode->child_nodes() возвращает массив потомков данного узла.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для того чтобы сделать обход дерева объектов, полезно еще уметь различать объекты по типам, т.е. определять, является ли узел элементом (тегом), текстом, атрибутом и т.п. Для этого используются специальные константы. XML_ELEMENT_NODE определяет, является ли узел элементом, XML_ATTRIBUTE_NODE определяет, является ли узел атрибутом, и XML_TEXT_NODE определяет, является ли узел куском текста. Эти константы имеют целочисленные значения 1, 2 и 3 соответственно. Использование этих констант полезно, поскольку переводы строки, применяемые для удобочитаемости XML-файлов, тоже становятся узлами.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // сначала делаем то же,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // что и в предыдущем примере\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $xmlstr = join('',file('persons.xml'));\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 if(!$dom = domxml_open_mem($xmlstr)) \{\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   echo "Ошибка при разборе документа\\n";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   exit;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $root = $dom->document_element();\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // Получаем массив потомков\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // родительского узла\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // (в нашем случае это массив <person>)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $nodes = $root->child_nodes();\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 print_r($nodes);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo "<hr>";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // Начинаем обработку каждого\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // узла в массиве\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 foreach($nodes as $node)\{\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // Если текущий узел – один\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // из узлов <person>, то\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // продолжаем ее обработку,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // чтобы получить информацию\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // об этой личности\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     if ($node->tagname=='person')\{\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // Создаем массив, куда\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // будем собирать информацию\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // о рассматриваемой личности\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     $currentPers = array();\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // Получаем id личности,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // который хранится в атрибуте 'id'\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     $currentPers['id'] = \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0           $node->get_attribute('id');\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // Получаем массив потомков\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // <person>. Это вся\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // информация о личности\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // (<name>,<birth> и т.д.)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     $persons_info = \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                 $node->child_nodes();\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // Перебираем все дочерние\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // узлы $node\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     foreach ($persons_info as $info)\{\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // проверяем, является ли узел\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // элементом (xml-тегом)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     if ($info->type==\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                   XML_ELEMENT_NODE) \{\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         // тогда метод tagname\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         // возвратит имя этого  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         // элемента (тега), а метод\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         // get_content() –\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         // его содержимое\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         $currentPers[$info->tagname] =\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                  $info->get_content();\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // выводим на экран полученные\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // массивы\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     print_r ($currentPers);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                                         \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     echo "<br>";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Итак, мы научились обходить дерево XML. Теперь можно попытаться что-нибудь найти в XML-файле. Правда, делать это не совсем удобно опять же из-за переносов строк, которые мы использовали при написании XML-файла. Пусть наш XML-файл записан в строку, а точнее, в нем есть следующая строка:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ...\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <person id="20">\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   <name>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     <first>Иван</first>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     <last>Иванов</last>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   </name>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ...\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Тогда в наш предыдущий пример вставим (после вывода на экран полученных массивов) строчку для поиска электронного адреса Ивана Иванова.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ...\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     $str = $currentPers["email"];\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     if ($currentPers["name"] ==\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                     "Иван Иванов" )\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         echo "Здравствуйте, Иван! " .\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         "Ваш e-mail $str";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ...\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Добавление новых элементов в XML-документ\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Далее разберем задачу, как можно добавить в нашу базу данных новую личность средствами php.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Сначала нужно скопировать описание личности (считаем, что все личности описываются с помощью стандартного набора характеристик, как в файле persons.xml). Это делается с помощью метода DomNode->clone_node(). Таким образом, мы клонируем элемент <person> и все его внутренние элементы (содержание тегов не копируется).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Потом можно установить какие-нибудь значения для элементов описания личности. Например, задать имя человека, дату его рождения и т.п. В конце нужно записать полученное описание личности в качестве потомка корневого элемента в дерево DOM с помощью метода DomNode->append_child(new_node), где в качестве параметра передается созданный объект (новый узел).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В PHP до версии 4.3 перед добавлением потомка к узлу с помощью данной функции этот потомок сначала копировался. Таким образом, новый узел являлся новой копией, которая могла изменяться без изменения узла, переданного как параметр в эту функцию. В более поздних версиях PHP новый узел удаляется из существующего контекста, если он уже есть в дереве. Такое поведение соответствует спецификациям W3C.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для удаления узла можно воспользоваться методом, применив его к узлу, который требуется удалить, т.е. DomNode->unlink_node().\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Заключение\b0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Итак, мы изучили ряд функций, позволяющих манипулировать данными, хранящимися в XML-формате. Это, конечно же, далеко не полный перечень существующих функций. В версии PHP5 он значительно усовершенствован и в большей степени соответствует стандарту DOM. Тем не менее знание приведенных здесь основных функций может оказаться полезным при решении конкретных прикладных задач.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Использование шаблонов в PHP\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Что такое шаблоны и зачем они нужны\b0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Что такое шаблон в языке программирования? Можно сказать, что шаблон - это текст с переменными внутри него. При обработке шаблона происходит замена переменных на их значения.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В одной из лекций мы уже рассматривали пример шаблона. Это был шаблон для отображения документов. Пользователь создавал строку текста, размеченного с помощью html-тегов, и вставлял в нее специальные метасимволы (вида <!имя элемента>), которые наша программа впоследствии заменяла на значения соответствующих элементов. Для чего нам был нужен такой шаблон? Чтобы, например, можно было изменить стиль отображения документа, не меняя кода программы.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Наиболее распространенный ответ на вопрос, зачем нужны шаблоны, звучит примерно так: шаблоны нужны для того, чтобы отделить логику работы приложения от способа представления данных, т. е. от дизайна.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Приведенный пример шаблона - один из самых простых. Для его обработки используется только функция подстановки str_replace(). Чаще всего для того, чтобы работать с шаблонами, создают библиотеки классов. В принципе создавать свою библиотеку не обязательно, поскольку существует множество свободно распространяемых библиотек шаблонов, над функциональностью которых трудятся большие коллективы разработчиков, стараясь сделать их универсальными, мощными и быстрыми. Некоторые из таких библиотек мы и рассмотрим. Но для начала сформулируем задачу, на примере решения которой будем демонстрировать использование различных шаблонов.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Итак, задача:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Требуется сгенерировать web-страницу со списком статей, имеющихся в базе данных. Для простоты считаем, что статья имеет название title, автора author, краткое содержание abstract и полное содержание fulltext, которое представлено либо в виде текста в базе данных, либо в виде ссылки на файл. Список должен быть организован так, чтобы при щелчке мышью на названии статьи ее полное содержание появлялось в новом окне.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Шаблоны подстановки\b0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Как можно решить такую задачу способом простой подстановки, т.е. тем методом, которым мы решили задачу отображения документов?\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Нужно придумать шаблон для этой страницы и где-то его хранить (в файле или в базе данных). Очевидно, что мы не можем придумать шаблон для всей страницы, потому что не знаем, сколько статей в базе данных. В шаблоне же мы договорились использовать только html и метасимволы <!имя элемента>. Поэтому мы можем написать только шаблон для одной строки списка, который уже программно надо преобразовать в нужное количество строк.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <li><a href="<!fulltext>" \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    target=new><!title></a>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    (<!author>)<br><p><!abstract></p>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Кроме того, здесь есть еще одна загвоздка - с отображением ссылки на полный текст статьи. Если мы будем действовать по правилу подстановки (менять все метасимволы на их значения из базы данных), то может получиться, что вместо <!fulltext> вставим не ссылку на текст, а сам текст. То есть для этого элемента нужна дополнительная проверка перед заменой и какие-то дополнительные действия в случае, если в поле fulltext содержится текст статьи, а не ссылка на файл. Не будем усложнять себе жизнь и договоримся, что в поле fulltext всегда содержится только ссылка на файл. Тогда задачу можно решить следующим образом:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $li_tmpl = file_get_contents("tmpl.html");\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // считываем шаблон строки из файла\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // устанавливаем соединение и выбираем\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // базу данных\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $conn = mysql_connect("localhost",\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                       "nina","123")\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 or die("Cant connect");\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 mysql_select_db("book");\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $sql = "SELECT * FROM Articles";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $q = mysql_query($sql,$conn); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // отправляем запрос\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $num = mysql_num_rows($q);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   for($i=0; $i<$num; $i++)\{\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     $tmpl .= $li_tmpl;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     $tmpl = str_replace("<!title>",\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0       mysql_result($q,$i,"title"),$tmpl);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     $tmpl = str_replace("<!author>",\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0       mysql_result($q,$i,"author"),$tmpl);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     $tmpl = str_replace("<!abstract>",\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0       mysql_result($q,$i,"abstract"),$tmpl);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     $tmpl = str_replace("<!fulltext>",\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0       mysql_result($q,$i,"fulltext"),$tmpl);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 echo $tmpl;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если шаблон был такой, как приведен выше, то получим примерно следующее.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Введение в PHP\b0   (Савельева Н.В.)\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Лекция дает представление о том, что такое язык PHP, для чего он создавался изначально и как используется теперь, какими возможностями обладает.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Установка и настройка ПО\b0   (Иванов Иван)\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Рекомендации по установке и настройке web-сервера и интерпретатора PHP\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В принципе метод достаточно прост и удобен, но требует дополнительных усилий программиста при возникновении задач более сложных, чем простая подстановка значений. Для решения задач, где требуется делать подстановку целых блоков или даже проверять условия, создают классы шаблонов, такие как FastTemplate и Smarty. Обсудим их подробнее.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Шаблоны FastTemplate\b0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 FastTemplate - это набор классов, позволяющих реализовать работу с шаблонами. Логику добавить в шаблон FastTemplate нельзя, вся она должна находиться в коде программы. Идея работы шаблонов FastTemplate заключается в том, что любая большая страница состоит из множества кусочков, самые маленькие из которых - обычные строки текста, и они получают имя и значение.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Что представляет собой файл шаблона FastTemplate? Это обычный html-файл, в котором могут встречаться переменные особого вида, впоследствии обрабатываемые методами класса FastTemplate.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Синтаксис переменных в шаблонах FastTemplate описывается следующим выражением: \{([A-Z0-9_]+)\}\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Это значит, что переменная должна начинаться с фигурной скобки "\{". Второй и последующие символы должны быть буквами верхнего регистра от A до Z, цифрами или символами подчеркивания. Переменная вычисляется с помощью закрывающей фигурной скобки "\}".\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \{TITLE\}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \{AUTH20\}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \{TOP_OF_PAGE\}\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Как уже было сказано, основная идея FastTemplate - создание страницы с помощью вложенных шаблонов. Например, для решения нашей задачи можно создать три файла шаблона:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <html>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <head><title>\{TITLE_\}</title>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 </head>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <body>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \{MAIN\}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 </body>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 </html>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0              \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <ul>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \{LIST_ELEMENT\}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 </ul>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0              \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <li><a href="\{FULLTEXT\}">\{TITLE\}</a>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (\{AUTHOR\})\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <br> <p> \{ABSTRACT\}\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0              \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Шаблоны мы создали - работу дизайнера выполнили. Теперь нужно научиться их обрабатывать, т.е. выполнить работу программиста. Сейчас создадим программу для обработки приведенных выше шаблонов.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Перед началом работы с шаблонами FastTemplate нужно подключить этот набор классов к нашей программе. В реальной жизни набор классов FastTemplate записан в один файл, как правило, с названием class.FastTemplate.php3, поэтому подключить его можно, например, с помощью команды:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 include("class.FastTemplate.php3");\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Следующий важный шаг - это создание объекта класса FastTemplate, с которым впоследствии мы будем работать:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $tpl = new FastTemplate(\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0               "/path/to/templates");\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В качестве параметра передается путь к месту, где находятся наши шаблоны.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Методы FastTemplate\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Далее необходимо изучить методы, которые можно применять к созданному объекту класса FastTemplate. Параллельно обратим внимание, как их можно использовать для решения нашей задачи.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для работы с FastTemplate нужно знать четыре основных метода: define, assign, parse и FastPrint.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Метод define\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Синтаксис:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 define( array ( ключ => значение,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                 ключ1 => значение1, ... ))\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Метод define() связывает имя файла шаблона с более коротким именем, которое можно будет использовать в программе. То есть "ключ" - это имя, которое мы будем использовать в программе для ссылки на файл шаблона, имя которого записано в строке "значение". Реальные имена файлов шаблонов не рекомендуется использовать нигде, кроме метода define. При вызове метода define() происходит загрузка всех определенных в нем шаблонов.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $tpl->define( array (main => "main.tpl",\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     list_f => "list.tpl",\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     list_el=> "list_element.tpl" ));\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Здесь мы задаем псевдонимы именам файлов шаблонов. Эти псевдонимы, т.е. переменные main, list_f и list_el, будут использоваться в программе вместо соответствующих имен файлов main.tpl, list.tpl и list_element.tpl.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Метод assign\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Синтаксис:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 assign( (пары ключ/значение) или \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0       ( array(пары ключ/значение) )\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Метод assign() присваивает переменным значения, "ключ" - это имя переменной, а "значение" - значение, которое ей нужно присвоить. Чтобы переменная в шаблоне была заменена значением, это значение нужно задать ей с помощью метода assign(). Согласно синтаксису этот метод можно использовать в двух различных формах. В FastTemplate есть только один массив, поэтому, если вы повторно задаете значение одному и тому же ключу, оно будет перезаписано.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $tpl->assign(array( \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     TITLE => "Установка и настройка ПО",\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     TITLE => "Введение в PHP" ));\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Здесь мы дважды устанавливаем значение переменной, доступной в файлах шаблона по имени TITLE. Эта переменная будет иметь последнее присвоенное ей значение, т.е. она равна строке "Введение в PHP".\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Метод parse\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Синтаксис:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 parse (возвращаемая переменная, \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0        источники шаблонов)\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Метод parse() - самый основной в FastTemplate. Он устанавливает значение возвращаемой переменной равным обработанным шаблонам из указанных источников. Метод может использоваться в трех формах: простой, составной и присоединяющей.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $tpl->parse(MAIN, "main"); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // простая форма\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $tpl->parse(MAIN, array ("list_f", "main"));\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // составная форма\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $tpl->parse(MAIN, ".list_el"); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // присоединяющая форма\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В простой форме шаблон с псевдонимом "main" загружается (если еще не был загружен), все его переменные подставляются, и результат сохраняется как значение переменной MAIN. Если переменная \{MAIN\} появится в более поздних шаблонах, то вместо нее будет подставлено значение, полученное в результате обработки шаблона "main". Это позволяет создавать вложенные шаблоны.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Составная форма метода parse() создана для того, чтобы упростить вложение шаблонов друг в друга. Следующие записи эквивалентны:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $tpl->parse(MAIN, "list_f");\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $tpl->parse(MAIN, ".main");\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 это то же самое что и\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $tpl->parse(MAIN, array("list_f", "main"));\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Когда используется составная форма, важно, чтобы каждый шаблон, идущий в списке после первого, содержал ту переменную, в которую передаются результаты обработки шаблона. В примере выше main должен содержать переменную \{MAIN\}, поскольку именно в нее передаются результаты обработки шаблона list_f. Если main не содержит переменной \{MAIN\}, то результаты обработки шаблона list_f будут потеряны.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Присоединяющий стиль позволяет добавлять результаты обработки шаблона к переменной результата. Точка перед псевдонимом файла шаблона говорит FastTemplate о том, что нужно присоединить результат обработки этого шаблона к возвращенным результатам, а не перезаписывать его. Такой стиль наиболее часто используется при построении таблиц с переменным числом рядов, получаемых, например, в результате запроса к базе данных.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Метод FastPrint\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Синтаксис:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 FastPrint(обработанная переменная)\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Метод FastPrint() печатает содержимое переданной в него обработанной переменной. Если он вызван без параметров, то печатается последняя использованная методом parse() переменная.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $tpl->FastPrint(); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 /* если продолжать предыдущий пример,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 то эта функция напечатает значение \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 переменной MAIN */\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $tpl->FastPrint("MAIN"); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // эта функция сделает тоже самое\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если нужно печатать не на экран, а, например, в файл, то получить ссылку на данные можно с помощью метода fetch().\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $data = $tpl->fetch("MAIN");\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 fwrite($fd, $data); // запись данных в файл\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Решение задачи с помощью шаблонов FastTemplate\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь попробуем собрать воедино все изученные методы, чтобы решить нашу задачу.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Заметим, что решение задачи получилось несколько более сложным, чем в первом случае, когда использовалась только функция регулярной замены. Зато здесь мы можем изменять три различных шаблона (документа в целом, списка и элемента списка).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Этот класс шаблонов появился еще до выхода PHP4 для работы с PHP3. Чтобы протестировать приведенные примеры, нужно скачать библиотеку классов FastTemplate и скопировать этот файл в свою рабочую директорию. Если вы работаете с PHP4, то в файл class.FastTemplate.php3 нужно внести пару изменений, о которых написано в документации, поставляющейся вместе с этой библиотекой.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Шаблоны Smarty\b0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Smarty - один из действующих проектов PHP, его официальный сайт - http://smarty.php.net. Там можно скачать как сам набор классов Smarty, так и документацию к нему. Этот набор классов для обработки шаблонов - гораздо более мощный и функциональный, чем FastTemplate.Чем отличается Smarty от классов шаблонов типа FastTemplate? Прежде всего, он не отделяет полностью логику от содержания. Логика, касающаяся отображения данных, может присутствовать в шаблоне, считают разработчики Smarty. Поэтому в              шаблоне Smarty могут быть условные операторы, операторы вставки файлов, операторы изменения переменных, циклы и т.п. Другая особенность Smarty - это компиляция шаблонов. Шаблоны переводятся в php-код, и интерпретатор PHP производит все необходимые действия по подстановке значений. Для ускорения работы скомпилированные шаблоны кэшируются.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Рассмотрим некоторые основные конструкции механизма шаблонов Smarty.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Установка\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Первое, с чего мы начнем, - это установка Smarty. Здесь все не так просто, как с FastTemplate. Smarty состоит не из одного php-файла с описанием класса, а из целого набора различных файлов-библиотек. Для того чтобы работать с шаблонами Smarty, нужно сделать эти библиотеки доступными для всех ваших программ. Находятся они в каталоге /libs/ дистрибутива Smarty. Файл, в котором содержится определение самого класса Smarty, называется Smarty.class.php. Чтобы проверить, доступны ли библиотеки класса              Smarty, нужно написать такой скрипт:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 require('Smarty.class.php');   \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // подключаем файл с\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // описанием класса Smarty\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $smarty = new Smarty; \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     // создаем экземпляр класса Smarty\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если при его исполнении появилась ошибка, то нужно попробовать один из перечисленных ниже вариантов.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // подключаем файл с описанием класса\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 require('c:/users/my/Smarty/libs/\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                      Smarty.class.php');\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $smarty = new Smarty; \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // создаем экземпляр класса Smarty\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0              \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - Добавить директорию, где содержатся библиотеки, в include_path (в этом случае код менять не нужно).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 define("SMARTY_DIR",\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0        "c:/users/my/Smarty/libs/index.html");\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 require(SMARTY_DIR."Smarty.class.php");\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $smarty = new Smarty;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0              \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь, после того как мы убедились, что библиотеки будут найдены, нужно создать директории, необходимые для работы Smarty, по умолчанию имеющие такие имена:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - templates - директория, где мы будем хранить созданные шаблоны;\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - templates_c - директория, где Smarty будет хранить скомпилированные шаблоны;\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - configs - директория для хранения конфигурационных файлов;\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  - cache - директория для кэша.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эти имена задаются свойствами $template_dir, $compile_dir, $config_dir, $cache_dir класса Smarty, поэтому их можно переопределить. Рекомендуется использовать различные наборы директорий для каждого приложения, работающего с шаблонами Smarty. Доступ к перечисленным директориям осуществляется библиотекой Smarty и никогда не выполняется напрямую через web-браузер. Поэтому, чтобы избежать проблем с безопасностью, лучше всего разместить эти              директории там, куда нет доступа через www.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Создадим перечисленные Smarty директории по адресу c:/smarty_dirs/book/. Заметим, что прочитать отсюда данные через браузер нельзя. Пусть наша программа (или приложение) находится по адресу /~my/tasks/book/. Для директорий $compile_dir и $cache_dir Smarty потребуется доступ на запись, так что нужно установить соответствующие им права для сетевого пользователя, с которым ваш сервер работает по умолчанию (обычно это www или nobody).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Чтобы протестировать сделанные настройки, создадим простой шаблон и программу, обрабатывающую его с использованием механизма Smarty.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 index.tpl (является Smarty шаблоном и находится в директории шаблонов c:/smarty_dirs/book/templates/)\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \{* Шаблон Smarty *\}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Привет, \{$name\}!\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 index.php (является кодом нашей программы и находится в директории /~my/tasks/book/ или, что то же самое, в директории c:/users/my/tasks/book/)\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В результате должны получить:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Привет, Вася!\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Все настройки, необходимые для работы нашего приложения, можно вынести в отдельный файл и организовать их в качестве расширения класса Smarty.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Далее более подробно рассмотрим, из каких элементов могут состоять шаблоны Smarty и как их обрабатывать внутри php-скрипта. Начнем с синтаксиса шаблонов.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Основной синтаксис\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Smarty - не просто класс для обработки шаблонов, он определяет целый язык построения шаблонов. Мы коснемся только основных его элементов. Итак, что представляет собой шаблон Smarty? Это набор специальных конструкций (переменных, вызовов функций и методов и т.п) и html-тегов. Все элементы (теги) языка шаблонов Smarty заключаются между символами-ограничителями. По умолчанию это символы фигурных скобок "\{" и "\}", но их можно изменить. Все, что не заключено в такие ограничители,              Smarty рассматривает как константы, не требующие обработки. В шаблоне index.tpl, приведенном выше, \{$name\} - это переменная, а строки "Привет," и "!" - не изменяющиеся в процессе обработки шаблона константы.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Комментарии в Smarty записываются между двумя звездочками:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \{* Это комментарий. После обработки шаблона\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    он на экране не отображается *\}\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Каждый Smarty тег либо выводит значение переменной, либо вызывает какую-либо функцию. Функция записывается следующим образом:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \{имя_функции атрибут1="значение1"\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0              атрибут2="значение2"\}\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Переменные в шаблоне могут быть нескольких типов:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Переменные, значение которым присваивается в php-скрипте пользователя, должны иметь перед именем знак доллара.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Например: \{$first_name\}\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Элементы массива, значения которых были присвоены в php-скрипте пользователя, доступны в шаблоне с помощью синтаксиса \{$имя_массива.ассоциативный_ключ\}.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Например: \{$person.last_name\}\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Элементы не ассоциативного массива доступны с помощью синтаксиса квадратных скобок: \{имя_массива[числовой_индекс]\}\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Например: \{$person[2]\}\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Свойства объектов, заданные в php-скрипте, доступны в шаблоне с помощью такого синтаксиса: \{имя_объекта->имя_свойства\}\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Например: \{$person->email\}\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Переменные, загруженные из конфигурационных файлов (что это такое, мы расскажем чуть позже), заключаются между символами #. Также они доступны как элементы ассоциативного массива $smarty.config.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Например: \{#bodyBgColor#\} или \{$smarty.config.bodyBgColor\}\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Кроме того, существует переменная \{$smarty\}, зарезервированная для некоторых специальных переменных шаблона, таких как переменные HTTP запроса, даты и времени, и т.п.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В шаблонах Smarty определен ряд модификаторов, которые можно применять к переменным, пользовательским функциям или строкам с тем, чтобы модифицировать их значения. Чтобы применить модификатор, нужно указать его название после вертикальной черты, следующей за именем переменной, функции или строкой, к которой он применяется.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Например, чтобы перевести значение переменной \{$title\} в верхний регистр, нужно применить к ней модификатор upper, т.е. написать следующее: \{$title|upper\}\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Можно использовать сразу несколько модификаторов, отделяя их друг от друга прямой вертикальной чертой. Например, \{$title|upper|truncate\} переведет значение переменной в верхний регистр и урежет до 80 символов.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Перечислять все имеющиеся модификаторы мы не будем. Их список можно найти в документации Smarty. Скажем только, что с их помощью можно посчитать число символов, слов и параграфов, дописать строку, задать формат вывода даты и времени, сделать регулярную замену и многое другое.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Конфигурационные файлы\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Конфигурационные файлы используются для того, чтобы управлять глобальными переменными, используемыми в шаблоне, с помощью одного файла. Их идея очень похожа на таблицы стилей css. Конфигурационный файл содержит набор переменных и их значения. Перед именем переменной не ставится никаких дополнительных символов типа знака доллара. Значение переменной по желанию заключают в кавычки (двойные или одинарные), если оно состоит из нескольких строк, то его заключают в тройные кавычки.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 # глобальные переменные\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 pageTitle = "List of documents"\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 bodyBgColor = #000000\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 tableBgColor = #000000\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 rowBgColor = #00ff00\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 [Customer]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 pageTitle = "Список статей"\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Intro = """Это значение состоит из\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      нескольких строк. Поэтому его нужно \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      заключить в тройные кавычки."""\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 # скрытая секция\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 [.Database]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 host=localhost\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 db=book\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 user=nina\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 pass=123\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Конфигурационный файл может состоять из нескольких разделов (секций), каждая из которых имеет имя и может загружаться отдельно от остальных секций. Имя секции заключается в квадратные скобки. Кроме секций в конфигурационном файле могут содержаться глобальные переменные - они не входят ни в одну секцию и всегда загружаются при загрузке конфигурационного файла. Если загружается какая-то одна секция, то загружаются ее переменные и              глобальные переменные. Если переменная существует и как глобальная переменная, и как переменная секции, то используется переменная секции. Если вы одинаково назовете две переменные внутри одной секции, то будет использоваться последняя из них. В приведенном выше примере две секции - Customer и Database, а кроме них заданы глобальные переменные pageTitle, bodyBgColor,              tableBgColor и rowBgColor.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Чтобы спрятать значение переменной или секцию целиком, нужно перед ее именем поставить точку. В таком случае при загрузке конфигурационного файла эти данные нельзя будет прочесть. В примере мы сделали скрытой секцию Database, чтобы нельзя было узнать пароль и имя пользователя, применяемые для установки соединения.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Комментарии в конфигурационном файле можно обозначать символом #.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Загрузка конфигурационных файлов производится с помощью встроенной функции или метода config_load, подробнее об этом мы расскажем в следующей главе.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Методы\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для работы с шаблонами класс Smarty определяет набор методов. Рассмотрим несколько основных методов.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Метод assign\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Синтаксис:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 void assign (смешанное значение);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 void assign (имя переменной, \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0              смешанное значение);\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Метод используется для того, чтобы присвоить значения переменным шаблона. Можно передавать ассоциативные массивы, содержащие пары имя/значение переменных, или передавать пары имя/значение для каждой переменной в отдельности.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <?php\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // передаем пары имя/значение для \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // переменной Name и\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // Address в отдельности\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $smarty->assign("Name","Вася");\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $smarty->assign("Address",$addr); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // здесь $addr может быть и массивом\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // передаем ассоциативный массив\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $smarty->assign(array(\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     "city" => "Новосибирск",\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     "street" => "Пирогова"));\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // таким образом, переменные city и street\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 // получат соответствующие значения\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Метод append\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Синтаксис:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 void append (смешанное значение);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 void append (имя переменной, \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0              смешанное значение);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 void append (имя переменной, \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0              смешанное значение, слияние);\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Принцип действия этого примерно такой же, как и у assign. Метод append позволяет присоединить элемент к массиву. Если вы присоединяете значение к строковой переменной, то она преобразуется в массив, и значение добавляется уже в него. Так же, как и в assign, здесь можно передавать пары ключ/значение или ассоциативные массивы, содержащие эти пары. Если указать третий аргумент слияние равным TRUE, то значение будет не присоединено в качестве еще одного элемента, а слито воедино с текущим массивом.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 $smarty->append(array(\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     title => $title,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     author => $author))\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Здесь если title была строкой, то она становится массивом и к нему добавляется еще один элемент со значением $title. То же самое происходит с переменной author.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Метод config_load\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 void config_load(имя файла, [имя секции]);\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Метод загружает конфигурационный файл и встраивает его в шаблон. Аналогично этому методу действует функция config_load.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Пример: $smarty->config_load("task.conf","Database");\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Метод display\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 void display(шаблон);\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Метод отображает шаблон. У этого метода есть еще два опциональных параметра, о которых можно прочитать в документации.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Метод fetch\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 string fetch(шаблон);\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Этот метод возвращает обработанный шаблон в строковую переменную, вместо того чтобы выводить его на экран. У этого метода есть еще два опциональных параметра, о которых можно прочитать в документации.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Встроенные функции\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Smarty поставляется с набором встроенных функций, интегрированных в язык шаблонов. Нельзя создавать свои функции с такими же именами или модифицировать встроенные функции. Опишем некоторые из таких функций.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Функция config_load\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Синтаксис:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \{config_load file="имя_файла" \}\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эта функция используется для загрузки в шаблон переменных из конфигурационных файлов. Кроме имени загружаемого файла, у этой функции может быть еще несколько дополнительных параметров. Например, параметр section, в котором указывают имя секции для загрузки. Более подробную информацию об этих и других параметрах можно получить из документации Smarty.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Пример:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \{config_load file="task.conf"\}\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Функция capture\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Синтаксис:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \{capture name="имя_блока" \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0          assign="имя_переменной"\} ... \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0          \{/capture\}\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эта функция предназначена для того, чтобы собирать в переменную выходные данные шаблона вместо того, чтобы выводить их на экран. Все, что находится между \{capture name="varname"\} и \{/capture\}, будет записано в переменную с именем varname. Захваченный таким образом контент может быть использован в шаблоне посредством специальной переменной $smarty.capture.varname, где varname - значение, переданное в атрибут name функции capture. Если имя              переменной не задано, будет использовано имя default.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Второй параметр assign задает имя переменной, которой будет присвоено захваченное выходное значение. Этот параметр, как и name, не обязательный.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Функция section\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Синтаксис:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \{section name="имя_секции"\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 loop="переменная_для_выч-ния_числа_итераций"\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 [,start="индекс_начальной_позиции"] \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 [, step="шаг"] [,max="максимум_итераций"] \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 [,show="показывать_ли_секцию"] \}... \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \{/section\}\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Секция Section - это цикл для обхода элементов массива. Обязательными являются параметры name, с помощью которого задается имя секции, и loop, который представляет собой переменную, определяющую число итераций цикла. Как правило, loop - это переменная типа массив, и число итераций секции равно числу элементов этого массива. Чтобы вывести переменную внутри цикла, нужно после имени переменной указать в квадратных скобках имя секции.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \{section name=art loop=$title\}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    Название: \{$title[art]\}<br>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \{/section\}\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Функция foreach\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Синтаксис:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \{foreach from="имя_массива" \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0          item="имя_текущего_элемента"\}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    ... \{/foreach\}\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Кроме того, можно использовать дополнительные атрибуты key - имя ключа для текущего элемента массива и name - имя цикла, с помощью которого можно будет получать доступ к его свойствам. Атрибуты from и item - обязательные.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Циклы foreach являются альтернативой циклам section. Действие функции foreach очень похоже на работу цикла foreach в языке PHP.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \{foreach from=$articles item=art\}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Title: \{$art\}<br>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \{/foreach\}\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Циклы foreach имеют свои собственные свойства. Получить доступ к ним можно таким образом: \{$smarty.foreach.foreachname.varname\}, где foreachname - это имя цикла, заданное его параметром name, а varname - имя свойства.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Оператор if, elseif, else\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Синтаксис:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \{if выражение\} блок_действий\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    \{elseif выражение1\} блок_действий1\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    \{else\} блок_действий2\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \{/if\}\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Действие оператора практически аналогично оператору if...elseif...else языка PHP. В выражениях могут использоваться следующие операторы сравнения: eq, ne, neq, gt, lt, lte, le, gte, ge, is even, is odd, is not even, is not odd, not, mod, div by, even by, odd by, ==, !=, >, <, <=, >=. Каждый из них обязательно должен быть отделен от окружающих его значений пробелами. В выражениях можно использовать круглые скобки и вызывать php-функции.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \{if $name eq "Вася"\}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    Добро пожаловать, Вася.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \{elseif $name eq "Петя"\}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    Добро пожаловать, Петя.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \{else\}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    Добро пожаловать. А вы кто?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \{/if\}\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \{* этот пример не будет работать, \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    поскольку не поставлены\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    пробелы вокруг операторов сравнения *\}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \{if $name=="Вася" || $name=="Петя"\}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ...\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \{/if\}\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Решение задачи с помощью шаблонов Smarty\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь, после знакомства с основными конструкциями Smarty, мы можем попытаться решить задачу отображения списка документов. Шаблон списка будет выглядеть следующим образом:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \{* Smarty template index.tpl *\}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \{config_load file="task.conf" \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <html>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <head><title>\{#pageTitle#\}</title>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 </head>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <body>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <ol>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \{section name=art loop=$title\}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    <li><a href="\{$fulltext[art]\}">\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0       \{$title[art]\}</a>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0       (\{$author[art]\})\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    <br> <p> \{$abstract[art]\}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \{/section\}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 </ol>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 </body>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 </html>\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В файле конфигурации task.conf будем хранить название страницы и параметры для доступа к базе данных:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 # глобальные переменные\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 pageTitle = "List of documents"\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 [Customer]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 pageTitle = "Список статей"\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 [Database]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 host=localhost\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 db=book\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 user=nina\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 pass=123\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Скрипт (index.php), обрабатывающий написанный нами шаблон, может выглядеть таким образом:\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Как вы, скорее всего, заметили, программа получилась еще более громоздкой, чем в первых двух случаях, когда использовалась простая замена значений и шаблоны FastTemplate. Действительно, механизм Smarty гораздо более сложен, чем тот же FastTemplate, но зато и более функционален.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Заключение\b0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Итак, в этой лекции было рассказано о том, что такое шаблоны и как их можно использовать при программировании web-приложений на языке PHP. Мы рассмотрели три способа решения задачи отображения сложного списка документов: с помощью функции регулярной замены, с помощью класса шаблонов FastTemplate и с помощью языка шаблонов Smarty. При этом мы познакомились с основными свойствами, методами и функциями классов FastTemplate и Smarty.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0   Литература\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0  Учебники к курсу\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  1.  Савельева Н.В.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Основы программирования на PHP\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Интернет-университет информационных технологий - ИНТУИТ.ру, 2005 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 2. Анисимов А.Е., Пупышев В.В.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Сборник заданий по основаниям программирования\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  БИНОМ. Лаборатория знаний, Интернет-университет информационных технологий - ИНТУИТ.ру, 2006 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 3. Непейвода Н.Н.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Стили и методы программирования\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Интернет-университет информационных технологий - ИНТУИТ.ру, 2005 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 4. Сузи Р.А.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Язык программирования Python\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  БИНОМ. Лаборатория знаний, Интернет-университет информационных технологий - ИНТУИТ.ру, 2006 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 5. Терехов А.Н.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Технология программирования\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  БИНОМ. Лаборатория знаний, Интернет-университет информационных технологий - ИНТУИТ.ру, 2006 \par
\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 Список литературы\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 1. Справочное руководство по языку PHP\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 http://www.php.net/\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 2. История PHP\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 http://chukotken.boom.ru/php/2.html\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 3.  Краткое руководство по языку HMTL\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 http://www.ict.nsc.ru/win/docs/html-gd/html-gd.dhtml\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 4. Федотов А. М.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Введение в интернет\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 http://www.ict.nsc.ru/win/fedotov/inter/index.html\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 5. GET и POST – чем отличаются, как использовать, вопросы безопасности\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 http://netadmin.ws/art/43.html\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 6. Храмцов П. Б.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Администрирование сети и сервисов Internet\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 7. Эйзенберг Э., Мелтон Д.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 SQL:1999, ранее известный как SQL3\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 8. Справочное руководство по MySQL\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 http://www.mysql.ru/docs/man/index.html\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 9. C. Shifflett\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Правда о сессиях\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Перевод С. Бресь\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 10. Грималовский А.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Сессии в PHP providerZ.ru\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 11. Куликов А.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Сессии в PHP\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 http://www.koulikov.cc\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0   Программное обеспечение\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 1.	PHP || The PHP Group \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 http://www.php.net/index.html\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Скрипт-язык для web-программирования.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Наиболее гибкий, удобный, простой и достаточно мощный язык, созданный специально для web-программистов, который интерпретируется и выполняется на сервере. Значительно облегчает написание динамических web-страниц.\par
\par
\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 2. Apache || Apache Software Foundation \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 http://www.apache.org/index.html\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 HTTP (WEB) сервер\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Самый популярный web-сервер, именно на этом сервере работают большинство сайтов Интернета. Информация об установке: http://httpd.apache.org/docs/2.2/install.html\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Лицензия: Apache License, Version 2.0, January 2004, http://www.apache.org/licenses/\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Требования к системе (Windows): До 50Мб дискового пространства для установки, после установки примерно 10Мб.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Требования к системе (Linux): До 50Мб дискового пространства для установки, после установки примерно 10Мб.\par
\par
\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 3. Apache Ant || Apache Software Foundation \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 http://www.apache.org/index.html\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Пакет Apache Ant это Java-основанное средство сборки.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Пакет Apache Ant это Java-основанное средство сборки. Теоретически, это разновидность make, но без складок make. Ant другой. Вместо модели, где он расширялся бы с помощью shell-основанных команд, Ant расширяется Java классами. Вместо написания команд оболочки, файлы конфигурации основаны на XML и вызываются из дерева целей, в котором различные задачи были запущены. Каждая задача запускается объектом, который включает особый интерфейс задачи.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Лицензия: Apache License, Version 2.0, January 2004, http://www.apache.org/licenses/\par
\par
\par

\s0 \f0\qc\fi0\li0\ri0 Спасибо, что скачали книгу в 
{\field{\*\fldinst{HYPERLINK "http://royallib.ru" }}{\fldrslt \ul бесплатной электронной библиотеке Royallib.ru}}
\par

\s0 \f0\qc\fi0\li0\ri0 
{\field{\*\fldinst{HYPERLINK "http://royallib.ru/comment/saveleva_nina/kurs_yazik_programmirovaniya_PHP.html" }}{\fldrslt \ul Оставить отзыв о книге}}
\par

\s0 \f0\qc\fi0\li0\ri0 
{\field{\*\fldinst{HYPERLINK "http://royallib.ru/author/saveleva_nina.html" }}{\fldrslt \ul Все книги автора}}
\par

}
